CCS PCD C Compiler, Version 5.015, 5967               02-feb.-22 15:07

               Filename:   C:\Users\dwegg\Google Drive\e-Tech\BMS\Slave_Algorithm\src\main.lst

               ROM used:   11302 bytes (13%)
                           Largest free fragment is 54234
               RAM used:   753 (9%) at main() level
                           881 (11%) worst case
               Stack size: 128

*
00000:  GOTO    1C98
*
00022:  DATA    1A,0D,00
*
00058:  DATA    E2,0D,00
0005A:  DATA    40,0D,00
.................... #include <24HJ128GP502.h> 
.................... //////////// Standard Header file for the PIC24HJ128GP502 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24HJ128GP502 
*
00200:  CLR     32
00202:  MOV     #156,W3
00204:  SUB     W0,W3,W3
00206:  BRA     C,210
00208:  MOV     #220,W3
0020A:  ADD     W3,W0,W0
0020C:  TBLRDL  [W0],W0
0020E:  RETURN  
00210:  MOV     #220,W0
00212:  ADD     W3,W3,W3
00214:  ADD     W3,W0,W3
00216:  TBLRDH  [W3++],W0
00218:  TBLRDH  [W3],W3
0021A:  SL      W3,#8,W3
0021C:  IOR      W3,  W0,W0
0021E:  RETURN  
00220:  DATA    00,00,08
00222:  DATA    99,C5,06
00224:  DATA    AB,CE,F5
00226:  DATA    32,0B,D5
00228:  DATA    CF,D8,6C
0022A:  DATA    56,1D,10
0022C:  DATA    64,16,5E
0022E:  DATA    FD,D3,1B
00230:  DATA    07,F4,C7
00232:  DATA    9E,31,DE
00234:  DATA    AC,3A,AA
00236:  DATA    35,FF,54
00238:  DATA    C8,2C,33
0023A:  DATA    51,E9,91
0023C:  DATA    63,E2,01
0023E:  DATA    FA,27,9A
00240:  DATA    97,AD,98
00242:  DATA    0E,68,5F
00244:  DATA    3C,63,65
00246:  DATA    A5,A6,8C
00248:  DATA    58,75,FC
0024A:  DATA    C1,B0,49
0024C:  DATA    F3,BB,CE
0024E:  DATA    6A,7E,42
00250:  DATA    90,59,57
00252:  DATA    09,9C,87
00254:  DATA    3B,97,AD
00256:  DATA    A2,52,A0
00258:  DATA    5F,81,34
0025A:  DATA    C6,44,65
0025C:  DATA    F4,4F,06
0025E:  DATA    6D,8A,6E
00260:  DATA    2E,5B,9F
00262:  DATA    B7,9E,AB
00264:  DATA    85,95,62
00266:  DATA    1C,50,78
00268:  DATA    E1,83,FB
0026A:  DATA    78,46,BD
0026C:  DATA    4A,4D,C9
0026E:  DATA    D3,88,B6
00270:  DATA    29,AF,50
00272:  DATA    B0,6A,73
00274:  DATA    82,61,D6
00276:  DATA    1B,A4,51
00278:  DATA    E6,77,4F
0027A:  DATA    7F,B2,94
0027C:  DATA    4D,B9,7D
0027E:  DATA    D4,7C,9F
00280:  DATA    B9,F6,E4
00282:  DATA    20,33,5A
00284:  DATA    12,38,19
00286:  DATA    8B,FD,89
00288:  DATA    76,2E,80
0028A:  DATA    EF,EB,4C
0028C:  DATA    DD,E0,B2
0028E:  DATA    44,25,47
00290:  DATA    BE,02,2B
00292:  DATA    27,C7,82
00294:  DATA    15,CC,D1
00296:  DATA    8C,09,A5
00298:  DATA    71,DA,48
0029A:  DATA    E8,1F,60
0029C:  DATA    DA,14,7A
0029E:  DATA    43,D1,6B
002A0:  DATA    C5,F3,E3
002A2:  DATA    5C,36,AE
002A4:  DATA    6E,3D,1E
002A6:  DATA    F7,F8,7D
002A8:  DATA    0A,2B,87
002AA:  DATA    93,EE,B8
002AC:  DATA    A1,E5,B5
002AE:  DATA    38,20,B3
002B0:  DATA    C2,07,2C
002B2:  DATA    5B,C2,76
002B4:  DATA    69,C9,41
002B6:  DATA    F0,0C,FC
002B8:  DATA    0D,DF,D8
002BA:  DATA    94,1A,39
002BC:  DATA    A6,11,EA
002BE:  DATA    3F,D4,32
002C0:  DATA    52,5E,73
002C2:  DATA    CB,9B,F7
002C4:  DATA    F9,90,8E
002C6:  DATA    60,55,24
002C8:  DATA    9D,86,17
002CA:  DATA    04,43,E1
002CC:  DATA    36,48,25
002CE:  DATA    AF,8D,EA
002D0:  DATA    55,AA,BC
002D2:  DATA    CC,6F,2F
002D4:  DATA    FE,64,46
002D6:  DATA    67,A1,08
002D8:  DATA    9A,72,DF
002DA:  DATA    03,B7,CD
002DC:  DATA    31,BC,ED
002DE:  DATA    A8,79,C6
002E0:  DATA    EB,A8,74
002E2:  DATA    72,6D,03
002E4:  DATA    40,66,89
002E6:  DATA    D9,A3,D0
002E8:  DATA    24,70,10
002EA:  DATA    BD,B5,15
002EC:  DATA    8F,BE,22
002EE:  DATA    16,7B,1E
002F0:  DATA    EC,5C,BB
002F2:  DATA    75,99,DB
002F4:  DATA    47,92,F8
002F6:  DATA    DE,57,0A
002F8:  DATA    23,84,61
002FA:  DATA    BA,41,CF
002FC:  DATA    88,4A,53
002FE:  DATA    11,8F,C4
00300:  DATA    7C,05,CA
00302:  DATA    E5,C0,01
00304:  DATA    D7,CB,37
00306:  DATA    4E,0E,D2
00308:  DATA    B3,DD,AE
0030A:  DATA    2A,18,17
0030C:  DATA    18,13,9C
0030E:  DATA    81,D6,1C
00310:  DATA    7B,F1,05
00312:  DATA    E2,34,D9
00314:  DATA    D0,3F,FF
00316:  DATA    49,FA,FE
00318:  DATA    B4,29,66
0031A:  DATA    2D,EC,3B
0031C:  DATA    1F,E7,54
0031E:  DATA    86,22,30
00320:  DATA    13,A2,CD
00322:  DATA    8A,67,F5
00324:  DATA    B8,6C,30
00326:  DATA    21,A9,26
00328:  DATA    DC,7A,A9
0032A:  DATA    45,BF,E3
0032C:  DATA    77,B4,9B
0032E:  DATA    EE,71,E8
00330:  DATA    14,56,02
00332:  DATA    8D,93,2D
00334:  DATA    BF,98,6F
00336:  DATA    26,5D,A7
00338:  DATA    DB,8E,F6
0033A:  DATA    42,4B,62
0033C:  DATA    70,40,C4
0033E:  DATA    E9,85,69
00340:  DATA    84,0F,5D
00342:  DATA    1D,CA,AC
00344:  DATA    2F,C1,A0
00346:  DATA    B6,04,7F
00348:  DATA    4B,D7,39
0034A:  DATA    D2,12,BA
0034C:  DATA    E0,19,0B
0034E:  DATA    79,DC,B1
00350:  DATA    83,FB,92
00352:  DATA    1A,3E,74
00354:  DATA    28,35,68
00356:  DATA    B1,F0,53
00358:  DATA    4C,23,F1
0035A:  DATA    D5,E6,96
0035C:  DATA    E7,ED,C3
0035E:  DATA    7E,28,9D
00360:  DATA    3D,F9,5A
00362:  DATA    A4,3C,58
00364:  DATA    96,37,A7
00366:  DATA    0F,F2,8B
00368:  DATA    F2,21,3E
0036A:  DATA    6B,E4,4E
0036C:  DATA    59,EF,0C
0036E:  DATA    C0,2A,45
00370:  DATA    3A,0D,95
00372:  DATA    A3,C8,80
00374:  DATA    91,C3,00
00376:  CLR     32
00378:  MOV     #4B2,W3
0037A:  SUB     W0,W3,W3
0037C:  BRA     C,386
0037E:  MOV     #396,W3
00380:  ADD     W3,W0,W0
00382:  TBLRDL  [W0],W0
00384:  RETURN  
00386:  MOV     #396,W0
00388:  ADD     W3,W3,W3
0038A:  ADD     W3,W0,W3
0038C:  TBLRDH  [W3++],W0
0038E:  TBLRDH  [W3],W3
00390:  SL      W3,#8,W3
00392:  IOR      W3,  W0,W0
00394:  RETURN  
00396:  DATA    00,00,59
00398:  DATA    01,00,02
0039A:  DATA    02,00,5A
0039C:  DATA    03,00,02
0039E:  DATA    04,00,5B
003A0:  DATA    05,00,02
003A2:  DATA    06,00,5C
003A4:  DATA    07,00,02
003A6:  DATA    08,00,5D
003A8:  DATA    09,00,02
003AA:  DATA    0A,00,5E
003AC:  DATA    0B,00,02
003AE:  DATA    0C,00,5F
003B0:  DATA    0D,00,02
003B2:  DATA    0E,00,60
003B4:  DATA    0F,00,02
003B6:  DATA    10,00,61
003B8:  DATA    11,00,02
003BA:  DATA    12,00,62
003BC:  DATA    13,00,02
003BE:  DATA    14,00,63
003C0:  DATA    15,00,02
003C2:  DATA    16,00,64
003C4:  DATA    17,00,02
003C6:  DATA    18,00,65
003C8:  DATA    19,00,02
003CA:  DATA    1A,00,66
003CC:  DATA    1B,00,02
003CE:  DATA    1C,00,67
003D0:  DATA    1D,00,02
003D2:  DATA    1E,00,68
003D4:  DATA    1F,00,02
003D6:  DATA    20,00,69
003D8:  DATA    21,00,02
003DA:  DATA    22,00,6A
003DC:  DATA    23,00,02
003DE:  DATA    24,00,6B
003E0:  DATA    25,00,02
003E2:  DATA    26,00,6C
003E4:  DATA    27,00,02
003E6:  DATA    28,00,6D
003E8:  DATA    29,00,02
003EA:  DATA    2A,00,6E
003EC:  DATA    2B,00,02
003EE:  DATA    2C,00,6F
003F0:  DATA    2D,00,02
003F2:  DATA    2E,00,70
003F4:  DATA    2F,00,02
003F6:  DATA    30,00,71
003F8:  DATA    31,00,02
003FA:  DATA    32,00,72
003FC:  DATA    33,00,02
003FE:  DATA    34,00,73
00400:  DATA    35,00,02
00402:  DATA    36,00,74
00404:  DATA    37,00,02
00406:  DATA    38,00,75
00408:  DATA    39,00,02
0040A:  DATA    3A,00,76
0040C:  DATA    3B,00,02
0040E:  DATA    3C,00,77
00410:  DATA    3D,00,02
00412:  DATA    3E,00,78
00414:  DATA    3F,00,02
00416:  DATA    40,00,79
00418:  DATA    41,00,02
0041A:  DATA    42,00,7A
0041C:  DATA    43,00,02
0041E:  DATA    44,00,7B
00420:  DATA    45,00,02
00422:  DATA    46,00,7C
00424:  DATA    47,00,02
00426:  DATA    48,00,7D
00428:  DATA    49,00,02
0042A:  DATA    4A,00,7E
0042C:  DATA    4B,00,02
0042E:  DATA    4C,00,7F
00430:  DATA    4D,00,02
00432:  DATA    4E,00,80
00434:  DATA    4F,00,02
00436:  DATA    50,00,81
00438:  DATA    51,00,02
0043A:  DATA    52,00,82
0043C:  DATA    53,00,02
0043E:  DATA    54,00,83
00440:  DATA    55,00,02
00442:  DATA    56,00,84
00444:  DATA    57,00,02
00446:  DATA    58,00,85
00448:  DATA    59,00,02
0044A:  DATA    5A,00,86
0044C:  DATA    5B,00,02
0044E:  DATA    5C,00,87
00450:  DATA    5D,00,02
00452:  DATA    5E,00,88
00454:  DATA    5F,00,02
00456:  DATA    60,00,89
00458:  DATA    61,00,02
0045A:  DATA    62,00,8A
0045C:  DATA    63,00,02
0045E:  DATA    64,00,8B
00460:  DATA    65,00,02
00462:  DATA    66,00,8C
00464:  DATA    67,00,02
00466:  DATA    68,00,8D
00468:  DATA    69,00,02
0046A:  DATA    6A,00,8E
0046C:  DATA    6B,00,02
0046E:  DATA    6C,00,8F
00470:  DATA    6D,00,02
00472:  DATA    6E,00,90
00474:  DATA    6F,00,02
00476:  DATA    70,00,91
00478:  DATA    71,00,02
0047A:  DATA    72,00,92
0047C:  DATA    73,00,02
0047E:  DATA    74,00,93
00480:  DATA    75,00,02
00482:  DATA    76,00,94
00484:  DATA    77,00,02
00486:  DATA    78,00,95
00488:  DATA    79,00,02
0048A:  DATA    7A,00,96
0048C:  DATA    7B,00,02
0048E:  DATA    7C,00,97
00490:  DATA    7D,00,02
00492:  DATA    7E,00,98
00494:  DATA    7F,00,02
00496:  DATA    80,00,99
00498:  DATA    81,00,02
0049A:  DATA    82,00,9A
0049C:  DATA    83,00,02
0049E:  DATA    84,00,9B
004A0:  DATA    85,00,02
004A2:  DATA    86,00,9C
004A4:  DATA    87,00,02
004A6:  DATA    88,00,9D
004A8:  DATA    89,00,02
004AA:  DATA    8A,00,9E
004AC:  DATA    8B,00,02
004AE:  DATA    8C,00,9F
004B0:  DATA    8D,00,02
004B2:  DATA    8E,00,A0
004B4:  DATA    8F,00,02
004B6:  DATA    90,00,A1
004B8:  DATA    91,00,02
004BA:  DATA    92,00,A2
004BC:  DATA    93,00,02
004BE:  DATA    94,00,A3
004C0:  DATA    95,00,02
004C2:  DATA    96,00,A4
004C4:  DATA    97,00,02
004C6:  DATA    98,00,A5
004C8:  DATA    99,00,02
004CA:  DATA    9A,00,A6
004CC:  DATA    9B,00,02
004CE:  DATA    9C,00,A7
004D0:  DATA    9D,00,02
004D2:  DATA    9E,00,A8
004D4:  DATA    9F,00,02
004D6:  DATA    A0,00,A9
004D8:  DATA    A1,00,02
004DA:  DATA    A2,00,AA
004DC:  DATA    A3,00,02
004DE:  DATA    A4,00,AB
004E0:  DATA    A5,00,02
004E2:  DATA    A6,00,AC
004E4:  DATA    A7,00,02
004E6:  DATA    A8,00,AD
004E8:  DATA    A9,00,02
004EA:  DATA    AA,00,AE
004EC:  DATA    AB,00,02
004EE:  DATA    AC,00,AF
004F0:  DATA    AD,00,02
004F2:  DATA    AE,00,B0
004F4:  DATA    AF,00,02
004F6:  DATA    B0,00,B1
004F8:  DATA    B1,00,02
004FA:  DATA    B2,00,B2
004FC:  DATA    B3,00,02
004FE:  DATA    B4,00,B3
00500:  DATA    B5,00,02
00502:  DATA    B6,00,B4
00504:  DATA    B7,00,02
00506:  DATA    B8,00,B5
00508:  DATA    B9,00,02
0050A:  DATA    BA,00,B6
0050C:  DATA    BB,00,02
0050E:  DATA    BC,00,B7
00510:  DATA    BD,00,02
00512:  DATA    BE,00,B8
00514:  DATA    BF,00,02
00516:  DATA    C0,00,B9
00518:  DATA    C1,00,02
0051A:  DATA    C2,00,BA
0051C:  DATA    C3,00,02
0051E:  DATA    C4,00,BB
00520:  DATA    C5,00,02
00522:  DATA    C6,00,BC
00524:  DATA    C7,00,02
00526:  DATA    C8,00,BD
00528:  DATA    C9,00,02
0052A:  DATA    CA,00,BE
0052C:  DATA    CB,00,02
0052E:  DATA    CC,00,BF
00530:  DATA    CD,00,02
00532:  DATA    CE,00,C0
00534:  DATA    CF,00,02
00536:  DATA    D0,00,C1
00538:  DATA    D1,00,02
0053A:  DATA    D2,00,C2
0053C:  DATA    D3,00,02
0053E:  DATA    D4,00,C3
00540:  DATA    D5,00,02
00542:  DATA    D6,00,C4
00544:  DATA    D7,00,02
00546:  DATA    D8,00,C5
00548:  DATA    D9,00,02
0054A:  DATA    DA,00,C6
0054C:  DATA    DB,00,02
0054E:  DATA    DC,00,C7
00550:  DATA    DD,00,02
00552:  DATA    DE,00,C8
00554:  DATA    DF,00,02
00556:  DATA    E0,00,C9
00558:  DATA    E1,00,02
0055A:  DATA    E2,00,CA
0055C:  DATA    E3,00,02
0055E:  DATA    E4,00,CB
00560:  DATA    E5,00,02
00562:  DATA    E6,00,CC
00564:  DATA    E7,00,02
00566:  DATA    E8,00,CD
00568:  DATA    E9,00,02
0056A:  DATA    EA,00,CE
0056C:  DATA    EB,00,02
0056E:  DATA    EC,00,CF
00570:  DATA    ED,00,02
00572:  DATA    EE,00,D0
00574:  DATA    EF,00,02
00576:  DATA    F0,00,D1
00578:  DATA    F1,00,02
0057A:  DATA    F2,00,D2
0057C:  DATA    F3,00,02
0057E:  DATA    F4,00,D3
00580:  DATA    F5,00,02
00582:  DATA    F6,00,D4
00584:  DATA    F7,00,02
00586:  DATA    F8,00,D5
00588:  DATA    F9,00,02
0058A:  DATA    FA,00,D6
0058C:  DATA    FB,00,02
0058E:  DATA    FC,00,D7
00590:  DATA    FD,00,02
00592:  DATA    FE,00,D8
00594:  DATA    FF,00,02
00596:  DATA    00,01,D9
00598:  DATA    01,01,02
0059A:  DATA    02,01,DA
0059C:  DATA    03,01,02
0059E:  DATA    04,01,DB
005A0:  DATA    05,01,02
005A2:  DATA    06,01,DC
005A4:  DATA    07,01,02
005A6:  DATA    08,01,DD
005A8:  DATA    09,01,02
005AA:  DATA    0A,01,DE
005AC:  DATA    0B,01,02
005AE:  DATA    0C,01,DF
005B0:  DATA    0D,01,02
005B2:  DATA    0E,01,E0
005B4:  DATA    0F,01,02
005B6:  DATA    10,01,E1
005B8:  DATA    11,01,02
005BA:  DATA    12,01,E2
005BC:  DATA    13,01,02
005BE:  DATA    14,01,E3
005C0:  DATA    15,01,02
005C2:  DATA    16,01,E4
005C4:  DATA    17,01,02
005C6:  DATA    18,01,E5
005C8:  DATA    19,01,02
005CA:  DATA    1A,01,E6
005CC:  DATA    1B,01,02
005CE:  DATA    1C,01,E7
005D0:  DATA    1D,01,02
005D2:  DATA    1E,01,E8
005D4:  DATA    1F,01,02
005D6:  DATA    20,01,E9
005D8:  DATA    21,01,02
005DA:  DATA    22,01,EA
005DC:  DATA    23,01,02
005DE:  DATA    24,01,EB
005E0:  DATA    25,01,02
005E2:  DATA    26,01,EC
005E4:  DATA    27,01,02
005E6:  DATA    28,01,ED
005E8:  DATA    29,01,02
005EA:  DATA    2A,01,EE
005EC:  DATA    2B,01,02
005EE:  DATA    2C,01,EF
005F0:  DATA    2D,01,02
005F2:  DATA    2E,01,F0
005F4:  DATA    2F,01,02
005F6:  DATA    30,01,F1
005F8:  DATA    31,01,02
005FA:  DATA    32,01,F2
005FC:  DATA    33,01,02
005FE:  DATA    34,01,F3
00600:  DATA    35,01,02
00602:  DATA    36,01,F4
00604:  DATA    37,01,02
00606:  DATA    38,01,F5
00608:  DATA    39,01,02
0060A:  DATA    3A,01,F6
0060C:  DATA    3B,01,02
0060E:  DATA    3C,01,F7
00610:  DATA    3D,01,02
00612:  DATA    3E,01,F8
00614:  DATA    3F,01,02
00616:  DATA    40,01,F9
00618:  DATA    41,01,02
0061A:  DATA    42,01,FA
0061C:  DATA    43,01,02
0061E:  DATA    44,01,FB
00620:  DATA    45,01,02
00622:  DATA    46,01,FC
00624:  DATA    47,01,02
00626:  DATA    48,01,FD
00628:  DATA    49,01,02
0062A:  DATA    4A,01,FE
0062C:  DATA    4B,01,02
0062E:  DATA    4C,01,FF
00630:  DATA    4D,01,02
00632:  DATA    4E,01,00
00634:  DATA    4F,01,03
00636:  DATA    50,01,01
00638:  DATA    51,01,03
0063A:  DATA    52,01,02
0063C:  DATA    53,01,03
0063E:  DATA    54,01,03
00640:  DATA    55,01,03
00642:  DATA    56,01,04
00644:  DATA    57,01,03
00646:  DATA    58,01,05
00648:  DATA    59,01,03
0064A:  DATA    5A,01,06
0064C:  DATA    5B,01,03
0064E:  DATA    5C,01,07
00650:  DATA    5D,01,03
00652:  DATA    5E,01,08
00654:  DATA    5F,01,03
00656:  DATA    60,01,09
00658:  DATA    61,01,03
0065A:  DATA    62,01,0A
0065C:  DATA    63,01,03
0065E:  DATA    64,01,0B
00660:  DATA    65,01,03
00662:  DATA    66,01,0C
00664:  DATA    67,01,03
00666:  DATA    68,01,0D
00668:  DATA    69,01,03
0066A:  DATA    6A,01,0E
0066C:  DATA    6B,01,03
0066E:  DATA    6C,01,0F
00670:  DATA    6D,01,03
00672:  DATA    6E,01,10
00674:  DATA    6F,01,03
00676:  DATA    70,01,11
00678:  DATA    71,01,03
0067A:  DATA    72,01,12
0067C:  DATA    73,01,03
0067E:  DATA    74,01,13
00680:  DATA    75,01,03
00682:  DATA    76,01,14
00684:  DATA    77,01,03
00686:  DATA    78,01,15
00688:  DATA    79,01,03
0068A:  DATA    7A,01,16
0068C:  DATA    7B,01,03
0068E:  DATA    7C,01,17
00690:  DATA    7D,01,03
00692:  DATA    7E,01,18
00694:  DATA    7F,01,03
00696:  DATA    80,01,19
00698:  DATA    81,01,03
0069A:  DATA    82,01,1A
0069C:  DATA    83,01,03
0069E:  DATA    84,01,1B
006A0:  DATA    85,01,03
006A2:  DATA    86,01,1C
006A4:  DATA    87,01,03
006A6:  DATA    88,01,1D
006A8:  DATA    89,01,03
006AA:  DATA    8A,01,1E
006AC:  DATA    8B,01,03
006AE:  DATA    8C,01,1F
006B0:  DATA    8D,01,03
006B2:  DATA    8E,01,20
006B4:  DATA    8F,01,03
006B6:  DATA    90,01,21
006B8:  DATA    91,01,03
006BA:  DATA    92,01,22
006BC:  DATA    93,01,03
006BE:  DATA    94,01,23
006C0:  DATA    95,01,03
006C2:  DATA    96,01,24
006C4:  DATA    97,01,03
006C6:  DATA    98,01,25
006C8:  DATA    99,01,03
006CA:  DATA    9A,01,26
006CC:  DATA    9B,01,03
006CE:  DATA    9C,01,27
006D0:  DATA    9D,01,03
006D2:  DATA    9E,01,28
006D4:  DATA    9F,01,03
006D6:  DATA    A0,01,29
006D8:  DATA    A1,01,03
006DA:  DATA    A2,01,2A
006DC:  DATA    A3,01,03
006DE:  DATA    A4,01,2B
006E0:  DATA    A5,01,03
006E2:  DATA    A6,01,2C
006E4:  DATA    A7,01,03
006E6:  DATA    A8,01,2D
006E8:  DATA    A9,01,03
006EA:  DATA    AA,01,2E
006EC:  DATA    AB,01,03
006EE:  DATA    AC,01,2F
006F0:  DATA    AD,01,03
006F2:  DATA    AE,01,30
006F4:  DATA    AF,01,03
006F6:  DATA    B0,01,31
006F8:  DATA    B1,01,03
006FA:  DATA    B2,01,32
006FC:  DATA    B3,01,03
006FE:  DATA    B4,01,33
00700:  DATA    B5,01,03
00702:  DATA    B6,01,34
00704:  DATA    B7,01,03
00706:  DATA    B8,01,35
00708:  DATA    B9,01,03
0070A:  DATA    BA,01,36
0070C:  DATA    BB,01,03
0070E:  DATA    BC,01,37
00710:  DATA    BD,01,03
00712:  DATA    BE,01,38
00714:  DATA    BF,01,03
00716:  DATA    C0,01,39
00718:  DATA    C1,01,03
0071A:  DATA    C2,01,3A
0071C:  DATA    C3,01,03
0071E:  DATA    C4,01,3B
00720:  DATA    C5,01,03
00722:  DATA    C6,01,3C
00724:  DATA    C7,01,03
00726:  DATA    C8,01,3D
00728:  DATA    C9,01,03
0072A:  DATA    CA,01,3E
0072C:  DATA    CB,01,03
0072E:  DATA    CC,01,3F
00730:  DATA    CD,01,03
00732:  DATA    CE,01,40
00734:  DATA    CF,01,03
00736:  DATA    D0,01,41
00738:  DATA    D1,01,03
0073A:  DATA    D2,01,42
0073C:  DATA    D3,01,03
0073E:  DATA    D4,01,43
00740:  DATA    D5,01,03
00742:  DATA    D6,01,44
00744:  DATA    D7,01,03
00746:  DATA    D8,01,45
00748:  DATA    D9,01,03
0074A:  DATA    DA,01,46
0074C:  DATA    DB,01,03
0074E:  DATA    DC,01,47
00750:  DATA    DD,01,03
00752:  DATA    DE,01,48
00754:  DATA    DF,01,03
00756:  DATA    E0,01,49
00758:  DATA    E1,01,03
0075A:  DATA    E2,01,4A
0075C:  DATA    E3,01,03
0075E:  DATA    E4,01,4B
00760:  DATA    E5,01,03
00762:  DATA    E6,01,4C
00764:  DATA    E7,01,03
00766:  DATA    E8,01,4D
00768:  DATA    E9,01,03
0076A:  DATA    EA,01,4E
0076C:  DATA    EB,01,03
0076E:  DATA    EC,01,4F
00770:  DATA    ED,01,03
00772:  DATA    EE,01,50
00774:  DATA    EF,01,03
00776:  DATA    F0,01,51
00778:  DATA    F1,01,03
0077A:  DATA    F2,01,52
0077C:  DATA    F3,01,03
0077E:  DATA    F4,01,53
00780:  DATA    F5,01,03
00782:  DATA    F6,01,54
00784:  DATA    F7,01,03
00786:  DATA    F8,01,55
00788:  DATA    F9,01,03
0078A:  DATA    FA,01,56
0078C:  DATA    FB,01,03
0078E:  DATA    FC,01,57
00790:  DATA    FD,01,03
00792:  DATA    FE,01,58
00794:  DATA    FF,01,03
00796:  DATA    00,02,59
00798:  DATA    01,02,03
0079A:  DATA    02,02,5A
0079C:  DATA    03,02,03
0079E:  DATA    04,02,5B
007A0:  DATA    05,02,03
007A2:  DATA    06,02,5C
007A4:  DATA    07,02,03
007A6:  DATA    08,02,5D
007A8:  DATA    09,02,03
007AA:  DATA    0A,02,5E
007AC:  DATA    0B,02,03
007AE:  DATA    0C,02,5F
007B0:  DATA    0D,02,03
007B2:  DATA    0E,02,60
007B4:  DATA    0F,02,03
007B6:  DATA    10,02,61
007B8:  DATA    11,02,03
007BA:  DATA    12,02,62
007BC:  DATA    13,02,03
007BE:  DATA    14,02,63
007C0:  DATA    15,02,03
007C2:  DATA    16,02,64
007C4:  DATA    17,02,03
007C6:  DATA    18,02,65
007C8:  DATA    19,02,03
007CA:  DATA    1A,02,66
007CC:  DATA    1B,02,03
007CE:  DATA    1C,02,67
007D0:  DATA    1D,02,03
007D2:  DATA    1E,02,68
007D4:  DATA    1F,02,03
007D6:  DATA    20,02,69
007D8:  DATA    21,02,03
007DA:  DATA    22,02,6A
007DC:  DATA    23,02,03
007DE:  DATA    24,02,6B
007E0:  DATA    25,02,03
007E2:  DATA    26,02,6C
007E4:  DATA    27,02,03
007E6:  DATA    28,02,6D
007E8:  DATA    29,02,03
007EA:  DATA    2A,02,6E
007EC:  DATA    2B,02,03
007EE:  DATA    2C,02,6F
007F0:  DATA    2D,02,03
007F2:  DATA    2E,02,70
007F4:  DATA    2F,02,03
007F6:  DATA    30,02,71
007F8:  DATA    31,02,03
007FA:  DATA    32,02,72
007FC:  DATA    33,02,03
007FE:  DATA    34,02,73
00800:  DATA    35,02,03
00802:  DATA    36,02,74
00804:  DATA    37,02,03
00806:  DATA    38,02,75
00808:  DATA    39,02,03
0080A:  DATA    3A,02,76
0080C:  DATA    3B,02,03
0080E:  DATA    3C,02,77
00810:  DATA    3D,02,03
00812:  DATA    3E,02,78
00814:  DATA    3F,02,03
00816:  DATA    40,02,79
00818:  DATA    41,02,03
0081A:  DATA    42,02,7A
0081C:  DATA    43,02,03
0081E:  DATA    44,02,7B
00820:  DATA    45,02,03
00822:  DATA    46,02,7C
00824:  DATA    47,02,03
00826:  DATA    48,02,7D
00828:  DATA    49,02,03
0082A:  DATA    4A,02,7E
0082C:  DATA    4B,02,03
0082E:  DATA    4C,02,7F
00830:  DATA    4D,02,03
00832:  DATA    4E,02,80
00834:  DATA    4F,02,03
00836:  DATA    50,02,81
00838:  DATA    51,02,03
0083A:  DATA    52,02,82
0083C:  DATA    53,02,03
0083E:  DATA    54,02,83
00840:  DATA    55,02,03
00842:  DATA    56,02,84
00844:  DATA    57,02,03
00846:  DATA    58,02,00
00848:  CLR     32
0084A:  MOV     #4B2,W3
0084C:  SUB     W0,W3,W3
0084E:  BRA     C,858
00850:  MOV     #868,W3
00852:  ADD     W3,W0,W0
00854:  TBLRDL  [W0],W0
00856:  RETURN  
00858:  MOV     #868,W0
0085A:  ADD     W3,W3,W3
0085C:  ADD     W3,W0,W3
0085E:  TBLRDH  [W3++],W0
00860:  TBLRDH  [W3],W3
00862:  SL      W3,#8,W3
00864:  IOR      W3,  W0,W0
00866:  RETURN  
00868:  DATA    28,08,21
0086A:  DATA    26,08,02
0086C:  DATA    23,08,20
0086E:  DATA    21,08,02
00870:  DATA    1E,08,1E
00872:  DATA    1C,08,02
00874:  DATA    19,08,1D
00876:  DATA    16,08,02
00878:  DATA    14,08,1B
0087A:  DATA    11,08,02
0087C:  DATA    0F,08,1A
0087E:  DATA    0C,08,02
00880:  DATA    0A,08,18
00882:  DATA    07,08,02
00884:  DATA    04,08,17
00886:  DATA    02,08,02
00888:  DATA    FF,07,15
0088A:  DATA    FD,07,02
0088C:  DATA    FA,07,14
0088E:  DATA    F7,07,02
00890:  DATA    F5,07,12
00892:  DATA    F2,07,02
00894:  DATA    EF,07,11
00896:  DATA    ED,07,02
00898:  DATA    EA,07,0F
0089A:  DATA    E7,07,02
0089C:  DATA    E5,07,0E
0089E:  DATA    E2,07,02
008A0:  DATA    DF,07,0C
008A2:  DATA    DD,07,02
008A4:  DATA    DA,07,0B
008A6:  DATA    D7,07,02
008A8:  DATA    D5,07,09
008AA:  DATA    D2,07,02
008AC:  DATA    CF,07,08
008AE:  DATA    CD,07,02
008B0:  DATA    CA,07,07
008B2:  DATA    C7,07,02
008B4:  DATA    C5,07,05
008B6:  DATA    C2,07,02
008B8:  DATA    BF,07,04
008BA:  DATA    BC,07,02
008BC:  DATA    BA,07,02
008BE:  DATA    B7,07,02
008C0:  DATA    B4,07,01
008C2:  DATA    B1,07,02
008C4:  DATA    AF,07,FF
008C6:  DATA    AC,07,01
008C8:  DATA    A9,07,FE
008CA:  DATA    A6,07,01
008CC:  DATA    A4,07,FD
008CE:  DATA    A1,07,01
008D0:  DATA    9E,07,FB
008D2:  DATA    9B,07,01
008D4:  DATA    98,07,FA
008D6:  DATA    96,07,01
008D8:  DATA    93,07,F8
008DA:  DATA    90,07,01
008DC:  DATA    8D,07,F7
008DE:  DATA    8A,07,01
008E0:  DATA    88,07,F6
008E2:  DATA    85,07,01
008E4:  DATA    82,07,F4
008E6:  DATA    7F,07,01
008E8:  DATA    7C,07,F3
008EA:  DATA    7A,07,01
008EC:  DATA    77,07,F1
008EE:  DATA    74,07,01
008F0:  DATA    71,07,F0
008F2:  DATA    6E,07,01
008F4:  DATA    6B,07,EF
008F6:  DATA    68,07,01
008F8:  DATA    66,07,ED
008FA:  DATA    63,07,01
008FC:  DATA    60,07,EC
008FE:  DATA    5D,07,01
00900:  DATA    5A,07,EB
00902:  DATA    57,07,01
00904:  DATA    54,07,E9
00906:  DATA    51,07,01
00908:  DATA    4F,07,E8
0090A:  DATA    4C,07,01
0090C:  DATA    49,07,E6
0090E:  DATA    46,07,01
00910:  DATA    43,07,E5
00912:  DATA    40,07,01
00914:  DATA    3D,07,E4
00916:  DATA    3A,07,01
00918:  DATA    37,07,E2
0091A:  DATA    34,07,01
0091C:  DATA    32,07,E1
0091E:  DATA    2F,07,01
00920:  DATA    2C,07,E0
00922:  DATA    29,07,01
00924:  DATA    26,07,DE
00926:  DATA    23,07,01
00928:  DATA    20,07,DD
0092A:  DATA    1D,07,01
0092C:  DATA    1A,07,DC
0092E:  DATA    17,07,01
00930:  DATA    14,07,DA
00932:  DATA    11,07,01
00934:  DATA    0E,07,D9
00936:  DATA    0B,07,01
00938:  DATA    08,07,D8
0093A:  DATA    05,07,01
0093C:  DATA    02,07,D7
0093E:  DATA    FF,06,01
00940:  DATA    FC,06,D5
00942:  DATA    FA,06,01
00944:  DATA    F7,06,D4
00946:  DATA    F4,06,01
00948:  DATA    F1,06,D3
0094A:  DATA    EE,06,01
0094C:  DATA    EB,06,D1
0094E:  DATA    E8,06,01
00950:  DATA    E5,06,D0
00952:  DATA    E2,06,01
00954:  DATA    DF,06,CF
00956:  DATA    DC,06,01
00958:  DATA    D9,06,CE
0095A:  DATA    D6,06,01
0095C:  DATA    D3,06,CC
0095E:  DATA    D0,06,01
00960:  DATA    CD,06,CB
00962:  DATA    CA,06,01
00964:  DATA    C7,06,CA
00966:  DATA    C4,06,01
00968:  DATA    C1,06,C8
0096A:  DATA    BE,06,01
0096C:  DATA    BB,06,C7
0096E:  DATA    B7,06,01
00970:  DATA    B4,06,C6
00972:  DATA    B1,06,01
00974:  DATA    AE,06,C5
00976:  DATA    AB,06,01
00978:  DATA    A8,06,C3
0097A:  DATA    A5,06,01
0097C:  DATA    A2,06,C2
0097E:  DATA    9F,06,01
00980:  DATA    9C,06,C1
00982:  DATA    99,06,01
00984:  DATA    96,06,C0
00986:  DATA    93,06,01
00988:  DATA    90,06,BE
0098A:  DATA    8D,06,01
0098C:  DATA    8A,06,BD
0098E:  DATA    87,06,01
00990:  DATA    84,06,BC
00992:  DATA    81,06,01
00994:  DATA    7E,06,BB
00996:  DATA    7B,06,01
00998:  DATA    78,06,BA
0099A:  DATA    75,06,01
0099C:  DATA    72,06,B8
0099E:  DATA    6E,06,01
009A0:  DATA    6B,06,B7
009A2:  DATA    68,06,01
009A4:  DATA    65,06,B6
009A6:  DATA    62,06,01
009A8:  DATA    5F,06,B5
009AA:  DATA    5C,06,01
009AC:  DATA    59,06,B4
009AE:  DATA    56,06,01
009B0:  DATA    53,06,B2
009B2:  DATA    50,06,01
009B4:  DATA    4D,06,B1
009B6:  DATA    4A,06,01
009B8:  DATA    47,06,B0
009BA:  DATA    44,06,01
009BC:  DATA    41,06,AF
009BE:  DATA    3D,06,01
009C0:  DATA    3A,06,AE
009C2:  DATA    37,06,01
009C4:  DATA    34,06,AC
009C6:  DATA    31,06,01
009C8:  DATA    2E,06,AB
009CA:  DATA    2B,06,01
009CC:  DATA    28,06,AA
009CE:  DATA    25,06,01
009D0:  DATA    22,06,A9
009D2:  DATA    1F,06,01
009D4:  DATA    1C,06,A8
009D6:  DATA    19,06,01
009D8:  DATA    16,06,A7
009DA:  DATA    12,06,01
009DC:  DATA    0F,06,A5
009DE:  DATA    0C,06,01
009E0:  DATA    09,06,A4
009E2:  DATA    06,06,01
009E4:  DATA    03,06,A3
009E6:  DATA    00,06,01
009E8:  DATA    FD,05,A2
009EA:  DATA    FA,05,01
009EC:  DATA    F7,05,A1
009EE:  DATA    F4,05,01
009F0:  DATA    F1,05,A0
009F2:  DATA    EE,05,01
009F4:  DATA    EB,05,9E
009F6:  DATA    E7,05,01
009F8:  DATA    E4,05,9D
009FA:  DATA    E1,05,01
009FC:  DATA    DE,05,9C
009FE:  DATA    DB,05,01
00A00:  DATA    D8,05,9B
00A02:  DATA    D5,05,01
00A04:  DATA    D2,05,9A
00A06:  DATA    CF,05,01
00A08:  DATA    CC,05,99
00A0A:  DATA    C9,05,01
00A0C:  DATA    C6,05,98
00A0E:  DATA    C3,05,01
00A10:  DATA    C0,05,97
00A12:  DATA    BD,05,01
00A14:  DATA    BA,05,95
00A16:  DATA    B6,05,01
00A18:  DATA    B3,05,94
00A1A:  DATA    B0,05,01
00A1C:  DATA    AD,05,93
00A1E:  DATA    AA,05,01
00A20:  DATA    A7,05,92
00A22:  DATA    A4,05,01
00A24:  DATA    A1,05,91
00A26:  DATA    9E,05,01
00A28:  DATA    9B,05,90
00A2A:  DATA    98,05,01
00A2C:  DATA    95,05,8F
00A2E:  DATA    92,05,01
00A30:  DATA    8F,05,8E
00A32:  DATA    8C,05,01
00A34:  DATA    89,05,8D
00A36:  DATA    86,05,01
00A38:  DATA    83,05,8C
00A3A:  DATA    80,05,01
00A3C:  DATA    7D,05,8B
00A3E:  DATA    7A,05,01
00A40:  DATA    77,05,89
00A42:  DATA    74,05,01
00A44:  DATA    71,05,88
00A46:  DATA    6E,05,01
00A48:  DATA    6B,05,87
00A4A:  DATA    67,05,01
00A4C:  DATA    64,05,86
00A4E:  DATA    61,05,01
00A50:  DATA    5E,05,85
00A52:  DATA    5B,05,01
00A54:  DATA    58,05,84
00A56:  DATA    55,05,01
00A58:  DATA    52,05,83
00A5A:  DATA    4F,05,01
00A5C:  DATA    4C,05,82
00A5E:  DATA    49,05,01
00A60:  DATA    46,05,81
00A62:  DATA    43,05,01
00A64:  DATA    40,05,80
00A66:  DATA    3D,05,01
00A68:  DATA    3A,05,7F
00A6A:  DATA    37,05,01
00A6C:  DATA    34,05,7E
00A6E:  DATA    31,05,01
00A70:  DATA    2E,05,7D
00A72:  DATA    2C,05,01
00A74:  DATA    29,05,7C
00A76:  DATA    26,05,01
00A78:  DATA    23,05,7B
00A7A:  DATA    20,05,01
00A7C:  DATA    1D,05,7A
00A7E:  DATA    1A,05,01
00A80:  DATA    17,05,79
00A82:  DATA    14,05,01
00A84:  DATA    11,05,78
00A86:  DATA    0E,05,01
00A88:  DATA    0B,05,77
00A8A:  DATA    08,05,01
00A8C:  DATA    05,05,76
00A8E:  DATA    02,05,01
00A90:  DATA    FF,04,75
00A92:  DATA    FC,04,01
00A94:  DATA    F9,04,74
00A96:  DATA    F6,04,01
00A98:  DATA    F3,04,73
00A9A:  DATA    F0,04,01
00A9C:  DATA    EE,04,72
00A9E:  DATA    EB,04,01
00AA0:  DATA    E8,04,71
00AA2:  DATA    E5,04,01
00AA4:  DATA    E2,04,70
00AA6:  DATA    DF,04,01
00AA8:  DATA    DC,04,6F
00AAA:  DATA    D9,04,01
00AAC:  DATA    D6,04,6E
00AAE:  DATA    D3,04,01
00AB0:  DATA    D0,04,6D
00AB2:  DATA    CE,04,01
00AB4:  DATA    CB,04,6C
00AB6:  DATA    C8,04,01
00AB8:  DATA    C5,04,6B
00ABA:  DATA    C2,04,01
00ABC:  DATA    BF,04,6A
00ABE:  DATA    BC,04,01
00AC0:  DATA    B9,04,69
00AC2:  DATA    B7,04,01
00AC4:  DATA    B4,04,68
00AC6:  DATA    B1,04,01
00AC8:  DATA    AE,04,67
00ACA:  DATA    AB,04,01
00ACC:  DATA    A8,04,66
00ACE:  DATA    A5,04,01
00AD0:  DATA    A3,04,65
00AD2:  DATA    A0,04,01
00AD4:  DATA    9D,04,64
00AD6:  DATA    9A,04,01
00AD8:  DATA    97,04,63
00ADA:  DATA    94,04,01
00ADC:  DATA    92,04,62
00ADE:  DATA    8F,04,01
00AE0:  DATA    8C,04,61
00AE2:  DATA    89,04,01
00AE4:  DATA    86,04,60
00AE6:  DATA    84,04,01
00AE8:  DATA    81,04,5F
00AEA:  DATA    7E,04,01
00AEC:  DATA    7B,04,5E
00AEE:  DATA    78,04,01
00AF0:  DATA    76,04,5D
00AF2:  DATA    73,04,01
00AF4:  DATA    70,04,5C
00AF6:  DATA    6D,04,01
00AF8:  DATA    6B,04,5B
00AFA:  DATA    68,04,01
00AFC:  DATA    65,04,5A
00AFE:  DATA    62,04,01
00B00:  DATA    60,04,59
00B02:  DATA    5D,04,01
00B04:  DATA    5A,04,58
00B06:  DATA    57,04,01
00B08:  DATA    55,04,57
00B0A:  DATA    52,04,01
00B0C:  DATA    4F,04,57
00B0E:  DATA    4C,04,01
00B10:  DATA    4A,04,56
00B12:  DATA    47,04,01
00B14:  DATA    44,04,55
00B16:  DATA    42,04,01
00B18:  DATA    3F,04,54
00B1A:  DATA    3C,04,01
00B1C:  DATA    39,04,53
00B1E:  DATA    37,04,01
00B20:  DATA    34,04,52
00B22:  DATA    31,04,01
00B24:  DATA    2F,04,51
00B26:  DATA    2C,04,01
00B28:  DATA    29,04,50
00B2A:  DATA    27,04,01
00B2C:  DATA    24,04,4F
00B2E:  DATA    21,04,01
00B30:  DATA    1F,04,4E
00B32:  DATA    1C,04,01
00B34:  DATA    19,04,4D
00B36:  DATA    17,04,01
00B38:  DATA    14,04,4D
00B3A:  DATA    11,04,01
00B3C:  DATA    0F,04,4C
00B3E:  DATA    0C,04,01
00B40:  DATA    0A,04,4B
00B42:  DATA    07,04,01
00B44:  DATA    04,04,4A
00B46:  DATA    02,04,01
00B48:  DATA    FF,03,49
00B4A:  DATA    FD,03,01
00B4C:  DATA    FA,03,48
00B4E:  DATA    F7,03,01
00B50:  DATA    F5,03,47
00B52:  DATA    F2,03,01
00B54:  DATA    F0,03,46
00B56:  DATA    ED,03,01
00B58:  DATA    EB,03,46
00B5A:  DATA    E8,03,01
00B5C:  DATA    E5,03,45
00B5E:  DATA    E3,03,01
00B60:  DATA    E0,03,44
00B62:  DATA    DE,03,01
00B64:  DATA    DB,03,43
00B66:  DATA    D9,03,01
00B68:  DATA    D6,03,42
00B6A:  DATA    D4,03,01
00B6C:  DATA    D1,03,41
00B6E:  DATA    CF,03,01
00B70:  DATA    CC,03,40
00B72:  DATA    CA,03,01
00B74:  DATA    C7,03,3F
00B76:  DATA    C5,03,01
00B78:  DATA    C2,03,3F
00B7A:  DATA    C0,03,01
00B7C:  DATA    BD,03,3E
00B7E:  DATA    BB,03,01
00B80:  DATA    B8,03,3D
00B82:  DATA    B6,03,01
00B84:  DATA    B3,03,3C
00B86:  DATA    B1,03,01
00B88:  DATA    AE,03,3B
00B8A:  DATA    AC,03,01
00B8C:  DATA    A9,03,3A
00B8E:  DATA    A7,03,01
00B90:  DATA    A4,03,3A
00B92:  DATA    A2,03,01
00B94:  DATA    A0,03,39
00B96:  DATA    9D,03,01
00B98:  DATA    9B,03,38
00B9A:  DATA    98,03,01
00B9C:  DATA    96,03,37
00B9E:  DATA    94,03,01
00BA0:  DATA    91,03,36
00BA2:  DATA    8F,03,01
00BA4:  DATA    8C,03,35
00BA6:  DATA    8A,03,01
00BA8:  DATA    88,03,35
00BAA:  DATA    85,03,01
00BAC:  DATA    83,03,34
00BAE:  DATA    80,03,01
00BB0:  DATA    7E,03,33
00BB2:  DATA    7C,03,01
00BB4:  DATA    79,03,32
00BB6:  DATA    77,03,01
00BB8:  DATA    75,03,31
00BBA:  DATA    72,03,01
00BBC:  DATA    70,03,31
00BBE:  DATA    6E,03,01
00BC0:  DATA    6B,03,30
00BC2:  DATA    69,03,01
00BC4:  DATA    67,03,2F
00BC6:  DATA    64,03,01
00BC8:  DATA    62,03,2E
00BCA:  DATA    60,03,01
00BCC:  DATA    5E,03,2D
00BCE:  DATA    5B,03,01
00BD0:  DATA    59,03,2D
00BD2:  DATA    57,03,01
00BD4:  DATA    54,03,2C
00BD6:  DATA    52,03,01
00BD8:  DATA    50,03,2B
00BDA:  DATA    4E,03,01
00BDC:  DATA    4B,03,2A
00BDE:  DATA    49,03,01
00BE0:  DATA    47,03,29
00BE2:  DATA    45,03,01
00BE4:  DATA    42,03,29
00BE6:  DATA    40,03,01
00BE8:  DATA    3E,03,28
00BEA:  DATA    3C,03,01
00BEC:  DATA    39,03,27
00BEE:  DATA    37,03,01
00BF0:  DATA    35,03,26
00BF2:  DATA    33,03,01
00BF4:  DATA    31,03,25
00BF6:  DATA    2E,03,01
00BF8:  DATA    2C,03,25
00BFA:  DATA    2A,03,01
00BFC:  DATA    28,03,24
00BFE:  DATA    26,03,01
00C00:  DATA    24,03,23
00C02:  DATA    21,03,01
00C04:  DATA    1F,03,22
00C06:  DATA    1D,03,01
00C08:  DATA    1B,03,22
00C0A:  DATA    19,03,01
00C0C:  DATA    17,03,21
00C0E:  DATA    14,03,01
00C10:  DATA    12,03,20
00C12:  DATA    10,03,01
00C14:  DATA    0E,03,1F
00C16:  DATA    0C,03,01
00C18:  DATA    0A,03,1F
00C1A:  DATA    08,03,01
00C1C:  DATA    06,03,1E
00C1E:  DATA    04,03,01
00C20:  DATA    01,03,1D
00C22:  DATA    FF,02,01
00C24:  DATA    FD,02,1C
00C26:  DATA    FB,02,01
00C28:  DATA    F9,02,1C
00C2A:  DATA    F7,02,01
00C2C:  DATA    F5,02,1B
00C2E:  DATA    F3,02,01
00C30:  DATA    F1,02,1A
00C32:  DATA    EF,02,01
00C34:  DATA    ED,02,19
00C36:  DATA    EB,02,01
00C38:  DATA    E9,02,19
00C3A:  DATA    E7,02,01
00C3C:  DATA    E5,02,18
00C3E:  DATA    E3,02,01
00C40:  DATA    E1,02,17
00C42:  DATA    DF,02,01
00C44:  DATA    DD,02,16
00C46:  DATA    DB,02,01
00C48:  DATA    D9,02,16
00C4A:  DATA    D7,02,01
00C4C:  DATA    D5,02,15
00C4E:  DATA    D3,02,01
00C50:  DATA    D1,02,14
00C52:  DATA    CF,02,01
00C54:  DATA    CD,02,14
00C56:  DATA    CB,02,01
00C58:  DATA    C9,02,13
00C5A:  DATA    C7,02,01
00C5C:  DATA    C5,02,12
00C5E:  DATA    C3,02,01
00C60:  DATA    C1,02,11
00C62:  DATA    BF,02,01
00C64:  DATA    BD,02,11
00C66:  DATA    BB,02,01
00C68:  DATA    B9,02,10
00C6A:  DATA    B7,02,01
00C6C:  DATA    B6,02,0F
00C6E:  DATA    B4,02,01
00C70:  DATA    B2,02,0F
00C72:  DATA    B0,02,01
00C74:  DATA    AE,02,0E
00C76:  DATA    AC,02,01
00C78:  DATA    AA,02,0D
00C7A:  DATA    A8,02,01
00C7C:  DATA    A6,02,0C
00C7E:  DATA    A5,02,01
00C80:  DATA    A3,02,0C
00C82:  DATA    A1,02,01
00C84:  DATA    9F,02,0B
00C86:  DATA    9D,02,01
00C88:  DATA    9B,02,0A
00C8A:  DATA    9A,02,01
00C8C:  DATA    98,02,0A
00C8E:  DATA    96,02,01
00C90:  DATA    94,02,09
00C92:  DATA    92,02,01
00C94:  DATA    90,02,08
00C96:  DATA    8F,02,01
00C98:  DATA    8D,02,08
00C9A:  DATA    8B,02,01
00C9C:  DATA    89,02,07
00C9E:  DATA    87,02,01
00CA0:  DATA    86,02,06
00CA2:  DATA    84,02,01
00CA4:  DATA    82,02,06
00CA6:  DATA    80,02,01
00CA8:  DATA    7E,02,05
00CAA:  DATA    7D,02,01
00CAC:  DATA    7B,02,04
00CAE:  DATA    79,02,01
00CB0:  DATA    77,02,04
00CB2:  DATA    76,02,01
00CB4:  DATA    74,02,03
00CB6:  DATA    72,02,01
00CB8:  DATA    71,02,02
00CBA:  DATA    6F,02,01
00CBC:  DATA    6D,02,02
00CBE:  DATA    6B,02,01
00CC0:  DATA    6A,02,01
00CC2:  DATA    68,02,01
00CC4:  DATA    66,02,00
00CC6:  DATA    65,02,01
00CC8:  DATA    63,02,00
00CCA:  DATA    61,02,01
00CCC:  DATA    5F,02,FF
00CCE:  DATA    5E,02,00
00CD0:  DATA    5C,02,FE
00CD2:  DATA    5A,02,00
00CD4:  DATA    59,02,FE
00CD6:  DATA    57,02,00
00CD8:  DATA    55,02,FD
00CDA:  DATA    54,02,00
00CDC:  DATA    52,02,FC
00CDE:  DATA    50,02,00
00CE0:  DATA    4F,02,FC
00CE2:  DATA    4D,02,00
00CE4:  DATA    4C,02,FB
00CE6:  DATA    4A,02,00
00CE8:  DATA    48,02,FA
00CEA:  DATA    47,02,00
00CEC:  DATA    45,02,FA
00CEE:  DATA    43,02,00
00CF0:  DATA    42,02,F9
00CF2:  DATA    40,02,00
00CF4:  DATA    3F,02,F9
00CF6:  DATA    3D,02,00
00CF8:  DATA    3B,02,F8
00CFA:  DATA    3A,02,00
00CFC:  DATA    38,02,F7
00CFE:  DATA    37,02,00
00D00:  DATA    35,02,F7
00D02:  DATA    34,02,00
00D04:  DATA    32,02,F6
00D06:  DATA    30,02,00
00D08:  DATA    2F,02,F5
00D0A:  DATA    2D,02,00
00D0C:  DATA    2C,02,F5
00D0E:  DATA    2A,02,00
00D10:  DATA    29,02,F4
00D12:  DATA    27,02,00
00D14:  DATA    26,02,F3
00D16:  DATA    24,02,00
00D18:  DATA    23,02,00
....................  
.................... #list 
....................  
....................  
.................... #FUSES HS 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES NOIESO 
.................... #FUSES NOPUT 
....................  
.................... #device ICSP=1 
.................... #use delay(crystal=20000000) 
*
019C2:  CP0     W0
019C4:  BTSC.B  42.1
019C6:  BRA     19D0
019C8:  REPEAT  #270B
019CA:  NOP     
019CC:  DEC     W0,W0
019CE:  BRA     NZ,19C8
019D0:  RETURN  
....................  
.................... #define CAN_USE_EXTENDED_ID   FALSE 
....................  
.................... //CAN config PICWizard 
.................... #define CAN_BRG_PRESCALAR   0 
.................... #define CAN_BRG_PROPAGATION_TIME   1 
.................... #define CAN_BRG_PHASE_SEGMENT_1   4 
.................... #define CAN_BRG_PHASE_SEGMENT_2   1 
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH   0 
.................... #define CAN_BRG_SAM   FALSE 
.................... #define CAN_BRG_WAKE_FILTER   FALSE 
.................... #define CAN_BRG_SEG_2_PHASE_TS   TRUE 
....................  
.................... #define CS_LTC6811 PIN_A0 
.................... #define LED1 PIN_B13 
.................... #define LED2 PIN_B12 
.................... #define ERROR_LED PIN_B2 
.................... #define CS_LTC1296 PIN_A4 
....................  
.................... #PIN_SELECT SDO1=PIN_B6 
.................... #PIN_SELECT SCK1OUT=PIN_B5 
.................... #PIN_SELECT SDI1=PIN_B7 
....................  
....................  
.................... #use spi(MASTER, CLK=PIN_B5, DI=PIN_B7, DO=PIN_B6, BAUD=9600, MODE=3, BITS=8, stream=SP, MSB_FIRST) 
*
01898:  MOV     W5,[W15++]
0189A:  MOV     W6,[W15++]
0189C:  MOV     W7,[W15++]
0189E:  MOV     #20,W0
018A0:  SUB     W0,W4,W5
018A2:  BRA     Z,18AC
018A4:  RLC     W2,W2
018A6:  RLC     W3,W3
018A8:  DEC     W5,W5
018AA:  BRA     NZ,18A4
018AC:  BSET.B  2C8.7
018AE:  BCLR.B  2C8.6
018B0:  BCLR.B  2C8.5
018B2:  BSET.B  2CC.5
018B4:  MOV     W4,W5
018B6:  BCLR.B  2CC.5
018B8:  NOP     
018BA:  BTSS    W3.F
018BC:  BCLR.B  2CC.6
018BE:  BTSC    W3.F
018C0:  BSET.B  2CC.6
018C2:  RLC     W2,W2
018C4:  RLC     W3,W3
018C6:  BSET.B  2CC.5
018C8:  RLC     W0,W0
018CA:  RLC     W1,W1
018CC:  BTSS.B  2CA.7
018CE:  BCLR.B  0.0
018D0:  BTSC.B  2CA.7
018D2:  BSET.B  0.0
018D4:  DEC     W5,W5
018D6:  BRA     NZ,18B6
018D8:  MOV     [--W15],W7
018DA:  MOV     [--W15],W6
018DC:  MOV     [--W15],W5
018DE:  RETURN  
....................  
.................... #use rs232 (baud=9600, xmit=PIN_B11, rcv=PIN_B10) 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <LT6811.c> 
.................... //Library to control the LT6811-2 for BMS applications (ONLY VALID IF THE ADDRESS IS 0000) 
.................... // 
.................... // 
.................... //This library contains the functions to make the voltage ADC conversions, the reading of these registers and the balancing 
.................... // 
.................... // 
.................... //It is necessary to define in the main program the SPI configuration with #USE SPI (...) 
.................... //It is also necessary to define the Chip select pin CS. Example #DEFINE CS pin_A1 
.................... //It is also necessary to include the stdint library in the main program before this one. Ex: #include <stdint.h> #include <LT6811.c> 
.................... // 
.................... // 
....................  
.................... void SUMAMA(uint8_t &a, uint8_t &b, uint8_t *x) 
.................... { 
....................    x[0]=a+b; 
....................    x[1]=a*b; 
.................... } 
....................  
....................  
....................  
.................... // 
.................... // START_ADC_VOLTAGES is a fucntion to start the ADC conversions, it is necessary to do it before read the registers where these conversions are saved. It last about 35 ms. 
.................... // 
....................  
.................... void START_ADC_VOLTAGES () 
.................... { 
....................    output_low(CS_LTC6811); 
018E0:  BCLR.B  2C0.0
018E2:  BCLR.B  2C4.0
....................    delay_us(500); 
018E4:  REPEAT  #1386
018E6:  NOP     
....................    output_high(CS_LTC6811); 
018E8:  BCLR.B  2C0.0
018EA:  BSET.B  2C4.0
....................    delay_us(10); 
018EC:  REPEAT  #62
018EE:  NOP     
....................    output_low(CS_LTC6811); 
018F0:  BCLR.B  2C0.0
018F2:  BCLR.B  2C4.0
....................    spi_xfer(SP, 0x83); 
018F4:  MOV     #8,W4
018F6:  MOV     #83,W2
018F8:  MOV     #0,W3
018FA:  CALL    1898
....................    spi_xfer(SP, 0x60); 
018FE:  MOV     #8,W4
01900:  MOV     #60,W2
01902:  MOV     #0,W3
01904:  CALL    1898
....................    spi_xfer(SP, 0x84); 
01908:  MOV     #8,W4
0190A:  MOV     #84,W2
0190C:  MOV     #0,W3
0190E:  CALL    1898
....................    spi_xfer(SP, 0x78); 
01912:  MOV     #8,W4
01914:  MOV     #78,W2
01916:  MOV     #0,W3
01918:  CALL    1898
....................    output_high(CS_LTC6811); 
0191C:  BCLR.B  2C0.0
0191E:  BSET.B  2C4.0
01920:  RETURN  
.................... } 
....................  
....................  
....................  
.................... // 
.................... // READ_VOLTAGES is a function to read the voltajes of the cells. It must be used after the START_ADC_VOLTAGES function. 
.................... // 
.................... // An example to use this function in the main program is: READ_VOLTAGES (&voltaja[0], total_v, v_cell_min, v_cell_max); 
.................... // The voltajes of the cells are saved in the voltaja array, the sum of all the cell voltajes are save in the total_v variable, the minimum and maximum cell voltaje are saved in v_cell_min and 
.................... // v_cell_max, respectively 
.................... // 
....................  
.................... void READ_VOLTAGES(uint16_t *voltaje, uint16_t &total, uint16_t v_min_aux, uint16_t v_max_aux) 
.................... { 
....................    int8 data[6], data1[6], data2[6], data3[6], i, am; 
....................  
....................    //Primer set de registros 
....................    output_low(CS_LTC6811); 
*
01E06:  BCLR.B  2C0.0
01E08:  BCLR.B  2C4.0
*
027D0:  BCLR.B  2C0.0
027D2:  BCLR.B  2C4.0
....................    delay_us(10); 
*
01E0A:  REPEAT  #62
01E0C:  NOP     
*
027D4:  REPEAT  #62
027D6:  NOP     
....................    output_high(CS_LTC6811); 
*
01E0E:  BCLR.B  2C0.0
01E10:  BSET.B  2C4.0
*
027D8:  BCLR.B  2C0.0
027DA:  BSET.B  2C4.0
....................    delay_us(10); 
*
01E12:  REPEAT  #62
01E14:  NOP     
*
027DC:  REPEAT  #62
027DE:  NOP     
....................    output_low(CS_LTC6811); 
*
01E16:  BCLR.B  2C0.0
01E18:  BCLR.B  2C4.0
*
027E0:  BCLR.B  2C0.0
027E2:  BCLR.B  2C4.0
....................    spi_xfer(SP, 0x80);   
*
01E1A:  MOV     #8,W4
01E1C:  MOV     #80,W2
01E1E:  MOV     #0,W3
01E20:  CALL    1898
*
027E4:  MOV     #8,W4
027E6:  MOV     #80,W2
027E8:  MOV     #0,W3
027EA:  CALL    1898
....................    spi_xfer(SP, 0x04);   
*
01E24:  MOV     #8,W4
01E26:  MOV     #4,W2
01E28:  MOV     #0,W3
01E2A:  CALL    1898
*
027EE:  MOV     #8,W4
027F0:  MOV     #4,W2
027F2:  MOV     #0,W3
027F4:  CALL    1898
....................    spi_xfer(SP, 0x77);   
*
01E2E:  MOV     #8,W4
01E30:  MOV     #77,W2
01E32:  MOV     #0,W3
01E34:  CALL    1898
*
027F8:  MOV     #8,W4
027FA:  MOV     #77,W2
027FC:  MOV     #0,W3
027FE:  CALL    1898
....................    spi_xfer(SP, 0xD6); 
*
01E38:  MOV     #8,W4
01E3A:  MOV     #D6,W2
01E3C:  MOV     #0,W3
01E3E:  CALL    1898
*
02802:  MOV     #8,W4
02804:  MOV     #D6,W2
02806:  MOV     #0,W3
02808:  CALL    1898
....................    for(i=0;i<6;++i) 
*
01E42:  CLR.B   88A
01E44:  MOV.B   88A,W0L
01E46:  SE      W0,W0
01E48:  CP      W0,#6
01E4A:  BRA     GE,1E66
*
0280C:  CLR.B   88A
0280E:  MOV.B   88A,W0L
02810:  SE      W0,W0
02812:  CP      W0,#6
02814:  BRA     GE,2830
....................    { 
....................       data[i]=spi_xfer(SP, 0xFF);  
*
01E4C:  MOV.B   88A,W0L
01E4E:  SE      W0,W0
01E50:  MOV     #872,W4
01E52:  ADD     W0,W4,W5
01E54:  MOV     #8,W4
01E56:  MOV     #FF,W2
01E58:  MOV     #0,W3
01E5A:  CALL    1898
01E5E:  MOV.B   W0L,[W5]
01E60:  INC.B   088A
01E62:  GOTO    1E44
*
02816:  MOV.B   88A,W0L
02818:  SE      W0,W0
0281A:  MOV     #872,W4
0281C:  ADD     W0,W4,W5
0281E:  MOV     #8,W4
02820:  MOV     #FF,W2
02822:  MOV     #0,W3
02824:  CALL    1898
02828:  MOV.B   W0L,[W5]
0282A:  INC.B   088A
0282C:  GOTO    280E
....................    } 
....................    output_high(CS_LTC6811); 
*
01E66:  BCLR.B  2C0.0
01E68:  BSET.B  2C4.0
*
02830:  BCLR.B  2C0.0
02832:  BSET.B  2C4.0
....................     
....................     
....................    //Segundo set de registros 
....................    output_low(CS_LTC6811); 
*
01E6A:  BCLR.B  2C0.0
01E6C:  BCLR.B  2C4.0
*
02834:  BCLR.B  2C0.0
02836:  BCLR.B  2C4.0
....................    delay_us(10); 
*
01E6E:  REPEAT  #62
01E70:  NOP     
*
02838:  REPEAT  #62
0283A:  NOP     
....................    output_high(CS_LTC6811); 
*
01E72:  BCLR.B  2C0.0
01E74:  BSET.B  2C4.0
*
0283C:  BCLR.B  2C0.0
0283E:  BSET.B  2C4.0
....................    delay_us(10); 
*
01E76:  REPEAT  #62
01E78:  NOP     
*
02840:  REPEAT  #62
02842:  NOP     
....................    output_low(CS_LTC6811); 
*
01E7A:  BCLR.B  2C0.0
01E7C:  BCLR.B  2C4.0
*
02844:  BCLR.B  2C0.0
02846:  BCLR.B  2C4.0
....................    spi_xfer(SP, 0x80);   
*
01E7E:  MOV     #8,W4
01E80:  MOV     #80,W2
01E82:  MOV     #0,W3
01E84:  CALL    1898
*
02848:  MOV     #8,W4
0284A:  MOV     #80,W2
0284C:  MOV     #0,W3
0284E:  CALL    1898
....................    spi_xfer(SP, 0x06);   
*
01E88:  MOV     #8,W4
01E8A:  MOV     #6,W2
01E8C:  MOV     #0,W3
01E8E:  CALL    1898
*
02852:  MOV     #8,W4
02854:  MOV     #6,W2
02856:  MOV     #0,W3
02858:  CALL    1898
....................    spi_xfer(SP, 0xEA);   
*
01E92:  MOV     #8,W4
01E94:  MOV     #EA,W2
01E96:  MOV     #0,W3
01E98:  CALL    1898
*
0285C:  MOV     #8,W4
0285E:  MOV     #EA,W2
02860:  MOV     #0,W3
02862:  CALL    1898
....................    spi_xfer(SP, 0x80); 
*
01E9C:  MOV     #8,W4
01E9E:  MOV     #80,W2
01EA0:  MOV     #0,W3
01EA2:  CALL    1898
*
02866:  MOV     #8,W4
02868:  MOV     #80,W2
0286A:  MOV     #0,W3
0286C:  CALL    1898
....................    for(i=0;i<6;++i) 
*
01EA6:  CLR.B   88A
01EA8:  MOV.B   88A,W0L
01EAA:  SE      W0,W0
01EAC:  CP      W0,#6
01EAE:  BRA     GE,1ECA
*
02870:  CLR.B   88A
02872:  MOV.B   88A,W0L
02874:  SE      W0,W0
02876:  CP      W0,#6
02878:  BRA     GE,2894
....................    { 
....................       data1[i]=spi_xfer(SP, 0xFF);  
*
01EB0:  MOV.B   88A,W0L
01EB2:  SE      W0,W0
01EB4:  MOV     #878,W4
01EB6:  ADD     W0,W4,W5
01EB8:  MOV     #8,W4
01EBA:  MOV     #FF,W2
01EBC:  MOV     #0,W3
01EBE:  CALL    1898
01EC2:  MOV.B   W0L,[W5]
01EC4:  INC.B   088A
01EC6:  GOTO    1EA8
*
0287A:  MOV.B   88A,W0L
0287C:  SE      W0,W0
0287E:  MOV     #878,W4
02880:  ADD     W0,W4,W5
02882:  MOV     #8,W4
02884:  MOV     #FF,W2
02886:  MOV     #0,W3
02888:  CALL    1898
0288C:  MOV.B   W0L,[W5]
0288E:  INC.B   088A
02890:  GOTO    2872
....................    } 
....................    output_high(CS_LTC6811); 
*
01ECA:  BCLR.B  2C0.0
01ECC:  BSET.B  2C4.0
*
02894:  BCLR.B  2C0.0
02896:  BSET.B  2C4.0
....................     
....................    //Tercer set de registros 
....................    output_low(CS_LTC6811); 
*
01ECE:  BCLR.B  2C0.0
01ED0:  BCLR.B  2C4.0
*
02898:  BCLR.B  2C0.0
0289A:  BCLR.B  2C4.0
....................    delay_us(10); 
*
01ED2:  REPEAT  #62
01ED4:  NOP     
*
0289C:  REPEAT  #62
0289E:  NOP     
....................    output_high(CS_LTC6811); 
*
01ED6:  BCLR.B  2C0.0
01ED8:  BSET.B  2C4.0
*
028A0:  BCLR.B  2C0.0
028A2:  BSET.B  2C4.0
....................    delay_us(10); 
*
01EDA:  REPEAT  #62
01EDC:  NOP     
*
028A4:  REPEAT  #62
028A6:  NOP     
....................    output_low(CS_LTC6811); 
*
01EDE:  BCLR.B  2C0.0
01EE0:  BCLR.B  2C4.0
*
028A8:  BCLR.B  2C0.0
028AA:  BCLR.B  2C4.0
....................    spi_xfer(SP, 0x80);   
*
01EE2:  MOV     #8,W4
01EE4:  MOV     #80,W2
01EE6:  MOV     #0,W3
01EE8:  CALL    1898
*
028AC:  MOV     #8,W4
028AE:  MOV     #80,W2
028B0:  MOV     #0,W3
028B2:  CALL    1898
....................    spi_xfer(SP, 0x08);   
*
01EEC:  MOV     #8,W4
01EEE:  MOV     #8,W2
01EF0:  MOV     #0,W3
01EF2:  CALL    1898
*
028B6:  MOV     #8,W4
028B8:  MOV     #8,W2
028BA:  MOV     #0,W3
028BC:  CALL    1898
....................    spi_xfer(SP, 0x2E);   
*
01EF6:  MOV     #8,W4
01EF8:  MOV     #2E,W2
01EFA:  MOV     #0,W3
01EFC:  CALL    1898
*
028C0:  MOV     #8,W4
028C2:  MOV     #2E,W2
028C4:  MOV     #0,W3
028C6:  CALL    1898
....................    spi_xfer(SP, 0x46); 
*
01F00:  MOV     #8,W4
01F02:  MOV     #46,W2
01F04:  MOV     #0,W3
01F06:  CALL    1898
*
028CA:  MOV     #8,W4
028CC:  MOV     #46,W2
028CE:  MOV     #0,W3
028D0:  CALL    1898
....................    for(i=0;i<6;++i) 
*
01F0A:  CLR.B   88A
01F0C:  MOV.B   88A,W0L
01F0E:  SE      W0,W0
01F10:  CP      W0,#6
01F12:  BRA     GE,1F2E
*
028D4:  CLR.B   88A
028D6:  MOV.B   88A,W0L
028D8:  SE      W0,W0
028DA:  CP      W0,#6
028DC:  BRA     GE,28F8
....................    { 
....................       data2[i]=spi_xfer(SP, 0xFF);  
*
01F14:  MOV.B   88A,W0L
01F16:  SE      W0,W0
01F18:  MOV     #87E,W4
01F1A:  ADD     W0,W4,W5
01F1C:  MOV     #8,W4
01F1E:  MOV     #FF,W2
01F20:  MOV     #0,W3
01F22:  CALL    1898
01F26:  MOV.B   W0L,[W5]
01F28:  INC.B   088A
01F2A:  GOTO    1F0C
*
028DE:  MOV.B   88A,W0L
028E0:  SE      W0,W0
028E2:  MOV     #87E,W4
028E4:  ADD     W0,W4,W5
028E6:  MOV     #8,W4
028E8:  MOV     #FF,W2
028EA:  MOV     #0,W3
028EC:  CALL    1898
028F0:  MOV.B   W0L,[W5]
028F2:  INC.B   088A
028F4:  GOTO    28D6
....................    } 
....................    output_high(CS_LTC6811); 
*
01F2E:  BCLR.B  2C0.0
01F30:  BSET.B  2C4.0
*
028F8:  BCLR.B  2C0.0
028FA:  BSET.B  2C4.0
....................     
....................    //Cuarto set de registros 
....................    output_low(CS_LTC6811); 
*
01F32:  BCLR.B  2C0.0
01F34:  BCLR.B  2C4.0
*
028FC:  BCLR.B  2C0.0
028FE:  BCLR.B  2C4.0
....................    delay_us(10); 
*
01F36:  REPEAT  #62
01F38:  NOP     
*
02900:  REPEAT  #62
02902:  NOP     
....................    output_high(CS_LTC6811); 
*
01F3A:  BCLR.B  2C0.0
01F3C:  BSET.B  2C4.0
*
02904:  BCLR.B  2C0.0
02906:  BSET.B  2C4.0
....................    delay_us(10); 
*
01F3E:  REPEAT  #62
01F40:  NOP     
*
02908:  REPEAT  #62
0290A:  NOP     
....................    output_low(CS_LTC6811); 
*
01F42:  BCLR.B  2C0.0
01F44:  BCLR.B  2C4.0
*
0290C:  BCLR.B  2C0.0
0290E:  BCLR.B  2C4.0
....................    spi_xfer(SP, 0x80);   
*
01F46:  MOV     #8,W4
01F48:  MOV     #80,W2
01F4A:  MOV     #0,W3
01F4C:  CALL    1898
*
02910:  MOV     #8,W4
02912:  MOV     #80,W2
02914:  MOV     #0,W3
02916:  CALL    1898
....................    spi_xfer(SP, 0x0A);   
*
01F50:  MOV     #8,W4
01F52:  MOV     #A,W2
01F54:  MOV     #0,W3
01F56:  CALL    1898
*
0291A:  MOV     #8,W4
0291C:  MOV     #A,W2
0291E:  MOV     #0,W3
02920:  CALL    1898
....................    spi_xfer(SP, 0xB3);   
*
01F5A:  MOV     #8,W4
01F5C:  MOV     #B3,W2
01F5E:  MOV     #0,W3
01F60:  CALL    1898
*
02924:  MOV     #8,W4
02926:  MOV     #B3,W2
02928:  MOV     #0,W3
0292A:  CALL    1898
....................    spi_xfer(SP, 0x10); 
*
01F64:  MOV     #8,W4
01F66:  MOV     #10,W2
01F68:  MOV     #0,W3
01F6A:  CALL    1898
*
0292E:  MOV     #8,W4
02930:  MOV     #10,W2
02932:  MOV     #0,W3
02934:  CALL    1898
....................    for(i=0;i<6;++i) 
*
01F6E:  CLR.B   88A
01F70:  MOV.B   88A,W0L
01F72:  SE      W0,W0
01F74:  CP      W0,#6
01F76:  BRA     GE,1F92
*
02938:  CLR.B   88A
0293A:  MOV.B   88A,W0L
0293C:  SE      W0,W0
0293E:  CP      W0,#6
02940:  BRA     GE,295C
....................    { 
....................       data3[i]=spi_xfer(SP, 0xFF);  
*
01F78:  MOV.B   88A,W0L
01F7A:  SE      W0,W0
01F7C:  MOV     #884,W4
01F7E:  ADD     W0,W4,W5
01F80:  MOV     #8,W4
01F82:  MOV     #FF,W2
01F84:  MOV     #0,W3
01F86:  CALL    1898
01F8A:  MOV.B   W0L,[W5]
01F8C:  INC.B   088A
01F8E:  GOTO    1F70
*
02942:  MOV.B   88A,W0L
02944:  SE      W0,W0
02946:  MOV     #884,W4
02948:  ADD     W0,W4,W5
0294A:  MOV     #8,W4
0294C:  MOV     #FF,W2
0294E:  MOV     #0,W3
02950:  CALL    1898
02954:  MOV.B   W0L,[W5]
02956:  INC.B   088A
02958:  GOTO    293A
....................    } 
....................    output_high(CS_LTC6811); 
*
01F92:  BCLR.B  2C0.0
01F94:  BSET.B  2C4.0
*
0295C:  BCLR.B  2C0.0
0295E:  BSET.B  2C4.0
....................     
....................    //calculo de los voltajes de las celdas y el voltaje total 
....................    am=0; 
*
01F96:  CLR.B   88B
*
02960:  CLR.B   88B
....................    total=0; 
*
01F98:  CLR     826
*
02962:  CLR     826
....................    V_min_aux=0xFFFF; 
*
01F9A:  SETM    86E
*
02964:  SETM    86E
....................    V_max_aux=0; 
*
01F9C:  CLR     870
*
02966:  CLR     870
....................    for(i=0;i<6;i=i+2) 
*
01F9E:  CLR.B   88A
01FA0:  MOV.B   88A,W0L
01FA2:  SE      W0,W0
01FA4:  CP      W0,#6
01FA6:  BRA     GE,204A
*
02968:  CLR.B   88A
0296A:  MOV.B   88A,W0L
0296C:  SE      W0,W0
0296E:  CP      W0,#6
02970:  BRA     GE,2A14
....................    { 
....................       voltaje[am]=make16(data[i+1],data[i])/10; 
*
01FA8:  MOV.B   88B,W0L
01FAA:  SE      W0,W0
01FAC:  MOV     W0,W4
01FAE:  MUL.UU  W4,#2,W0
01FB0:  MOV     86C,W4
01FB2:  ADD     W0,W4,W5
01FB4:  MOV.B   88A,W0L
01FB6:  SE      W0,W0
01FB8:  ADD     W0,#1,W0
01FBA:  MOV     W0,W6
01FBC:  MOV     #872,W4
01FBE:  ADD     W6,W4,W0
01FC0:  MOV.B   [W0],W7L
01FC2:  MOV.B   88A,W0L
01FC4:  SE      W0,W0
01FC6:  MOV     #872,W4
01FC8:  ADD     W0,W4,W0
01FCA:  MOV.B   [W0],W8L
01FCC:  MOV.B   W8L,W9L
01FCE:  MOV.B   W7L,W0L
01FD0:  MOV.B   W0L,13
01FD2:  MOV     W9,W4
01FD4:  MOV     #A,W3
01FD6:  REPEAT  #11
01FD8:  DIV.U   W4,W3
01FDA:  MOV     W0,[W5]
*
02972:  MOV.B   88B,W0L
02974:  SE      W0,W0
02976:  MOV     W0,W4
02978:  MUL.UU  W4,#2,W0
0297A:  MOV     86C,W4
0297C:  ADD     W0,W4,W5
0297E:  MOV.B   88A,W0L
02980:  SE      W0,W0
02982:  ADD     W0,#1,W0
02984:  MOV     W0,W6
02986:  MOV     #872,W4
02988:  ADD     W6,W4,W0
0298A:  MOV.B   [W0],W7L
0298C:  MOV.B   88A,W0L
0298E:  SE      W0,W0
02990:  MOV     #872,W4
02992:  ADD     W0,W4,W0
02994:  MOV.B   [W0],W8L
02996:  MOV.B   W8L,W9L
02998:  MOV.B   W7L,W0L
0299A:  MOV.B   W0L,13
0299C:  MOV     W9,W4
0299E:  MOV     #A,W3
029A0:  REPEAT  #11
029A2:  DIV.U   W4,W3
029A4:  MOV     W0,[W5]
....................       total=total+voltaje[am]; 
*
01FDC:  MOV.B   88B,W0L
01FDE:  SE      W0,W0
01FE0:  MOV     W0,W4
01FE2:  MUL.UU  W4,#2,W0
01FE4:  MOV     86C,W4
01FE6:  ADD     W0,W4,W0
01FE8:  MOV     W0,W4
01FEA:  MOV     [W4],W0
01FEC:  ADD     826
*
029A6:  MOV.B   88B,W0L
029A8:  SE      W0,W0
029AA:  MOV     W0,W4
029AC:  MUL.UU  W4,#2,W0
029AE:  MOV     86C,W4
029B0:  ADD     W0,W4,W0
029B2:  MOV     W0,W4
029B4:  MOV     [W4],W0
029B6:  ADD     826
....................       if(voltaje[am]<V_min_aux) V_min_aux=voltaje[am]; 
*
01FEE:  MOV.B   88B,W0L
01FF0:  SE      W0,W0
01FF2:  MOV     W0,W4
01FF4:  MUL.UU  W4,#2,W0
01FF6:  MOV     86C,W4
01FF8:  ADD     W0,W4,W0
01FFA:  MOV     [W0],W5
01FFC:  MOV     86E,W4
01FFE:  CP      W4,W5
02000:  BRA     LEU,2012
02002:  MOV.B   88B,W0L
02004:  SE      W0,W0
02006:  MOV     W0,W4
02008:  MUL.UU  W4,#2,W0
0200A:  MOV     86C,W4
0200C:  ADD     W0,W4,W0
0200E:  MOV     [W0],[W15++]
02010:  POP     86E
*
029B8:  MOV.B   88B,W0L
029BA:  SE      W0,W0
029BC:  MOV     W0,W4
029BE:  MUL.UU  W4,#2,W0
029C0:  MOV     86C,W4
029C2:  ADD     W0,W4,W0
029C4:  MOV     [W0],W5
029C6:  MOV     86E,W4
029C8:  CP      W4,W5
029CA:  BRA     LEU,29DC
029CC:  MOV.B   88B,W0L
029CE:  SE      W0,W0
029D0:  MOV     W0,W4
029D2:  MUL.UU  W4,#2,W0
029D4:  MOV     86C,W4
029D6:  ADD     W0,W4,W0
029D8:  MOV     [W0],[W15++]
029DA:  POP     86E
....................       if(voltaje[am]>V_max_aux) V_max_aux=voltaje[am]; 
*
02012:  MOV.B   88B,W0L
02014:  SE      W0,W0
02016:  MOV     W0,W4
02018:  MUL.UU  W4,#2,W0
0201A:  MOV     86C,W4
0201C:  ADD     W0,W4,W0
0201E:  MOV     [W0],W5
02020:  MOV     870,W4
02022:  CP      W4,W5
02024:  BRA     C,2036
02026:  MOV.B   88B,W0L
02028:  SE      W0,W0
0202A:  MOV     W0,W4
0202C:  MUL.UU  W4,#2,W0
0202E:  MOV     86C,W4
02030:  ADD     W0,W4,W0
02032:  MOV     [W0],[W15++]
02034:  POP     870
*
029DC:  MOV.B   88B,W0L
029DE:  SE      W0,W0
029E0:  MOV     W0,W4
029E2:  MUL.UU  W4,#2,W0
029E4:  MOV     86C,W4
029E6:  ADD     W0,W4,W0
029E8:  MOV     [W0],W5
029EA:  MOV     870,W4
029EC:  CP      W4,W5
029EE:  BRA     C,2A00
029F0:  MOV.B   88B,W0L
029F2:  SE      W0,W0
029F4:  MOV     W0,W4
029F6:  MUL.UU  W4,#2,W0
029F8:  MOV     86C,W4
029FA:  ADD     W0,W4,W0
029FC:  MOV     [W0],[W15++]
029FE:  POP     870
....................       am=am+1; 
*
02036:  MOV.B   88B,W0L
02038:  SE      W0,W0
0203A:  ADD     W0,#1,W0
0203C:  MOV.B   W0L,88B
0203E:  MOV.B   88A,W0L
02040:  SE      W0,W0
02042:  ADD     W0,#2,W0
02044:  MOV.B   W0L,88A
02046:  GOTO    1FA0
*
02A00:  MOV.B   88B,W0L
02A02:  SE      W0,W0
02A04:  ADD     W0,#1,W0
02A06:  MOV.B   W0L,88B
02A08:  MOV.B   88A,W0L
02A0A:  SE      W0,W0
02A0C:  ADD     W0,#2,W0
02A0E:  MOV.B   W0L,88A
02A10:  GOTO    296A
....................    } 
....................    for(i=0;i<6;i=i+2) 
*
0204A:  CLR.B   88A
0204C:  MOV.B   88A,W0L
0204E:  SE      W0,W0
02050:  CP      W0,#6
02052:  BRA     GE,20F6
*
02A14:  CLR.B   88A
02A16:  MOV.B   88A,W0L
02A18:  SE      W0,W0
02A1A:  CP      W0,#6
02A1C:  BRA     GE,2AC0
....................    { 
....................       voltaje[am]=make16(data1[i+1],data1[i])/10; 
*
02054:  MOV.B   88B,W0L
02056:  SE      W0,W0
02058:  MOV     W0,W4
0205A:  MUL.UU  W4,#2,W0
0205C:  MOV     86C,W4
0205E:  ADD     W0,W4,W5
02060:  MOV.B   88A,W0L
02062:  SE      W0,W0
02064:  ADD     W0,#1,W0
02066:  MOV     W0,W6
02068:  MOV     #878,W4
0206A:  ADD     W6,W4,W0
0206C:  MOV.B   [W0],W7L
0206E:  MOV.B   88A,W0L
02070:  SE      W0,W0
02072:  MOV     #878,W4
02074:  ADD     W0,W4,W0
02076:  MOV.B   [W0],W8L
02078:  MOV.B   W8L,W9L
0207A:  MOV.B   W7L,W0L
0207C:  MOV.B   W0L,13
0207E:  MOV     W9,W4
02080:  MOV     #A,W3
02082:  REPEAT  #11
02084:  DIV.U   W4,W3
02086:  MOV     W0,[W5]
*
02A1E:  MOV.B   88B,W0L
02A20:  SE      W0,W0
02A22:  MOV     W0,W4
02A24:  MUL.UU  W4,#2,W0
02A26:  MOV     86C,W4
02A28:  ADD     W0,W4,W5
02A2A:  MOV.B   88A,W0L
02A2C:  SE      W0,W0
02A2E:  ADD     W0,#1,W0
02A30:  MOV     W0,W6
02A32:  MOV     #878,W4
02A34:  ADD     W6,W4,W0
02A36:  MOV.B   [W0],W7L
02A38:  MOV.B   88A,W0L
02A3A:  SE      W0,W0
02A3C:  MOV     #878,W4
02A3E:  ADD     W0,W4,W0
02A40:  MOV.B   [W0],W8L
02A42:  MOV.B   W8L,W9L
02A44:  MOV.B   W7L,W0L
02A46:  MOV.B   W0L,13
02A48:  MOV     W9,W4
02A4A:  MOV     #A,W3
02A4C:  REPEAT  #11
02A4E:  DIV.U   W4,W3
02A50:  MOV     W0,[W5]
....................       total=total+voltaje[am]; 
*
02088:  MOV.B   88B,W0L
0208A:  SE      W0,W0
0208C:  MOV     W0,W4
0208E:  MUL.UU  W4,#2,W0
02090:  MOV     86C,W4
02092:  ADD     W0,W4,W0
02094:  MOV     W0,W4
02096:  MOV     [W4],W0
02098:  ADD     826
*
02A52:  MOV.B   88B,W0L
02A54:  SE      W0,W0
02A56:  MOV     W0,W4
02A58:  MUL.UU  W4,#2,W0
02A5A:  MOV     86C,W4
02A5C:  ADD     W0,W4,W0
02A5E:  MOV     W0,W4
02A60:  MOV     [W4],W0
02A62:  ADD     826
....................       if(voltaje[am]<V_min_aux) V_min_aux=voltaje[am]; 
*
0209A:  MOV.B   88B,W0L
0209C:  SE      W0,W0
0209E:  MOV     W0,W4
020A0:  MUL.UU  W4,#2,W0
020A2:  MOV     86C,W4
020A4:  ADD     W0,W4,W0
020A6:  MOV     [W0],W5
020A8:  MOV     86E,W4
020AA:  CP      W4,W5
020AC:  BRA     LEU,20BE
020AE:  MOV.B   88B,W0L
020B0:  SE      W0,W0
020B2:  MOV     W0,W4
020B4:  MUL.UU  W4,#2,W0
020B6:  MOV     86C,W4
020B8:  ADD     W0,W4,W0
020BA:  MOV     [W0],[W15++]
020BC:  POP     86E
*
02A64:  MOV.B   88B,W0L
02A66:  SE      W0,W0
02A68:  MOV     W0,W4
02A6A:  MUL.UU  W4,#2,W0
02A6C:  MOV     86C,W4
02A6E:  ADD     W0,W4,W0
02A70:  MOV     [W0],W5
02A72:  MOV     86E,W4
02A74:  CP      W4,W5
02A76:  BRA     LEU,2A88
02A78:  MOV.B   88B,W0L
02A7A:  SE      W0,W0
02A7C:  MOV     W0,W4
02A7E:  MUL.UU  W4,#2,W0
02A80:  MOV     86C,W4
02A82:  ADD     W0,W4,W0
02A84:  MOV     [W0],[W15++]
02A86:  POP     86E
....................       if(voltaje[am]>V_max_aux) V_max_aux=voltaje[am]; 
*
020BE:  MOV.B   88B,W0L
020C0:  SE      W0,W0
020C2:  MOV     W0,W4
020C4:  MUL.UU  W4,#2,W0
020C6:  MOV     86C,W4
020C8:  ADD     W0,W4,W0
020CA:  MOV     [W0],W5
020CC:  MOV     870,W4
020CE:  CP      W4,W5
020D0:  BRA     C,20E2
020D2:  MOV.B   88B,W0L
020D4:  SE      W0,W0
020D6:  MOV     W0,W4
020D8:  MUL.UU  W4,#2,W0
020DA:  MOV     86C,W4
020DC:  ADD     W0,W4,W0
020DE:  MOV     [W0],[W15++]
020E0:  POP     870
*
02A88:  MOV.B   88B,W0L
02A8A:  SE      W0,W0
02A8C:  MOV     W0,W4
02A8E:  MUL.UU  W4,#2,W0
02A90:  MOV     86C,W4
02A92:  ADD     W0,W4,W0
02A94:  MOV     [W0],W5
02A96:  MOV     870,W4
02A98:  CP      W4,W5
02A9A:  BRA     C,2AAC
02A9C:  MOV.B   88B,W0L
02A9E:  SE      W0,W0
02AA0:  MOV     W0,W4
02AA2:  MUL.UU  W4,#2,W0
02AA4:  MOV     86C,W4
02AA6:  ADD     W0,W4,W0
02AA8:  MOV     [W0],[W15++]
02AAA:  POP     870
....................       am=am+1; 
*
020E2:  MOV.B   88B,W0L
020E4:  SE      W0,W0
020E6:  ADD     W0,#1,W0
020E8:  MOV.B   W0L,88B
020EA:  MOV.B   88A,W0L
020EC:  SE      W0,W0
020EE:  ADD     W0,#2,W0
020F0:  MOV.B   W0L,88A
020F2:  GOTO    204C
*
02AAC:  MOV.B   88B,W0L
02AAE:  SE      W0,W0
02AB0:  ADD     W0,#1,W0
02AB2:  MOV.B   W0L,88B
02AB4:  MOV.B   88A,W0L
02AB6:  SE      W0,W0
02AB8:  ADD     W0,#2,W0
02ABA:  MOV.B   W0L,88A
02ABC:  GOTO    2A16
....................    } 
....................    for(i=0;i<6;i=i+2) 
*
020F6:  CLR.B   88A
020F8:  MOV.B   88A,W0L
020FA:  SE      W0,W0
020FC:  CP      W0,#6
020FE:  BRA     GE,21A2
*
02AC0:  CLR.B   88A
02AC2:  MOV.B   88A,W0L
02AC4:  SE      W0,W0
02AC6:  CP      W0,#6
02AC8:  BRA     GE,2B6C
....................    { 
....................       voltaje[am]=make16(data2[i+1],data2[i])/10; 
*
02100:  MOV.B   88B,W0L
02102:  SE      W0,W0
02104:  MOV     W0,W4
02106:  MUL.UU  W4,#2,W0
02108:  MOV     86C,W4
0210A:  ADD     W0,W4,W5
0210C:  MOV.B   88A,W0L
0210E:  SE      W0,W0
02110:  ADD     W0,#1,W0
02112:  MOV     W0,W6
02114:  MOV     #87E,W4
02116:  ADD     W6,W4,W0
02118:  MOV.B   [W0],W7L
0211A:  MOV.B   88A,W0L
0211C:  SE      W0,W0
0211E:  MOV     #87E,W4
02120:  ADD     W0,W4,W0
02122:  MOV.B   [W0],W8L
02124:  MOV.B   W8L,W9L
02126:  MOV.B   W7L,W0L
02128:  MOV.B   W0L,13
0212A:  MOV     W9,W4
0212C:  MOV     #A,W3
0212E:  REPEAT  #11
02130:  DIV.U   W4,W3
02132:  MOV     W0,[W5]
*
02ACA:  MOV.B   88B,W0L
02ACC:  SE      W0,W0
02ACE:  MOV     W0,W4
02AD0:  MUL.UU  W4,#2,W0
02AD2:  MOV     86C,W4
02AD4:  ADD     W0,W4,W5
02AD6:  MOV.B   88A,W0L
02AD8:  SE      W0,W0
02ADA:  ADD     W0,#1,W0
02ADC:  MOV     W0,W6
02ADE:  MOV     #87E,W4
02AE0:  ADD     W6,W4,W0
02AE2:  MOV.B   [W0],W7L
02AE4:  MOV.B   88A,W0L
02AE6:  SE      W0,W0
02AE8:  MOV     #87E,W4
02AEA:  ADD     W0,W4,W0
02AEC:  MOV.B   [W0],W8L
02AEE:  MOV.B   W8L,W9L
02AF0:  MOV.B   W7L,W0L
02AF2:  MOV.B   W0L,13
02AF4:  MOV     W9,W4
02AF6:  MOV     #A,W3
02AF8:  REPEAT  #11
02AFA:  DIV.U   W4,W3
02AFC:  MOV     W0,[W5]
....................       total=total+voltaje[am]; 
*
02134:  MOV.B   88B,W0L
02136:  SE      W0,W0
02138:  MOV     W0,W4
0213A:  MUL.UU  W4,#2,W0
0213C:  MOV     86C,W4
0213E:  ADD     W0,W4,W0
02140:  MOV     W0,W4
02142:  MOV     [W4],W0
02144:  ADD     826
*
02AFE:  MOV.B   88B,W0L
02B00:  SE      W0,W0
02B02:  MOV     W0,W4
02B04:  MUL.UU  W4,#2,W0
02B06:  MOV     86C,W4
02B08:  ADD     W0,W4,W0
02B0A:  MOV     W0,W4
02B0C:  MOV     [W4],W0
02B0E:  ADD     826
....................       if(voltaje[am]<V_min_aux) V_min_aux=voltaje[am]; 
*
02146:  MOV.B   88B,W0L
02148:  SE      W0,W0
0214A:  MOV     W0,W4
0214C:  MUL.UU  W4,#2,W0
0214E:  MOV     86C,W4
02150:  ADD     W0,W4,W0
02152:  MOV     [W0],W5
02154:  MOV     86E,W4
02156:  CP      W4,W5
02158:  BRA     LEU,216A
0215A:  MOV.B   88B,W0L
0215C:  SE      W0,W0
0215E:  MOV     W0,W4
02160:  MUL.UU  W4,#2,W0
02162:  MOV     86C,W4
02164:  ADD     W0,W4,W0
02166:  MOV     [W0],[W15++]
02168:  POP     86E
*
02B10:  MOV.B   88B,W0L
02B12:  SE      W0,W0
02B14:  MOV     W0,W4
02B16:  MUL.UU  W4,#2,W0
02B18:  MOV     86C,W4
02B1A:  ADD     W0,W4,W0
02B1C:  MOV     [W0],W5
02B1E:  MOV     86E,W4
02B20:  CP      W4,W5
02B22:  BRA     LEU,2B34
02B24:  MOV.B   88B,W0L
02B26:  SE      W0,W0
02B28:  MOV     W0,W4
02B2A:  MUL.UU  W4,#2,W0
02B2C:  MOV     86C,W4
02B2E:  ADD     W0,W4,W0
02B30:  MOV     [W0],[W15++]
02B32:  POP     86E
....................       if(voltaje[am]>V_max_aux) V_max_aux=voltaje[am]; 
*
0216A:  MOV.B   88B,W0L
0216C:  SE      W0,W0
0216E:  MOV     W0,W4
02170:  MUL.UU  W4,#2,W0
02172:  MOV     86C,W4
02174:  ADD     W0,W4,W0
02176:  MOV     [W0],W5
02178:  MOV     870,W4
0217A:  CP      W4,W5
0217C:  BRA     C,218E
0217E:  MOV.B   88B,W0L
02180:  SE      W0,W0
02182:  MOV     W0,W4
02184:  MUL.UU  W4,#2,W0
02186:  MOV     86C,W4
02188:  ADD     W0,W4,W0
0218A:  MOV     [W0],[W15++]
0218C:  POP     870
*
02B34:  MOV.B   88B,W0L
02B36:  SE      W0,W0
02B38:  MOV     W0,W4
02B3A:  MUL.UU  W4,#2,W0
02B3C:  MOV     86C,W4
02B3E:  ADD     W0,W4,W0
02B40:  MOV     [W0],W5
02B42:  MOV     870,W4
02B44:  CP      W4,W5
02B46:  BRA     C,2B58
02B48:  MOV.B   88B,W0L
02B4A:  SE      W0,W0
02B4C:  MOV     W0,W4
02B4E:  MUL.UU  W4,#2,W0
02B50:  MOV     86C,W4
02B52:  ADD     W0,W4,W0
02B54:  MOV     [W0],[W15++]
02B56:  POP     870
....................       am=am+1; 
*
0218E:  MOV.B   88B,W0L
02190:  SE      W0,W0
02192:  ADD     W0,#1,W0
02194:  MOV.B   W0L,88B
02196:  MOV.B   88A,W0L
02198:  SE      W0,W0
0219A:  ADD     W0,#2,W0
0219C:  MOV.B   W0L,88A
0219E:  GOTO    20F8
*
02B58:  MOV.B   88B,W0L
02B5A:  SE      W0,W0
02B5C:  ADD     W0,#1,W0
02B5E:  MOV.B   W0L,88B
02B60:  MOV.B   88A,W0L
02B62:  SE      W0,W0
02B64:  ADD     W0,#2,W0
02B66:  MOV.B   W0L,88A
02B68:  GOTO    2AC2
....................    } 
....................    for(i=0;i<6;i=i+2) 
*
021A2:  CLR.B   88A
021A4:  MOV.B   88A,W0L
021A6:  SE      W0,W0
021A8:  CP      W0,#6
021AA:  BRA     GE,224E
*
02B6C:  CLR.B   88A
02B6E:  MOV.B   88A,W0L
02B70:  SE      W0,W0
02B72:  CP      W0,#6
02B74:  BRA     GE,2C18
....................    { 
....................       voltaje[am]=make16(data3[i+1],data3[i])/10; 
*
021AC:  MOV.B   88B,W0L
021AE:  SE      W0,W0
021B0:  MOV     W0,W4
021B2:  MUL.UU  W4,#2,W0
021B4:  MOV     86C,W4
021B6:  ADD     W0,W4,W5
021B8:  MOV.B   88A,W0L
021BA:  SE      W0,W0
021BC:  ADD     W0,#1,W0
021BE:  MOV     W0,W6
021C0:  MOV     #884,W4
021C2:  ADD     W6,W4,W0
021C4:  MOV.B   [W0],W7L
021C6:  MOV.B   88A,W0L
021C8:  SE      W0,W0
021CA:  MOV     #884,W4
021CC:  ADD     W0,W4,W0
021CE:  MOV.B   [W0],W8L
021D0:  MOV.B   W8L,W9L
021D2:  MOV.B   W7L,W0L
021D4:  MOV.B   W0L,13
021D6:  MOV     W9,W4
021D8:  MOV     #A,W3
021DA:  REPEAT  #11
021DC:  DIV.U   W4,W3
021DE:  MOV     W0,[W5]
*
02B76:  MOV.B   88B,W0L
02B78:  SE      W0,W0
02B7A:  MOV     W0,W4
02B7C:  MUL.UU  W4,#2,W0
02B7E:  MOV     86C,W4
02B80:  ADD     W0,W4,W5
02B82:  MOV.B   88A,W0L
02B84:  SE      W0,W0
02B86:  ADD     W0,#1,W0
02B88:  MOV     W0,W6
02B8A:  MOV     #884,W4
02B8C:  ADD     W6,W4,W0
02B8E:  MOV.B   [W0],W7L
02B90:  MOV.B   88A,W0L
02B92:  SE      W0,W0
02B94:  MOV     #884,W4
02B96:  ADD     W0,W4,W0
02B98:  MOV.B   [W0],W8L
02B9A:  MOV.B   W8L,W9L
02B9C:  MOV.B   W7L,W0L
02B9E:  MOV.B   W0L,13
02BA0:  MOV     W9,W4
02BA2:  MOV     #A,W3
02BA4:  REPEAT  #11
02BA6:  DIV.U   W4,W3
02BA8:  MOV     W0,[W5]
....................       total=total+voltaje[am]; 
*
021E0:  MOV.B   88B,W0L
021E2:  SE      W0,W0
021E4:  MOV     W0,W4
021E6:  MUL.UU  W4,#2,W0
021E8:  MOV     86C,W4
021EA:  ADD     W0,W4,W0
021EC:  MOV     W0,W4
021EE:  MOV     [W4],W0
021F0:  ADD     826
*
02BAA:  MOV.B   88B,W0L
02BAC:  SE      W0,W0
02BAE:  MOV     W0,W4
02BB0:  MUL.UU  W4,#2,W0
02BB2:  MOV     86C,W4
02BB4:  ADD     W0,W4,W0
02BB6:  MOV     W0,W4
02BB8:  MOV     [W4],W0
02BBA:  ADD     826
....................       if(voltaje[am]<V_min_aux) V_min_aux=voltaje[am]; 
*
021F2:  MOV.B   88B,W0L
021F4:  SE      W0,W0
021F6:  MOV     W0,W4
021F8:  MUL.UU  W4,#2,W0
021FA:  MOV     86C,W4
021FC:  ADD     W0,W4,W0
021FE:  MOV     [W0],W5
02200:  MOV     86E,W4
02202:  CP      W4,W5
02204:  BRA     LEU,2216
02206:  MOV.B   88B,W0L
02208:  SE      W0,W0
0220A:  MOV     W0,W4
0220C:  MUL.UU  W4,#2,W0
0220E:  MOV     86C,W4
02210:  ADD     W0,W4,W0
02212:  MOV     [W0],[W15++]
02214:  POP     86E
*
02BBC:  MOV.B   88B,W0L
02BBE:  SE      W0,W0
02BC0:  MOV     W0,W4
02BC2:  MUL.UU  W4,#2,W0
02BC4:  MOV     86C,W4
02BC6:  ADD     W0,W4,W0
02BC8:  MOV     [W0],W5
02BCA:  MOV     86E,W4
02BCC:  CP      W4,W5
02BCE:  BRA     LEU,2BE0
02BD0:  MOV.B   88B,W0L
02BD2:  SE      W0,W0
02BD4:  MOV     W0,W4
02BD6:  MUL.UU  W4,#2,W0
02BD8:  MOV     86C,W4
02BDA:  ADD     W0,W4,W0
02BDC:  MOV     [W0],[W15++]
02BDE:  POP     86E
....................       if(voltaje[am]>V_max_aux) V_max_aux=voltaje[am]; 
*
02216:  MOV.B   88B,W0L
02218:  SE      W0,W0
0221A:  MOV     W0,W4
0221C:  MUL.UU  W4,#2,W0
0221E:  MOV     86C,W4
02220:  ADD     W0,W4,W0
02222:  MOV     [W0],W5
02224:  MOV     870,W4
02226:  CP      W4,W5
02228:  BRA     C,223A
0222A:  MOV.B   88B,W0L
0222C:  SE      W0,W0
0222E:  MOV     W0,W4
02230:  MUL.UU  W4,#2,W0
02232:  MOV     86C,W4
02234:  ADD     W0,W4,W0
02236:  MOV     [W0],[W15++]
02238:  POP     870
*
02BE0:  MOV.B   88B,W0L
02BE2:  SE      W0,W0
02BE4:  MOV     W0,W4
02BE6:  MUL.UU  W4,#2,W0
02BE8:  MOV     86C,W4
02BEA:  ADD     W0,W4,W0
02BEC:  MOV     [W0],W5
02BEE:  MOV     870,W4
02BF0:  CP      W4,W5
02BF2:  BRA     C,2C04
02BF4:  MOV.B   88B,W0L
02BF6:  SE      W0,W0
02BF8:  MOV     W0,W4
02BFA:  MUL.UU  W4,#2,W0
02BFC:  MOV     86C,W4
02BFE:  ADD     W0,W4,W0
02C00:  MOV     [W0],[W15++]
02C02:  POP     870
....................       am=am+1; 
*
0223A:  MOV.B   88B,W0L
0223C:  SE      W0,W0
0223E:  ADD     W0,#1,W0
02240:  MOV.B   W0L,88B
02242:  MOV.B   88A,W0L
02244:  SE      W0,W0
02246:  ADD     W0,#2,W0
02248:  MOV.B   W0L,88A
0224A:  GOTO    21A4
*
02C04:  MOV.B   88B,W0L
02C06:  SE      W0,W0
02C08:  ADD     W0,#1,W0
02C0A:  MOV.B   W0L,88B
02C0C:  MOV.B   88A,W0L
02C0E:  SE      W0,W0
02C10:  ADD     W0,#2,W0
02C12:  MOV.B   W0L,88A
02C14:  GOTO    2B6E
....................    }   
....................     
.................... } 
....................  
....................  
....................  
.................... // 
.................... // BALANCEO is a function that evaluate the conditions of balancing and give the order to the IC. 
.................... // 
.................... // The alogorith works the following way, it evaluates individualy each cell and if its voltage is over a limit (v_min) and the balancing temperature (temp_slave_max) is below the maximum (temp_max) 
.................... // and (the voltage is over a upper limit (v_balanceo) or the difference between the cell voltaje is bigger than a difference (diff_max) with the minimum cell voltage (v_cell_min)). 
.................... // 
....................  
.................... void BLANCEO(uint16_t &v_cell_min, uint16_t &v_balanceo, uint16_t &v_min, uint8_t &diff_max, uint8_t &diff_min, uint16_t *voltaje, uint16_t &temp_max, uint16_t &temp_slave_max) 
*
02514:  CLR     87A
02516:  CLR     87C
.................... { 
....................    int8 i, a, balanceo1, balanceo2; 
....................    int1 bal; 
....................    int8 pec[6]; 
....................    int16 remainder=0, addr=0,out; 
....................    const unsigned int16 crc15Table[256] = {0x0,0xc599, 0xceab, 0xb32, 0xd8cf, 0x1d56, 0x1664, 0xd3fd, 0xf407, 0x319e, 0x3aac,  //!<precomputed CRC15 Table 
....................    0xff35, 0x2cc8, 0xe951, 0xe263, 0x27fa, 0xad97, 0x680e, 0x633c, 0xa6a5, 0x7558, 0xb0c1,  
....................    0xbbf3, 0x7e6a, 0x5990, 0x9c09, 0x973b, 0x52a2, 0x815f, 0x44c6, 0x4ff4, 0x8a6d, 0x5b2e, 
....................    0x9eb7, 0x9585, 0x501c, 0x83e1, 0x4678, 0x4d4a, 0x88d3, 0xaf29, 0x6ab0, 0x6182, 0xa41b, 
....................    0x77e6, 0xb27f, 0xb94d, 0x7cd4, 0xf6b9, 0x3320, 0x3812, 0xfd8b, 0x2e76, 0xebef, 0xe0dd,  
....................    0x2544, 0x2be, 0xc727, 0xcc15, 0x98c, 0xda71, 0x1fe8, 0x14da, 0xd143, 0xf3c5, 0x365c,  
....................    0x3d6e, 0xf8f7,0x2b0a, 0xee93, 0xe5a1, 0x2038, 0x7c2, 0xc25b, 0xc969, 0xcf0, 0xdf0d,  
....................    0x1a94, 0x11a6, 0xd43f, 0x5e52, 0x9bcb, 0x90f9, 0x5560, 0x869d, 0x4304, 0x4836, 0x8daf, 
....................    0xaa55, 0x6fcc, 0x64fe, 0xa167, 0x729a, 0xb703, 0xbc31, 0x79a8, 0xa8eb, 0x6d72, 0x6640, 
....................    0xa3d9, 0x7024, 0xb5bd, 0xbe8f, 0x7b16, 0x5cec, 0x9975, 0x9247, 0x57de, 0x8423, 0x41ba, 
....................    0x4a88, 0x8f11, 0x57c, 0xc0e5, 0xcbd7, 0xe4e, 0xddb3, 0x182a, 0x1318, 0xd681, 0xf17b,  
....................    0x34e2, 0x3fd0, 0xfa49, 0x29b4, 0xec2d, 0xe71f, 0x2286, 0xa213, 0x678a, 0x6cb8, 0xa921,  
....................    0x7adc, 0xbf45, 0xb477, 0x71ee, 0x5614, 0x938d, 0x98bf, 0x5d26, 0x8edb, 0x4b42, 0x4070,  
....................    0x85e9, 0xf84, 0xca1d, 0xc12f, 0x4b6, 0xd74b, 0x12d2, 0x19e0, 0xdc79, 0xfb83, 0x3e1a, 0x3528,  
....................    0xf0b1, 0x234c, 0xe6d5, 0xede7, 0x287e, 0xf93d, 0x3ca4, 0x3796, 0xf20f, 0x21f2, 0xe46b, 0xef59,  
....................    0x2ac0, 0xd3a, 0xc8a3, 0xc391, 0x608, 0xd5f5, 0x106c, 0x1b5e, 0xdec7, 0x54aa, 0x9133, 0x9a01,  
....................    0x5f98, 0x8c65, 0x49fc, 0x42ce, 0x8757, 0xa0ad, 0x6534, 0x6e06, 0xab9f, 0x7862, 0xbdfb, 0xb6c9,  
....................    0x7350, 0x51d6, 0x944f, 0x9f7d, 0x5ae4, 0x8919, 0x4c80, 0x47b2, 0x822b, 0xa5d1, 0x6048, 0x6b7a,  
....................    0xaee3, 0x7d1e, 0xb887, 0xb3b5, 0x762c, 0xfc41, 0x39d8, 0x32ea, 0xf773, 0x248e, 0xe117, 0xea25,  
....................    0x2fbc, 0x846, 0xcddf, 0xc6ed, 0x374, 0xd089, 0x1510, 0x1e22, 0xdbbb, 0xaf8, 0xcf61, 0xc453,  
....................    0x1ca, 0xd237, 0x17ae, 0x1c9c, 0xd905, 0xfeff, 0x3b66, 0x3054, 0xf5cd, 0x2630, 0xe3a9, 0xe89b,  
....................    0x2d02, 0xa76f, 0x62f6, 0x69c4, 0xac5d, 0x7fa0, 0xba39, 0xb10b, 0x7492, 0x5368, 0x96f1, 0x9dc3,  
....................    0x585a, 0x8ba7, 0x4e3e, 0x450c, 0x8095}; 
....................     
....................    balanceo1=0; 
02518:  CLR.B   870
....................    balanceo2=0; 
0251A:  CLR.B   871
....................     
....................    for (a=0;a<12;a++) 
0251C:  CLR.B   86F
0251E:  MOV.B   86F,W0L
02520:  SE      W0,W0
02522:  CP      W0,#C
02524:  BRA     GE,2748
....................    { 
....................        
....................       if(voltaje[a]>v_min && temp_slave_max<temp_max && (voltaje[a]> v_balanceo || (voltaje[a]-v_cell_min)>diff_max)) 
02526:  MOV.B   86F,W0L
02528:  SE      W0,W0
0252A:  MOV     W0,W4
0252C:  MUL.UU  W4,#2,W0
0252E:  MOV     86C,W4
02530:  ADD     W0,W4,W0
02532:  MOV     [W0],W5
02534:  MOV     84E,W4
02536:  CP      W4,W5
02538:  BRA     C,25A6
0253A:  MOV     854,W0
0253C:  MOV     852,W4
0253E:  CP      W4,W0
02540:  BRA     LEU,25A6
02542:  MOV.B   86F,W0L
02544:  SE      W0,W0
02546:  MOV     W0,W4
02548:  MUL.UU  W4,#2,W0
0254A:  MOV     86C,W4
0254C:  ADD     W0,W4,W0
0254E:  MOV     [W0],W5
02550:  MOV     850,W4
02552:  CP      W4,W5
02554:  BRA     NC,2570
02556:  MOV.B   86F,W0L
02558:  SE      W0,W0
0255A:  MOV     W0,W4
0255C:  MUL.UU  W4,#2,W0
0255E:  MOV     86C,W4
02560:  ADD     W0,W4,W0
02562:  MOV     [W0],W5
02564:  MOV     84C,W4
02566:  SUB     W5,W4,W5
02568:  MOV.B   80D,W0L
0256A:  CLR.B   1
0256C:  CP      W0,W5
0256E:  BRA     C,25A6
....................       { 
....................          bal=1; 
02570:  BSET.B  872.0
....................          if (a<8) 
02572:  MOV.B   86F,W0L
02574:  SE      W0,W0
02576:  CP      W0,#8
02578:  BRA     GE,2590
....................          { 
....................             balanceo1=(balanceo1|(1<<a)); 
0257A:  MOV     86E,W4
0257C:  LSR     W4,#8,W4
0257E:  CLR.B   9
02580:  MOV     #1,W5
02582:  SL      W5,W4,W5
02584:  MOV.B   870,W0L
02586:  SE      W0,W0
02588:  IOR      W0,  W5,W0
0258A:  MOV.B   W0L,870
....................          } 
0258C:  GOTO    25A2
....................          else 
....................          { 
....................             balanceo2=(balanceo2|(1<<(a-8))); 
02590:  MOV.B   86F,W0L
02592:  SE      W0,W0
02594:  SUB     W0,#8,W0
02596:  MOV     #1,W5
02598:  SL      W5,W0,W5
0259A:  MOV.B   871,W0L
0259C:  SE      W0,W0
0259E:  IOR      W0,  W5,W0
025A0:  MOV.B   W0L,871
....................          } 
....................       } 
025A2:  GOTO    25A8
....................       else 
....................       { 
....................          bal=0; 
025A6:  BCLR.B  872.0
....................       } 
....................        
....................        
....................       if(bal==1) 
025A8:  BTSS.B  872.0
025AA:  BRA     26B2
....................       { 
....................          pec[0]=0xF8; 
025AC:  MOV.B   #F8,W0L
025AE:  MOV.B   W0L,874
....................          pec[1]=0; 
025B0:  CLR.B   875
....................          pec[2]=0; 
025B2:  CLR.B   876
....................          pec[3]=0; 
025B4:  CLR.B   877
....................          pec[4]=balanceo1; 
025B6:  MOV.B   870,W0L
025B8:  MOV.B   W0L,878
....................          pec[5]=balanceo2; 
025BA:  MOV.B   871,W0L
025BC:  MOV.B   W0L,879
....................          remainder = 16; 
025BE:  MOV     #10,W4
025C0:  MOV     W4,87A
....................          for(i = 0; i<6;i++)  
025C2:  CLR.B   86E
025C4:  MOV.B   86E,W0L
025C6:  SE      W0,W0
025C8:  CP      W0,#6
025CA:  BRA     GE,25FE
....................          { 
....................             addr = ((remainder>>7)^pec[i])&0xff; 
025CC:  MOV     87A,W5
025CE:  LSR     W5,#7,W5
025D0:  MOV.B   86E,W0L
025D2:  SE      W0,W0
025D4:  MOV     #874,W4
025D6:  ADD     W0,W4,W0
025D8:  MOV     W0,W4
025DA:  MOV.B   [W4],W0L
025DC:  SE      W0,W0
025DE:  XOR     W5,W0,W5
025E0:  MOV     W5,W4
025E2:  AND     #FF,W4
025E4:  MOV     W4,87C
....................             remainder = (remainder<<8)^crc15Table[addr]; 
025E6:  MOV.B   87A,W0L
025E8:  MOV.B   W0L,B
025EA:  CLR.B   W5
025EC:  MOV     87C,W4
025EE:  MUL.UU  W4,#2,W0
025F0:  CALL    200
025F4:  XOR     W5,W0,W0
025F6:  MOV     W0,87A
025F8:  INC.B   086E
025FA:  GOTO    25C4
....................          } 
....................          out=remainder*2; 
025FE:  MOV     87A,W4
02600:  MUL.UU  W4,#2,W0
02602:  MOV     W0,87E
....................           
....................          output_low(CS_LTC6811); 
02604:  BCLR.B  2C0.0
02606:  BCLR.B  2C4.0
....................          delay_us(10); 
02608:  REPEAT  #62
0260A:  NOP     
....................          output_high(CS_LTC6811); 
0260C:  BCLR.B  2C0.0
0260E:  BSET.B  2C4.0
....................          delay_us(10); 
02610:  REPEAT  #62
02612:  NOP     
....................          output_low(CS_LTC6811); 
02614:  BCLR.B  2C0.0
02616:  BCLR.B  2C4.0
....................          spi_xfer(SP, 0x80);   
02618:  MOV     #8,W4
0261A:  MOV     #80,W2
0261C:  MOV     #0,W3
0261E:  CALL    1898
....................          spi_xfer(SP, 0x01);   
02622:  MOV     #8,W4
02624:  MOV     #1,W2
02626:  MOV     #0,W3
02628:  CALL    1898
....................          spi_xfer(SP, 0x4D);   
0262C:  MOV     #8,W4
0262E:  MOV     #4D,W2
02630:  MOV     #0,W3
02632:  CALL    1898
....................          spi_xfer(SP, 0x7A); 
02636:  MOV     #8,W4
02638:  MOV     #7A,W2
0263A:  MOV     #0,W3
0263C:  CALL    1898
....................           
....................          spi_xfer(SP, 0xF8); 
02640:  MOV     #8,W4
02642:  MOV     #F8,W2
02644:  MOV     #0,W3
02646:  CALL    1898
....................          spi_xfer(SP, 0x00); 
0264A:  MOV     #8,W4
0264C:  MOV     #0,W2
0264E:  MOV     #0,W3
02650:  CALL    1898
....................          spi_xfer(SP, 0x00); 
02654:  MOV     #8,W4
02656:  MOV     #0,W2
02658:  MOV     #0,W3
0265A:  CALL    1898
....................          spi_xfer(SP, 0x00); 
0265E:  MOV     #8,W4
02660:  MOV     #0,W2
02662:  MOV     #0,W3
02664:  CALL    1898
....................          spi_xfer(SP, balanceo1); 
02668:  MOV.B   870,W0L
0266A:  MOV.B   W0L,4
0266C:  SE      W2,W2
0266E:  CLR     W3
02670:  BTSC    W2.F
02672:  SETM    W3
02674:  MOV     #8,W4
02676:  CALL    1898
....................          spi_xfer(SP, balanceo2); 
0267A:  MOV.B   871,W0L
0267C:  MOV.B   W0L,W2L
0267E:  SE      W2,W2
02680:  CLR     W3
02682:  BTSC    W2.F
02684:  SETM    W3
02686:  MOV     #8,W4
02688:  CALL    1898
....................           
....................          spi_xfer(SP, (out>>8));   
0268C:  MOV.B   87F,W0L
0268E:  MOV.B   W0L,W5L
02690:  CLR.B   B
02692:  MOV     #8,W4
02694:  MOV     W5,W2
02696:  MOV     #0,W3
02698:  CALL    1898
....................          spi_xfer(SP, out); 
0269C:  MOV     #8,W4
0269E:  MOV     87E,W2
026A0:  CLR     W3
026A2:  BTSC    W2.F
026A4:  SETM    W3
026A6:  CALL    1898
....................  
....................          output_high(CS_LTC6811);    
026AA:  BCLR.B  2C0.0
026AC:  BSET.B  2C4.0
....................       } 
026AE:  GOTO    2742
....................       else 
....................       { 
....................          output_low(CS_LTC6811); 
026B2:  BCLR.B  2C0.0
026B4:  BCLR.B  2C4.0
....................          delay_us(10); 
026B6:  REPEAT  #62
026B8:  NOP     
....................          output_high(CS_LTC6811); 
026BA:  BCLR.B  2C0.0
026BC:  BSET.B  2C4.0
....................          delay_us(10); 
026BE:  REPEAT  #62
026C0:  NOP     
....................          output_low(CS_LTC6811); 
026C2:  BCLR.B  2C0.0
026C4:  BCLR.B  2C4.0
....................          spi_xfer(SP, 0x80);   
026C6:  MOV     #8,W4
026C8:  MOV     #80,W2
026CA:  MOV     #0,W3
026CC:  CALL    1898
....................          spi_xfer(SP, 0x01);   
026D0:  MOV     #8,W4
026D2:  MOV     #1,W2
026D4:  MOV     #0,W3
026D6:  CALL    1898
....................          spi_xfer(SP, 0x4D);   
026DA:  MOV     #8,W4
026DC:  MOV     #4D,W2
026DE:  MOV     #0,W3
026E0:  CALL    1898
....................          spi_xfer(SP, 0x7A); 
026E4:  MOV     #8,W4
026E6:  MOV     #7A,W2
026E8:  MOV     #0,W3
026EA:  CALL    1898
....................           
....................          spi_xfer(SP, 0xF8); 
026EE:  MOV     #8,W4
026F0:  MOV     #F8,W2
026F2:  MOV     #0,W3
026F4:  CALL    1898
....................          spi_xfer(SP, 0x00); 
026F8:  MOV     #8,W4
026FA:  MOV     #0,W2
026FC:  MOV     #0,W3
026FE:  CALL    1898
....................          spi_xfer(SP, 0x00); 
02702:  MOV     #8,W4
02704:  MOV     #0,W2
02706:  MOV     #0,W3
02708:  CALL    1898
....................          spi_xfer(SP, 0x00); 
0270C:  MOV     #8,W4
0270E:  MOV     #0,W2
02710:  MOV     #0,W3
02712:  CALL    1898
....................          spi_xfer(SP, 0x00); 
02716:  MOV     #8,W4
02718:  MOV     #0,W2
0271A:  MOV     #0,W3
0271C:  CALL    1898
....................          spi_xfer(SP, 0x00); 
02720:  MOV     #8,W4
02722:  MOV     #0,W2
02724:  MOV     #0,W3
02726:  CALL    1898
....................           
....................          spi_xfer(SP, 0xBE);   
0272A:  MOV     #8,W4
0272C:  MOV     #BE,W2
0272E:  MOV     #0,W3
02730:  CALL    1898
....................          spi_xfer(SP, 0xE2); 
02734:  MOV     #8,W4
02736:  MOV     #E2,W2
02738:  MOV     #0,W3
0273A:  CALL    1898
....................     
....................          output_high(CS_LTC6811);   
0273E:  BCLR.B  2C0.0
02740:  BSET.B  2C4.0
....................       } 
02742:  INC.B   086F
02744:  GOTO    251E
....................    } 
....................     
.................... } 
....................  
.................... #include <LTC1296.c> 
.................... //Library to control the LTC1296 (ALL CHANNELS CONFIGURED AS UNIPOLAR) 
.................... // 
.................... // 
.................... //This library contains the functions to make the temperature ADC conversions 
.................... // 
.................... // 
.................... //It is necessary to define in the main program the SPI configuration with #USE SPI (stream=SP, ...) 
.................... //It is also necessary to define the Chip select pin CS. Example #DEFINE CS_LTC1296 pin_A4 
.................... //It is also necessary to include the stdint library in the main program before this one. Ex: #include <stdint.h> #include <LTC1296.c> 
.................... // 
.................... // 
....................  
.................... void ADC_LTC1296(uint16_t *temp) 
*
01922:  MOV     W5,[W15++]
01924:  CLR.B   86E
01926:  CLR.B   86F
01928:  CLR     872
0192A:  CLR     874
.................... { 
....................     
....................    const int16 Temp_table[901]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900}; 
....................    const int16 Lec[901]={2088,2086,2083,2081,2078,2076,2073,2070,2068,2065,2063,2060,2058,2055,2052,2050,2047,2045,2042,2039,2037,2034,2031,2029,2026,2023,2021,2018,2015,2013,2010,2007,2005,2002,1999,1997,1994,1991,1989,1986,1983,1980,1978,1975,1972,1969,1967,1964,1961,1958,1956,1953,1950,1947,1944,1942,1939,1936,1933,1930,1928,1925,1922,1919,1916,1914,1911,1908,1905,1902,1899,1896,1894,1891,1888,1885,1882,1879,1876,1873,1871,1868,1865,1862,1859,1856,1853,1850,1847,1844,1842,1839,1836,1833,1830,1827,1824,1821,1818,1815,1812,1809,1806,1803,1800,1797,1794,1791,1788,1786,1783,1780,1777,1774,1771,1768,1765,1762,1759,1756,1753,1750,1747,1744,1741,1738,1735,1732,1729,1726,1723,1719,1716,1713,1710,1707,1704,1701,1698,1695,1692,1689,1686,1683,1680,1677,1674,1671,1668,1665,1662,1659,1656,1653,1650,1646,1643,1640,1637,1634,1631,1628,1625,1622,1619,1616,1613,1610,1607,1604,1601,1597,1594,1591,1588,1585,1582,1579,1576,1573,1570,1567,1564,1561,1558,1554,1551,1548,1545,1542,1539,1536,1533,1530,1527,1524,1521,1518,1515,1511,1508,1505,1502,1499,1496,1493,1490,1487,1484,1481,1478,1475,1472,1469,1466,1462,1459,1456,1453,1450,1447,1444,1441,1438,1435,1432,1429,1426,1423,1420,1417,1414,1411,1408,1405,1402,1399,1396,1393,1390,1387,1383,1380,1377,1374,1371,1368,1365,1362,1359,1356,1353,1350,1347,1344,1341,1338,1335,1332,1329,1326,1324,1321,1318,1315,1312,1309,1306,1303,1300,1297,1294,1291,1288,1285,1282,1279,1276,1273,1270,1267,1264,1262,1259,1256,1253,1250,1247,1244,1241,1238,1235,1232,1230,1227,1224,1221,1218,1215,1212,1209,1207,1204,1201,1198,1195,1192,1189,1187,1184,1181,1178,1175,1172,1170,1167,1164,1161,1158,1156,1153,1150,1147,1144,1142,1139,1136,1133,1131,1128,1125,1122,1120,1117,1114,1111,1109,1106,1103,1100,1098,1095,1092,1090,1087,1084,1081,1079,1076,1073,1071,1068,1065,1063,1060,1057,1055,1052,1049,1047,1044,1041,1039,1036,1034,1031,1028,1026,1023,1021,1018,1015,1013,1010,1008,1005,1003,1000,997,995,992,990,987,985,982,980,977,975,972,970,967,965,962,960,957,955,952,950,947,945,942,940,937,935,932,930,928,925,923,920,918,916,913,911,908,906,904,901,899,896,894,892,889,887,885,882,880,878,875,873,871,868,866,864,862,859,857,855,852,850,848,846,843,841,839,837,834,832,830,828,825,823,821,819,817,814,812,810,808,806,804,801,799,797,795,793,791,788,786,784,782,780,778,776,774,772,769,767,765,763,761,759,757,755,753,751,749,747,745,743,741,739,737,735,733,731,729,727,725,723,721,719,717,715,713,711,709,707,705,703,701,699,697,695,694,692,690,688,686,684,682,680,678,677,675,673,671,669,667,666,664,662,660,658,656,655,653,651,649,647,646,644,642,640,638,637,635,633,631,630,628,626,625,623,621,619,618,616,614,613,611,609,607,606,604,602,601,599,597,596,594,592,591,589,588,586,584,583,581,579,578,576,575,573,571,570,568,567,565,564,562,560,559,557,556,554,553,551,550,548,547,545,544,542,541,539,538,536,535,533,532,530,529,527,526,524,523,521,520,519,517,516,514,513,511,510,509,507,506,504,503,502,500,499,497,496,495,493,492,491,489,488,486,485,484,482,481,480,478,477,476,474,473,472,471,469,468,467,465,464,463,462,460,459,458,456,455,454,453,451,450,449,448,446,445,444,443,442,440,439,438,437,436,434,433,432,431,430,428,427,426,425,424,423,421,420,419,418,417,416,414,413,412,411,410,409,408,407,405,404,403,402,401,400,399,398,397,396,395,393,392,391,390,389,388,387,386,385,384,383,382,381,380,379,378,377,376,375,374,373,372,371,370,369,368,367,366,365,364,363,362,361,360,359,358,357,356,355,354,353,352,351,350,349,348,347,346,345,344,343,343,342,341,340,339,338,337,336,335,334,333,333,332,331,330,329,328,327,326,326,325,324,323,322,321,320,319,319,318,317,316,315,314,314,313,312,311,310,309,309,308,307,306,305,305,304,303,302,301,301,300,299,298,297,297,296,295,294,293,293,292,291,290,290,289,288,287,287,286,285,284,284,283,282,281,281,280,279,278,278,277,276,276,275,274,273,273,272,271,271,270,269,268,268,267,266,266,265,264,264,263,262,262,261,260,260,259,258,258,257,256,256,255,254,254,253,252,252,251,250,250,249,249,248,247,247,246,245,245,244,243}; 
....................    int8 v=0, v2=0, a, send; 
....................    int16 value=0, i=0; 
....................     
....................    for(a=0;a<8;a++) 
0192C:  CLR.B   870
0192E:  MOV.B   870,W0L
01930:  SE      W0,W0
01932:  CP      W0,#8
01934:  BRA     GE,19BE
....................    { 
....................       output_low(CS_LTC1296); 
01936:  BCLR.B  2C0.4
01938:  BCLR.B  2C4.4
....................       send=0x18|a; 
0193A:  MOV.B   870,W0L
0193C:  SE      W0,W0
0193E:  IOR      W0,  #18,W0
01940:  MOV.B   W0L,871
....................       spi_xfer (SP, send); 
01942:  MOV.B   871,W0L
01944:  MOV.B   W0L,W2L
01946:  SE      W2,W2
01948:  CLR     W3
0194A:  BTSC    W2.F
0194C:  SETM    W3
0194E:  MOV     #8,W4
01950:  CALL    1898
....................       v=spi_xfer (SP, 0xE0); 
01954:  MOV     #8,W4
01956:  MOV     #E0,W2
01958:  MOV     #0,W3
0195A:  CALL    1898
0195E:  MOV.B   W0L,86E
....................       v2=spi_xfer (SP, 0xFF); 
01960:  MOV     #8,W4
01962:  MOV     #FF,W2
01964:  MOV     #0,W3
01966:  CALL    1898
0196A:  MOV.B   W0L,86F
....................       value=make16(v&0x0F, v2); 
0196C:  MOV.B   86E,W0L
0196E:  SE      W0,W0
01970:  AND     W0,#F,W5
01972:  MOV.B   86F,W0L
01974:  MOV.B   W0L,872
01976:  MOV.B   W5L,W0L
01978:  MOV.B   W0L,873
....................       for(i=1;i<901;i++) 
0197A:  MOV     #1,W4
0197C:  MOV     W4,874
0197E:  MOV     874,W4
01980:  MOV     #385,W3
01982:  CP      W3,W4
01984:  BRA     LE,19B0
....................       { 
....................          if(value<=Lec[i]) temp[a]=temp_table[i]; 
01986:  MOV     874,W4
01988:  MUL.UU  W4,#2,W0
0198A:  CALL    848
0198E:  MOV     872,W4
01990:  CP      W4,W0
01992:  BRA     GT,19AA
01994:  MOV.B   870,W0L
01996:  SE      W0,W0
01998:  MOV     W0,W4
0199A:  MUL.UU  W4,#2,W0
0199C:  MOV     86C,W4
0199E:  ADD     W0,W4,W5
019A0:  MOV     874,W4
019A2:  MUL.UU  W4,#2,W0
019A4:  CALL    376
019A8:  MOV     W0,[W5]
019AA:  INC     0874
019AC:  GOTO    197E
....................       } 
....................       output_high(CS_LTC1296); 
019B0:  BCLR.B  2C0.4
019B2:  BSET.B  2C4.4
....................       delay_us(50); 
019B4:  REPEAT  #1F2
019B6:  NOP     
019B8:  INC.B   0870
019BA:  GOTO    192E
....................        
....................    } 
019BE:  MOV     [--W15],W5
019C0:  RETURN  
....................     
....................     
.................... } 
....................  
.................... #include <can-PIC24.c> 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////                        can-PIC24.c                                     //// 
.................... //// CAN Library routines for Microchip's PIC24 and dsPIC33 line            //// 
.................... ////                                                                        //// 
.................... //// This library provides the following functions:                         //// 
.................... ////  (for more information on these functions see the comment              //// 
.................... ////   header above each function)                                          //// 
.................... ////                                                                        //// 
.................... ////  can_init - Configures the PIC24 CAN1 peripheral                       //// 
.................... ////  can2_init - Configures the PIC24 CAN2 peripheral                      //// 
.................... ////                                                                        //// 
.................... ////  can_set_baud - Sets the baud rate control registers for CAN1          //// 
.................... ////  can2_set_baud - Sets the baud rate control registers for CAN2         //// 
.................... ////                                                                        //// 
.................... ////  can_set_mode - Sets the CAN1 module into a specific mode              //// 
.................... ////  can2_set_mode - Sets the CAN2 module into a specific mode             ////  
.................... ////                                                                        //// 
.................... ////  can_set_id - Sets the standard and extended ID of filters and         //// 
.................... ////     masks for CAN1                                                     //// 
.................... ////  can2_set_id - Sets the standard and extended ID of filters and        //// 
.................... ////     masks for CAN2                                                     //// 
.................... ////                                                                        //// 
.................... ////  can_set_buffer_id Sets the standard and extended ID of specified      //// 
.................... ////     buffer for CAN1                                                    //// 
.................... ////  can2_set_buffer_id Sets the standard and extended ID of specified     //// 
.................... ////     buffer for CAN2                                                    //// 
.................... ////                                                                        //// 
.................... ////  can_set_buffer_size() Sets the DMA buffer size that CAN1 uses         //// 
.................... ////  can2_set_buffer_size() Sets the DMA buffer size that CAN2 uses        //// 
.................... ////                                                                        //// 
.................... ////  can_get_id - Gets the standard and extended ID for CAN1               //// 
.................... ////  can2_get_id - Gets the standard and extended ID for CAN2              //// 
.................... ////                                                                        //// 
.................... ////  can_putd - Sends a message/request with specified ID for CAN1         //// 
.................... ////  can2_putd - Sends a message/request with specified ID for CAN2        //// 
.................... ////                                                                        //// 
.................... ////  can_getd - Returns specified message/request and ID for CAN1          //// 
.................... ////  can2_getd - Returns specified message/request and ID for CAN2         //// 
.................... ////                                                                        //// 
.................... ////  can_kbhit - Returns true if there is data in one of the receive       //// 
.................... ////     buffers for CAN1                                                   //// 
.................... ////  can2_kbhit - Returns true if there is data in one of the receive      //// 
.................... ////     buffers for CAN2                                                   //// 
.................... ////                                                                        //// 
.................... ////  can_tbe - Returns true if the transmit buffer is ready to send        //// 
.................... ////     more data for CAN1                                                 //// 
.................... ////  can2_tbe - Returns true if the transmit buffer is ready to send       //// 
.................... ////     more data for CAN2                                                 //// 
.................... ////                                                                        //// 
.................... ////  can_abort - Aborts all pending transmissions for CAN1                 //// 
.................... ////  can2_abort - Aborts all pending transmissions for CAN2                //// 
.................... ////                                                                        //// 
.................... ////  can_enable_b_transfer - enables buffer as transmitter for CAN1        //// 
.................... ////  can2_enable_b_transfer - enables buffer as transmitter for CAN2       //// 
.................... ////                                                                        //// 
.................... ////  can_enable_b_receiver - enables buffer as receiver for CAN1           //// 
.................... ////  can2_enable_b_receiver - enables buffer as receiver for CAN2          //// 
.................... ////                                                                        //// 
.................... ////  can_enable_rtr - enables transmit buffer as Auto-rtr for CAN1         //// 
.................... ////  can2_enable_rtr - enables transmit buffer as Auto-rtr for CAN2        //// 
.................... ////                                                                        //// 
.................... ////  can_disable_rtr - disables transmit buffer as Auto-rtr for CAN1       //// 
.................... ////  can2_disable_rtr - disables transmit buffer as Auto-rtr for CAN2      //// 
.................... ////                                                                        //// 
.................... ////  can_load_rtr - loads an Auto-rtr buffer with data for CAN1            //// 
.................... ////  can2_load_rtr - loads an Auto-rtr buffer with data for CAN2           //// 
.................... ////                                                                        //// 
.................... ////  can_enable_filter - enables one of 15 filters for CAN1                //// 
.................... ////  can2_enable_filter - enables one of 15 filters for CAN2               //// 
.................... ////                                                                        //// 
.................... ////  can_disable_filter - disables one of the 15 filters for CAN1          //// 
.................... ////  can2_disable_filter - disables one of the 15 filters for CAN2         //// 
.................... ////                                                                        //// 
.................... ////  can_associate_filter_to_buffer - associates a filter with a           //// 
.................... ////     buffer for CAN1                                                    //// 
.................... ////  can2_associate_filter_to_buffer - associates a filter with a          //// 
.................... ////     buffer for CAN2                                                    //// 
.................... ////                                                                        //// 
.................... ////  can_associate_filter_to_mask - associates a filter with a mask        //// 
.................... ////     for CAN1                                                           //// 
.................... ////  can2_associate_filter_to_mask - associates a filter with a mask       //// 
.................... ////     for CAN2                                                           //// 
.................... ////                                                                        //// 
.................... ////  can_fifo_getd - retrieve data in FIFO mode for CAN1                   //// 
.................... ////  can2_fifo_getd - retrieve data in FIFO mode for CAN2                  //// 
.................... ////                                                                        //// 
.................... ////  can_trb0_putd                                                         //// 
.................... ////  can_trb1_putd                                                         //// 
.................... ////  can_trb2_putd                                                         //// 
.................... ////  can_trb3_putd                                                         //// 
.................... ////  can_trb4_putd                                                         //// 
.................... ////  can_trb5_putd                                                         //// 
.................... ////  can_trb6_putd                                                         //// 
.................... ////  can_trb7_putd - place data in a specific buffer for CAN1              //// 
.................... ////  can2_trb0_putd                                                        //// 
.................... ////  can2_trb1_putd                                                        //// 
.................... ////  can2_trb2_putd                                                        //// 
.................... ////  can2_trb3_putd                                                        //// 
.................... ////  can2_trb4_putd                                                        //// 
.................... ////  can2_trb5_putd                                                        //// 
.................... ////  can2_trb6_putd                                                        //// 
.................... ////  can2_trb7_putd - place data in a specific buffer for CAN2             //// 
.................... ////                                                                        //// 
.................... ////  can_enable_interrupts - enables specified interrupts for #INT_CAN1    //// 
.................... ////  can2_enable_interrupts - enables specified interrupts for #INT_CAN2   //// 
.................... ////                                                                        //// 
.................... ////  can_disable_interrupts - disables specified interrupts for #INT_CAN1  //// 
.................... ////  can2_disable_interrupts - disables specified interrupts for #INT_CAN2 //// 
.................... ////                                                                        //// 
.................... ////  can_config_DMA - configures DMA buffers for CAN1                      //// 
.................... ////  can2_config_DMA - configures DMA buffers for CAN2                     //// 
.................... ////                                                                        //// 
.................... //// PIN_F0 is C1RX, PIN_F1 is C1TX, PIN_G0 is C2RX and PIN_G1 is C2TX. You //// 
.................... //// will need a CAN transceiver to connect these pins to CANH and CANL bus //// 
.................... //// lines.                                                                 //// 
.................... ////                                                                        //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services                //// 
.................... //// This source code may only be used by licensed users of the CCS         //// 
.................... //// C compiler.  This source code may only be distributed to other         //// 
.................... //// licensed users of the CCS C compiler.  No other use,                   //// 
.................... //// reproduction or distribution is permitted without written              //// 
.................... //// permission.  Derivative programs created using this software           //// 
.................... //// in object code form are not restricted in any way.                     //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <can-PIC24.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-PIC24.h                              //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC24HJ and dsPIC33FJ.                  //// 
.................... ////                                                                 //// 
.................... //// (see can-PIC24.c)                                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN24HJ_LIB_DEFINES__ 
.................... #define __CCS_CAN24HJ_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #ifndef CAN_BUFFER_SIZE 
....................    #define CAN_BUFFER_SIZE 32 
.................... #endif 
....................  
.................... #ifndef CAN2_BUFFER_SIZE 
....................    #define CAN2_BUFFER_SIZE 32 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN2_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN2_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/(Fosc/2) ) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN2_BRG_PRESCALAR 
....................   #define CAN2_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/(Fosc/2) ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_SEG_2_PHASE_TS 
....................  #define CAN2_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_SAM 
....................  #define CAN2_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_PHASE_SEGMENT_1 
....................  #define CAN2_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_PROPAGATION_TIME 
....................  #define CAN2_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_WAKE_FILTER 
....................  #define CAN2_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN2_BRG_PHASE_SEGMENT_2 
....................  #define CAN2_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_CANCKS 
....................  #define CAN_CANCKS 1         //For PIC24EP and dsPIC33EP chips this bit seems 
.................... #endif                        //to be backwards from what the datasheet says 
....................                               //(1 sets FCCAN = FOSC/2 and 0 sets FCCAN = FOSC). 
....................                               //Bit not used for PIC24HJ and dsPIC33FJ chip 
....................                               //(FCCAN = FOSC/2). 
....................                                
.................... #ifndef CAN2_CANCKS 
....................  #define CAN2_CANCKS 1 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////// ECAN Control Registers //////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_OP_MODE {   CAN_OP_LISTEN_ALL=7, 
....................                      CAN_OP_CONFIG=4, 
....................                      CAN_OP_LISTEN=3, 
....................                      CAN_OP_LOOPBACK=2, 
....................                      CAN_OP_DISABLE=1, 
....................                      CAN_OP_NORMAL=0 }; 
....................                       
.................... // ECAN Control Register 1                      
.................... struct CiCTRL1_struct { 
....................    int1 win;               //0      //SFR map window select bit 
....................    int void21:2;           //1:2     
....................    int1 cancap;            //3      //CAN message receive timer capture event enable bit 
....................    int1 void4;             //4 
....................    CAN_OP_MODE opmode:3;   //5:7    //Operation mode bits 
....................    CAN_OP_MODE reqop:3;    //8:10   //Request operation mode bits 
....................    int1 cancks;            //11     //CAN master clock select bit 
....................    int1 abat;              //12     //Abort all pending transmissions bit 
....................    int1 csidl;             //13     //Stop in idle mode bit 
....................    int void15_14:2;        //14:15 
.................... }; 
....................  
.................... struct CiCTRL1_struct C1CTRL1; 
.................... #word C1CTRL1=getenv("SFR:C1CTRL1") 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    struct CiCTRL1_struct C2CTRL1; 
....................    #word C2CTRL1=getenv("SFR:C2CTRL1") 
.................... #endif 
....................  
.................... // ECAN Control Register 2 
.................... struct CiCTRL2_struct { 
....................    int dncnt:5;            //0:4    //DeviceNet filter bit number bits 
....................    int void15_5:11;        //5:15 
.................... }; 
....................  
.................... struct CiCTRL2_struct C1CTRL2; 
.................... #word C1CTRL2=getenv("SFR:C1CTRL2") 
....................  
.................... #if getenv("SFR_VALID:C2CTRL2") 
....................    struct CiCTRL2_struct C2CTRL2; 
....................    #word C2CTRL2=getenv("SFR:C2CTRL2") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Baud Control Registers ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // ECAN Baud Configuration Register 1 
.................... struct CiCFG1_struct { 
....................    int brp:6;              //0:5    //Baud Rate Prescalar bits 
....................    int sjw:2;              //6:7    //Synchronization jump width bits 
....................    int void15_8:8;         //8:15 
.................... }; 
....................  
.................... struct CiCFG1_struct C1CFG1; 
.................... #word C1CFG1=getenv("SFR:C1CFG1") 
....................  
.................... #if getenv("SFR_VALID:C2CFG1") 
....................    struct CiCFG1_struct C2CFG1; 
....................    #word C2CFG1=getenv("SFR:C2CFG1") 
.................... #endif 
....................  
.................... //ECAN Baud Configuration Register 2 
.................... struct CiCFG2_struct { 
....................    int prseg:3;            //0:2    //Propagation time segment bits 
....................    int seg1ph:3;           //3:5    //Phase segment 1 bits 
....................    int1 sam;               //6      //Sample of the CAN bus line bit 
....................    int1 seg2phts;          //7      //Phase segment 2 time select bit 
....................    int seg2ph:3;           //8:10   //Phase segment 2 bits 
....................    int void13_11:3;        //11:13 
....................    int1 wakfil;            //14       //Select CAN bus line filter for wake-up bit 
....................    int1 void15;            //15 
.................... }; 
....................  
.................... struct CiCFG2_struct C1CFG2; 
.................... #word C1CFG2=getenv("SFR:C1CFG2") 
....................  
.................... #if getenv("SFR_VALID:C2CFG2") 
....................    struct CiCFG2_struct C2CFG2; 
....................    #word C2CFG2=getenv("SFR:C2CFG2") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //ECAN Transmit/Receive Error Count Register 
.................... struct CiEC_struct { 
....................    uint8_t rerrcnt;        //0:7    //Receive error count bits 
....................    uint8_t terrcnt;        //8:15   //Transmit error count bits 
.................... }; 
....................  
.................... struct CiEC_struct C1EC; 
.................... #word C1EC=getenv("SFR:C1EC") 
....................  
.................... #if getenv("SFR_VALID:C2EC") 
....................    struct CiEC_struct C2EC; 
....................    #word C2EC=getenv("SFR:C2EC") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_FILTER_CONTROL { FLTEN0=0x0001, FLTEN1=0x0002, FLTEN2=0x0004, FLTEN3=0x0008, 
....................                           FLTEN4=0x0010, FLTEN5=0x0020, FLTEN6=0x0040, FLTEN7=0x0080, 
....................                           FLTEN8=0x0100, FLTEN9=0x0200, FLTEN10=0x0400, FLTEN11=0x0800, 
....................                           FLTEN12=0x1000, FLTEN13=0x2000, FLTEN14=0x4000, FLTEN15=0x8000}; 
....................  
.................... //ECAN Acceptance Filter Enable register 
.................... #word C1FEN1=getenv("SFR:C1FEN1") 
....................  
.................... #if getenv("SFR_VALID:C2FEN1") 
....................    #word C2FEN1=getenv("SFR:C2FEN1") 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_FILTER_ASSOCIATION { F0BP=0x00, F1BP=0x01, F2BP=0x02, F3BP=0x03, F4BP=0x04, 
....................                               F5BP=0x05, F6BP=0x06, F7BP=0x07, F8BP=0x08, F9BP=0x09, 
....................                               F10BP=0x0A,F11BP=0x0B,F12BP=0x0C,F13BP=0x0D,F14BP=0x0E, 
....................                               F15BP=0x0F}; 
....................                                
.................... enum CAN_FILTER_ASSOCIATION_BUFFERS { ATRB0=0x00, ATRB1=0x01, ATRB2=0x02, ATRB3=0x03, ATRB4=0x04, 
....................                                       ATRB5=0x05, ATRB6=0x06, ATRB7=0x07, ARB8=0x08, ARB9=0x09, 
....................                                       ARB10=0x0A, ARB11=0x0B, ARB12=0x0C, ARB13=0x0D, ARB14=0x0E, 
....................                                       AFIFO=0x0F}; 
....................  
.................... //ECAN Filter 0-3 Buffer Pointer Register 
.................... struct CiBUFPNT1_struct { 
....................    int f0bp:4;             //0:3    //RX Buffer mask for Filter 0 
....................    int f1bp:4;             //4:7    //RX Buffer mask for Filter 1 
....................    int f2bp:4;             //8:11   //RX Buffer mask for Filter 2 
....................    int f3bp:4;             //12:15  //RX Buffer mask for Filter 3 
.................... }; 
....................  
.................... struct CiBUFPNT1_struct C1BUFPNT1; 
.................... #word C1BUFPNT1=getenv("SFR:C1BUFPNT1") 
....................  
.................... #if getenv("SFR_VALID:C2BUFPNT1") 
....................    struct CiBUFPNT1_struct C2BUFPNT1; 
....................    #word C2BUFPNT1=getenv("SFR:C2BUFPNT1") 
.................... #endif 
....................  
.................... //ECAN Filter 4-7 Buffer Pointer Register 
.................... struct CiBUFPNT2_struct { 
....................    int f4bp:4;             //0:3    //RX Buffer mask for Filter 4 
....................    int f5bp:4;             //4:7    //RX Buffer mask for Filter 5 
....................    int f6bp:4;             //8:11   //RX Buffer mask for Filter 6 
....................    int f7bp:4;             //12:15  //RX Buffer mask for Filter 7 
.................... }; 
....................  
.................... struct CiBUFPNT2_struct C1BUFPNT2; 
.................... #word C1BUFPNT2=getenv("SFR:C1BUFPNT2") 
....................  
.................... #if getenv("SFR_VALID:C2BUFPNT2") 
....................    struct CiBUFPNT2_struct C2BUFPNT2; 
....................    #word C2BUFPNT2=getenv("SFR:C2BUFPNT2") 
.................... #endif 
....................  
.................... //ECAN Filter 8-11 Buffer Pointer Register 
.................... struct CiBUFPNT3_struct { 
....................    int f8bp:4;             //0:3    //RX Buffer mask for Filter 8 
....................    int f9bp:4;             //4:7    //RX Buffer mask for Filter 9 
....................    int f10bp:4;            //8:11   //RX Buffer mask for Filter 10 
....................    int f11bp:4;            //12:15  //RX Buffer mask for Filter 11 
.................... }; 
....................  
.................... struct CiBUFPNT3_struct C1BUFPNT3; 
.................... #word C1BUFPNT3=getenv("SFR:C1BUFPNT3") 
....................  
.................... #if getenv("SFR_VALID:C2BUFPNT3") 
....................    struct CiBUFPNT3_struct C2BUFPNT3; 
....................    #word C2BUFPNT3=getenv("SFR:C2BUFPNT3") 
.................... #endif 
....................  
.................... //ECAN Filter 12-15 Buffer Pointer Register 
.................... struct CiBUFPNT4_struct { 
....................    int f12bp:4;            //0:3    //RX Buffer mask for Filter 12 
....................    int f13bp:4;            //4:7    //RX Buffer mask for Filter 13 
....................    int f14bp:4;            //8:11   //RX Buffer mask for Filter 14 
....................    int f15bp:4;            //12:15  //RX Buffer mask for Filter 15 
.................... }; 
....................  
.................... struct CiBUFPNT4_struct C1BUFPNT4; 
.................... #word C1BUFPNT4=getenv("SFR:C1BUFPNT4") 
....................  
.................... #if getenv("SFR_VALID:C2BUFPNT4") 
....................    struct CiBUFPNT4_struct C2BUFPNT4; 
....................    #word C2BUFPNT4=getenv("SFR:C2BUFPNT4") 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //ECAN Acceptance Filter Standard Identifier Register 
.................... #word C1RXF0SID=getenv("SFR:C1RXF0SID") 
.................... #word C1RXF1SID=getenv("SFR:C1RXF1SID") 
.................... #word C1RXF2SID=getenv("SFR:C1RXF2SID") 
.................... #word C1RXF3SID=getenv("SFR:C1RXF3SID") 
.................... #word C1RXF4SID=getenv("SFR:C1RXF4SID") 
.................... #word C1RXF5SID=getenv("SFR:C1RXF5SID") 
.................... #word C1RXF6SID=getenv("SFR:C1RXF6SID") 
.................... #word C1RXF7SID=getenv("SFR:C1RXF7SID") 
.................... #word C1RXF8SID=getenv("SFR:C1RXF8SID") 
.................... #word C1RXF9SID=getenv("SFR:C1RXF9SID") 
.................... #word C1RXF10SID=getenv("SFR:C1RXF10SID") 
.................... #word C1RXF11SID=getenv("SFR:C1RXF11SID") 
.................... #word C1RXF12SID=getenv("SFR:C1RXF12SID") 
.................... #word C1RXF13SID=getenv("SFR:C1RXF13SID") 
.................... #word C1RXF14SID=getenv("SFR:C1RXF14SID") 
.................... #word C1RXF15SID=getenv("SFR:C1RXF15SID") 
....................  
.................... #if getenv("SFR_VALID:C2RXF0SID") 
....................    #word C2RXF0SID=getenv("SFR:C2RXF0SID") 
....................    #word C2RXF1SID=getenv("SFR:C2RXF1SID") 
....................    #word C2RXF2SID=getenv("SFR:C2RXF2SID") 
....................    #word C2RXF3SID=getenv("SFR:C2RXF3SID") 
....................    #word C2RXF4SID=getenv("SFR:C2RXF4SID") 
....................    #word C2RXF5SID=getenv("SFR:C2RXF5SID") 
....................    #word C2RXF6SID=getenv("SFR:C2RXF6SID") 
....................    #word C2RXF7SID=getenv("SFR:C2RXF7SID") 
....................    #word C2RXF8SID=getenv("SFR:C2RXF8SID") 
....................    #word C2RXF9SID=getenv("SFR:C2RXF9SID") 
....................    #word C2RXF10SID=getenv("SFR:C2RXF10SID") 
....................    #word C2RXF11SID=getenv("SFR:C2RXF11SID") 
....................    #word C2RXF12SID=getenv("SFR:C2RXF12SID") 
....................    #word C2RXF13SID=getenv("SFR:C2RXF13SID") 
....................    #word C2RXF14SID=getenv("SFR:C2RXF14SID") 
....................    #word C2RXF15SID=getenv("SFR:C2RXF15SID") 
.................... #endif 
....................  
.................... //ECAN Acceptance Filter Extended Identifier Register 
.................... #word C1RXF0=getenv("SFR:C1RXF0EID") 
.................... #word C1RXF1=getenv("SFR:C1RXF1EID") 
.................... #word C1RXF2=getenv("SFR:C1RXF2EID") 
.................... #word C1RXF3=getenv("SFR:C1RXF3EID") 
.................... #word C1RXF4=getenv("SFR:C1RXF4EID") 
.................... #word C1RXF5=getenv("SFR:C1RXF5EID") 
.................... #word C1RXF6=getenv("SFR:C1RXF6EID") 
.................... #word C1RXF7=getenv("SFR:C1RXF7EID") 
.................... #word C1RXF8=getenv("SFR:C1RXF8EID") 
.................... #word C1RXF9=getenv("SFR:C1RXF9EID") 
.................... #word C1RXF10=getenv("SFR:C1RXF10EID") 
.................... #word C1RXF11=getenv("SFR:C1RXF11EID") 
.................... #word C1RXF12=getenv("SFR:C1RXF12EID") 
.................... #word C1RXF13=getenv("SFR:C1RXF13EID") 
.................... #word C1RXF14=getenv("SFR:C1RXF14EID") 
.................... #word C1RXF15=getenv("SFR:C1RXF15EID") 
....................  
.................... #if getenv("SFR_VALID:C2RXF0EID") 
....................    #word C2RXF0=getenv("SFR:C2RXF0EID") 
....................    #word C2RXF1=getenv("SFR:C2RXF1EID") 
....................    #word C2RXF2=getenv("SFR:C2RXF2EID") 
....................    #word C2RXF3=getenv("SFR:C2RXF3EID") 
....................    #word C2RXF4=getenv("SFR:C2RXF4EID") 
....................    #word C2RXF5=getenv("SFR:C2RXF5EID") 
....................    #word C2RXF6=getenv("SFR:C2RXF6EID") 
....................    #word C2RXF7=getenv("SFR:C2RXF7EID") 
....................    #word C2RXF8=getenv("SFR:C2RXF8EID") 
....................    #word C2RXF9=getenv("SFR:C2RXF9EID") 
....................    #word C2RXF10=getenv("SFR:C2RXF10EID") 
....................    #word C2RXF11=getenv("SFR:C2RXF11EID") 
....................    #word C2RXF12=getenv("SFR:C2RXF12EID") 
....................    #word C2RXF13=getenv("SFR:C2RXF13EID") 
....................    #word C2RXF14=getenv("SFR:C2RXF14EID") 
....................    #word C2RXF15=getenv("SFR:C2RXF15EID") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_MASK_FILTER_ASSOCIATION { ACCEPTANCE_MASK_0=0, ACCEPTANCE_MASK_1=1, 
....................                                    ACCEPTANCE_MASK_2=2, NO_MASK=3}; 
....................  
.................... // ECAN Filter 7-0 Mask Selection Register 
.................... struct CiFMSKSEL1_struct { 
....................    int f0msk:2;            //0:1    // Mask Source for Filter 0 bits 
....................    int f1msk:2;            //2:3    // Mask Source for Filter 1 bits 
....................    int f2msk:2;            //4:5    // Mask Source for Filter 2 bits 
....................    int f3msk:2;            //6:7    // Mask Source for Filter 3 bits 
....................    int f4msk:2;            //8:9    // Mask Source for Filter 4 bits 
....................    int f5msk:2;            //10:11  // Mask Source for Filter 5 bits 
....................    int f6msk:2;            //12:13  // Mask Source for Filter 6 bits 
....................    int f7msk:2;            //14:15  // Mask Source for Filter 7 bits 
.................... }; 
....................  
.................... struct CiFMSKSEL1_struct C1FMSKSEL1; 
.................... #word C1FMSKSEL1=getenv("SFR:C1FMSKSEL1") 
....................  
.................... #if getenv("SFR_VALID:C2FMSKSEL1") 
....................    struct CiFMSKSEL1_struct C2FMSKSEL1; 
....................    #word C2FMSKSEL1=getenv("SFR:C2FMSKSEL1") 
.................... #endif 
....................  
.................... // ECAN Filter 15-8 Mask Selection Register 
.................... struct CiFMSKSEL2_struct { 
....................    int f8msk:2;            //0:1    // Mask Source for Filter 8 bits 
....................    int f9msk:2;            //2:3    // Mask Source for Filter 9 bits 
....................    int f10msk:2;           //4:5    // Mask Source for Filter 10 bits 
....................    int f11msk:2;           //6:7    // Mask Source for Filter 11 bits 
....................    int f12msk:2;           //8:9    // Mask Source for Filter 12 bits 
....................    int f13msk:2;           //10:11  // Mask Source for Filter 13 bits 
....................    int f14msk:2;           //12:13  // Mask Source for Filter 14 bits 
....................    int f15msk:2;           //14:15  // Mask Source for Filter 15 bits 
.................... }; 
....................  
.................... struct CiFMSKSEL2_struct C1FMSKSEL2; 
.................... #word C1FMSKSEL2=getenv("SFR:C1FMSKSEL2") 
....................  
.................... #if getenv("SFR_VALID:C2FMSKSEL2") 
....................    struct CiFMSKSEL2_struct C2FMSKSEL2; 
....................    #word C2FMSKSEL2=getenv("SFR:C2FMSKSEL2") 
.................... #endif 
....................  
.................... // ECAN Acceptance Filter Mask Standard Identifier Register 
.................... #word C1RXM0SID=getenv("SFR:C1RXM0SID") 
.................... #word C1RXM1SID=getenv("SFR:C1RXM1SID") 
.................... #word C1RXM2SID=getenv("SFR:C1RXM2SID") 
....................  
.................... #if getenv("SFR_VALID:C2RXM0SID") 
....................    #word C2RXM0SID=getenv("SFR:C2RXM0SID") 
....................    #word C2RXM1SID=getenv("SFR:C2RXM1SID") 
....................    #word C2RXM2SID=getenv("SFR:C2RXM2SID") 
.................... #endif 
....................  
.................... // ECAN Acceptance Filter Mask Extended Identifier Register 
.................... #word C1RXM0=getenv("SFR:C1RXM0EID") 
.................... #word C1RXM1=getenv("SFR:C1RXM1EID") 
.................... #word C1RXM2=getenv("SFR:C1RXM1EID") 
....................  
.................... #if getenv("SFR_VALID:C2RXM0EID") 
....................    #word C2RXM0=getenv("SFR:C2RXM0EID") 
....................    #word C2RXM1=getenv("SFR:C2RXM1EID") 
....................    #word C2RXM2=getenv("SFR:C2RXM2EID") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum BUFFER { TRB0=0, TRB1=1, TRB2=2, TRB3=3, TRB4=4, TRB5=5, TRB6=6, TRB7=7, RB8=8, 
....................               RB9=9, RB10=10, RB11=11, RB12=12, RB13=13, RB14=14, RB15=15, RB16=16, 
....................               RB17=17, RB18=18, RB19=19, RB20=20, RB21=21, RB22=22, RB23=23, RB24=24, 
....................               RB25=25, RB26=26, RB27=27, RB28=28, RB29=29, RB30=30, RB31=31}; 
....................  
.................... // ECAN Receive Buffer Full Register 1 
.................... struct CiRXFUL1_struct { 
....................    int1 rxful0;            //0      //receive buffer 0 full bit 
....................    int1 rxful1;            //1      //receive buffer 1 full bit 
....................    int1 rxful2;            //2      //receive buffer 2 full bit 
....................    int1 rxful3;            //3      //receive buffer 3 full bit 
....................    int1 rxful4;            //4      //receive buffer 4 full bit 
....................    int1 rxful5;            //5      //receive buffer 5 full bit 
....................    int1 rxful6;            //6      //receive buffer 6 full bit 
....................    int1 rxful7;            //7      //receive buffer 7 full bit 
....................    int1 rxful8;            //8      //receive buffer 8 full bit 
....................    int1 rxful9;            //9      //receive buffer 9 full bit 
....................    int1 rxful10;           //10     //receive buffer 10 full bit 
....................    int1 rxful11;           //11     //receive buffer 11 full bit 
....................    int1 rxful12;           //12     //receive buffer 12 full bit 
....................    int1 rxful13;           //13     //receive buffer 13 full bit 
....................    int1 rxful14;           //14     //receive buffer 14 full bit 
....................    int1 rxful15;           //15     //receive buffer 15 full bit 
.................... }; 
....................  
.................... struct CiRXFUL1_struct C1RXFUL1;    
.................... #word C1RXFUL1=getenv("SFR:C1RXFUL1") 
....................  
.................... #if getenv("SFR_VALID:C2RXFUL1") 
....................    struct CiRXFUL1_struct C2RXFUL1; 
....................    #word C2RXFUL1=getenv("SFR:C2RXFUL1") 
.................... #endif 
....................  
.................... // ECAN Receive Buffer Full Register 2 
.................... struct CiRXFUL2_struct { 
....................    int1 rxful16;           //0      //receive buffer 16 full bit 
....................    int1 rxful17;           //1      //receive buffer 17 full bit 
....................    int1 rxful18;           //2      //receive buffer 18 full bit 
....................    int1 rxful19;           //3      //receive buffer 19 full bit 
....................    int1 rxful20;           //4      //receive buffer 20 full bit 
....................    int1 rxful21;           //5      //receive buffer 21 full bit 
....................    int1 rxful22;           //6      //receive buffer 22 full bit 
....................    int1 rxful23;           //7      //receive buffer 23 full bit 
....................    int1 rxful24;           //8      //receive buffer 24 full bit 
....................    int1 rxful25;           //9      //receive buffer 25 full bit 
....................    int1 rxful26;           //10     //receive buffer 26 full bit 
....................    int1 rxful27;           //11     //receive buffer 27 full bit 
....................    int1 rxful28;           //12     //receive buffer 28 full bit 
....................    int1 rxful29;           //13     //receive buffer 29 full bit 
....................    int1 rxful30;           //14     //receive buffer 30 full bit 
....................    int1 rxful31;           //15     //receive buffer 31 full bit 
.................... }; 
....................  
.................... struct CiRXFUL2_struct C1RXFUL2; 
.................... #word C1RXFUL2=getenv("SFR:C1RXFUL2") 
....................  
.................... #if getenv("SFR_VALID:C2RXFUL2") 
....................    struct CiRXFUL2_struct C2RXFUL2; 
....................    #word C2RXFUL2=getenv("SFR:C2RXFUL2") 
.................... #endif 
....................  
.................... // ECAN Receive Buffer Overflow Register 1 
.................... struct CiRXOVF1_struct { 
....................    int1 rxovf0;            //0      //receive buffer 0 overflow bit 
....................    int1 rxovf1;            //1      //receive buffer 1 overflow bit 
....................    int1 rxovf2;            //2      //receive buffer 2 overflow bit 
....................    int1 rxovf3;            //3      //receive buffer 3 overflow bit 
....................    int1 rxovf4;            //4      //receive buffer 4 overflow bit 
....................    int1 rxovf5;            //5      //receive buffer 5 overflow bit 
....................    int1 rxovf6;            //6      //receive buffer 6 overflow bit 
....................    int1 rxovf7;            //7      //receive buffer 7 overflow bit 
....................    int1 rxovf8;            //8      //receive buffer 8 overflow bit 
....................    int1 rxovf9;            //9      //receive buffer 9 overflow bit 
....................    int1 rxovf10;           //10     //receive buffer 10 overflow bit 
....................    int1 rxovf11;           //11     //receive buffer 11 overflow bit 
....................    int1 rxovf12;           //12     //receive buffer 12 overflow bit 
....................    int1 rxovf13;           //13     //receive buffer 13 overflow bit 
....................    int1 rxovf14;           //14     //receive buffer 14 overflow bit 
....................    int1 rxovf15;           //15     //receive buffer 15 overflow bit 
.................... }; 
....................  
.................... struct CiRXOVF1_struct C1RXOVF1; 
.................... #word C1RXOVF1=getenv("SFR:C1RXOVF1") 
....................  
.................... #if getenv("SFR_VALID:C2RXOVF1") 
....................    struct CiRXOVF1_struct C2RXOVF1; 
....................    #word C2RXOVF1=getenv("SFR:C2RXOVF1") 
.................... #endif 
....................  
.................... // ECAN Receive Buffer Overflow Register 2 
.................... struct CiRXOVF2_struct { 
....................    int1 rxovf16;           //0      //receive buffer 16 overflow bit 
....................    int1 rxovf17;           //1      //receive buffer 17 overflow bit 
....................    int1 rxovf18;           //2      //receive buffer 18 overflow bit 
....................    int1 rxovf19;           //3      //receive buffer 19 overflow bit 
....................    int1 rxovf20;           //4      //receive buffer 20 overflow bit 
....................    int1 rxovf21;           //5      //receive buffer 21 overflow bit 
....................    int1 rxovf22;           //6      //receive buffer 22 overflow bit 
....................    int1 rxovf23;           //7      //receive buffer 23 overflow bit 
....................    int1 rxovf24;           //8      //receive buffer 24 overflow bit 
....................    int1 rxovf25;           //9      //receive buffer 25 overflow bit 
....................    int1 rxovf26;           //10     //receive buffer 26 overflow bit 
....................    int1 rxovf27;           //11     //receive buffer 27 overflow bit 
....................    int1 rxovf28;           //12     //receive buffer 28 overflow bit 
....................    int1 rxovf29;           //13     //receive buffer 29 overflow bit 
....................    int1 rxovf30;           //14     //receive buffer 30 overflow bit 
....................    int1 rxovf31;           //15     //receive buffer 31 overflow bit 
.................... }; 
....................  
.................... struct CiRXOVF2_struct C1RXOVF2; 
.................... #word C1RXOVF2=getenv("SFR:C1RXOVF2") 
....................  
.................... #if getenv("SFR_VALID:C2RXOVF2") 
....................    struct CiRXOVF2_struct C2RXOVF2; 
....................    #word C2RXOVF2=getenv("SFR:C2RXOVF2") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // ECAN Tx/Rx Buffer m Control Register 
.................... struct CiTRmnCON_struct { 
....................    int txmpri:2;           //0:1    // Message Transmission Priority bits 
....................    int1 rtrenm;            //2      // Auto-Remote Transmit Enable bit 
....................    int1 txreqm;            //3      // Message Send Request bit 
....................    int1 txerrm;            //4      // Error Detected During Transmission bit 
....................    int1 txlarbm;           //5      // Message Lost Arbitration bit 
....................    int1 txabtm;            //6      // Message Aborted bit 
....................    int1 txenm;             //7      // Tx/Rx Buffer Selection bit 
....................    int txnpri:2;           //8:9    // Message Transmission Priority bits 
....................    int1 rtrenn;            //10     // Auto-Remote Transmit Enable bit 
....................    int1 txreqn;            //11     // Message Send Request bit 
....................    int1 txerrn;            //12     // Error Detected During Transmission bit 
....................    int1 txlarbn;           //13     // Message Lost Arbitration bit 
....................    int1 txabtn;            //14     // Message Aborted bit 
....................    int1 txenn;             //15     // Tx/Rx Buffer Selection bit 
.................... }; 
....................  
.................... struct CiTRmnCON_struct C1TR01CON; 
.................... struct CiTRmnCON_struct C1TR23CON; 
.................... struct CiTRmnCON_struct C1TR45CON; 
.................... struct CiTRmnCON_struct C1TR67CON; 
.................... #word C1TR01CON=getenv("SFR:C1TR01CON") 
.................... #word C1TR23CON=getenv("SFR:C1TR23CON") 
.................... #word C1TR45CON=getenv("SFR:C1TR45CON") 
.................... #word C1TR67CON=getenv("SFR:C1TR67CON") 
....................  
.................... #if getenv("SFR_VALID:C2TR01CON") 
....................    struct CiTRmnCON_struct C2TR01CON; 
....................    struct CiTRmnCON_struct C2TR23CON; 
....................    struct CiTRmnCON_struct C2TR45CON; 
....................    struct CiTRmnCON_struct C2TR67CON; 
....................    #word C2TR01CON=getenv("SFR:C2TR01CON") 
....................    #word C2TR23CON=getenv("SFR:C2TR23CON") 
....................    #word C2TR45CON=getenv("SFR:C2TR45CON") 
....................    #word C2TR67CON=getenv("SFR:C2TR67CON") 
.................... #endif 
....................  
.................... #word C1RXD=getenv("SFR:C1RXD") 
.................... #word C1TXD=getenv("SFR:C1TXD") 
....................  
.................... #if getenv("SFR_VALID:C2RXD") 
....................    #word C2RXD=getenv("SFR:C2RXD") 
....................    #word C2TXD=getenv("SFR:C2TXD") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // ECAN Interrupt Code Register 
.................... struct CiVEC_struct { 
....................    int icode:7;            //0:6    // Interrupt Flag Code bits 
....................    int1 void7;             //7 
....................    int filhit:5;           //8:12   // Filter Hit Number bits 
....................    int void15_13:3;        //13:15 
.................... }; 
....................  
.................... struct CiVEC_struct C1VEC; 
.................... #word C1VEC=getenv("SFR:C1VEC") 
....................  
.................... #if getenv("SFR_VALID:C2VEC") 
....................    struct CiVEC_struct C2VEC; 
....................    #word C2VEC=getenv("SFR:C2VEC") 
.................... #endif 
....................  
.................... // ECAN FIF0 Control Register 
.................... struct CiFCTRL_struct { 
....................    int fsa:5;              //0:4    // FIFO Area Starts with Buffer bits 
....................    int void12_5:8;         //5:12 
....................    int dmabs:3;            //13:15  // DMA Buffer Size bits 
.................... }; 
....................  
.................... struct CiFCTRL_struct C1FCTRL; 
.................... #word C1FCTRL=getenv("SFR:C1FCTRL") 
....................  
.................... #if getenv("SFR_VALID:C2FCTRL") 
....................    struct CiFCTRL_struct C2FCTRL; 
....................    #word C2FCTRL=getenv("SFR:C2FCTRL") 
.................... #endif 
....................  
.................... // ECAN FIF0 Status Register 
.................... struct CiFIFO_struct { 
....................    int fnrb:6;             //0:5    // FIFO Next Read Buffer Pointer bits 
....................    int void76:2;           //6:7 
....................    int fbp:6;              //8:13   // FIFO Buffer Pointer bits 
....................    int void15_14:2;        //14:15 
.................... }; 
....................  
.................... struct CiFIFO_struct C1FIFO; 
.................... #word C1FIFO=getenv("SFR:C1FIFO") 
....................  
.................... #if getenv("SFR_VALID:C2FIFO") 
....................    struct CiFIFO_struct C2FIFO; 
....................    #word C2FIFO=getenv("SFR:C2FIFO") 
.................... #endif 
....................  
.................... // ECAN Interrupt Flag Register 
.................... struct CiINTF_struct { 
....................    int1 tbif;              //0      // TX Buffer Interrupt flag bit 
....................    int1 rbif;              //1      // rx buffer interrupt flag bit 
....................    int1 rbobif;            //2      // rx buffer overflow interrupt flag bit 
....................    int1 fifoif;            //3      // fifo almost full interrupt flag bit 
....................    int1 void4;             //4 
....................    int1 errif;             //5      // error interrupt flag bit 
....................    int1 wakif;             //6      // bus wake-up activity interrupt flag bit 
....................    int1 ivrif;             //7      // invalid message received interrupt flag bit 
....................    int1 ewarn;             //8      // transmitter or receiver in error state warning bit 
....................    int1 rxwar;             //9      // receiver in error state warning bit 
....................    int1 txwar;             //10     // transmitter in error state warning bit 
....................    int1 rxbp;              //11     // receiver in error state bus passive bit 
....................    int1 txbp;              //12     // transmitter in error state bus passive bit 
....................    int1 txbo;              //13     // transmitter in error state bus off bit 
....................    int void15_14:2;        //14:15 
.................... }; 
....................  
.................... struct CiINTF_struct C1INTF; 
.................... #word C1INTF=getenv("SFR:C1INTF") 
....................  
.................... #if getenv("SFR_VALID:C2INTF") 
....................    struct CiINTF_struct C2INTF; 
....................    #word C2INTF=getenv("SFR:C2INTF") 
.................... #endif 
....................  
.................... enum INTERRUPT {TB=0x01,RB=0x02,RXOV=0x04,FIFO=0x08,ERR=0x20,WAK=0x40,IVR=0x80}; 
....................  
.................... // ECAN Interrupt Enable Register 
.................... typedef struct { 
....................    int1 tbie;              //0      //tx buffer interrupt enable bit 
....................    int1 rbie;              //1      //rx buffer interrupt enable bit 
....................    int1 rbovie;            //2      //rx buffer overflow interrupt enable bit 
....................    int1 fifoie;            //3      //fifo almost full interrupt enable bit 
....................    int1 void4;             //4 
....................    int1 errie;             //5      //error interrupt enable bit 
....................    int1 wakie;             //6      //bus wake-up activity interrupt enable bit 
....................    int1 ivrie;             //7      //invalid message received interrupt enable bit 
....................    uint8_t void15_8;       //8:15 
.................... }CiINTE_struct; 
....................  
.................... CiINTE_struct C1INTE; 
.................... #word C1INTE=getenv("SFR:C1INTE") 
....................  
.................... #if getenv("SFR_VALID:C2INTE") 
....................    CiINTE_struct C2INTE; 
....................    #word C2INTE=getenv("SFR:C2INTE") 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    uint8_t filthit;     // filter that allowed the frame into the buffer 
....................    uint8_t buffer;      // receive buffer 
....................    int1 err_ovfl;       // buffer overflow 
....................    int1 rtr;            // rtr requested 
....................    int1 ext;            // extended id 
....................    int1 inv;            // invalid id? 
.................... }; 
....................  
.................... void can_init(void); 
.................... void can_set_baud(void); 
.................... void can_set_mode(CAN_OP_MODE mode); 
.................... void can_set_id(uint16_t *addr, uint32_t id, int1 ext); 
.................... void can_set_buffer_id(BUFFER buffer, uint32_t id, int1 ext); 
.................... void can_set_buffer_size(uint8_t size); 
.................... uint32_t can_get_id(BUFFER buffer, int1 ext); 
.................... int1 can_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t priority, int1 ext, int1 rtr); 
.................... int1 can_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat); 
.................... void can_enable_b_transfer(BUFFER b); 
.................... void can_enable_b_receiver(BUFFER b); 
.................... void can_enable_rtr(BUFFER b); 
.................... void can_disable_rtr(BUFFER b); 
.................... void can_load_rtr (BUFFER b, uint8_t *data, uint8_t len); 
.................... void can_enable_filter(CAN_FILTER_CONTROL filter); 
.................... void can_disable_filter(CAN_FILTER_CONTROL filter); 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter); 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATION mask, CAN_FILTER_ASSOCIATION filter); 
.................... int1 can_fifo_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat ); 
.................... void can_config_DMA(void); 
.................... void can_enable_interrupts(INTERRUPT setting); 
.................... void can_disable_interrupt(INTERRUPT setting); 
....................  
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_init(void); 
....................    void can2_set_baud(void); 
....................    void can2_set_mode(CAN_OP_MODE mode); 
....................    void can2_set_id(uint16_t *addr, uint32_t id, int1 ext); 
....................    void can2_set_buffer_id(BUFFER buffer, uint32_t id, int1 ext); 
....................    void can2_set_buffer_size(uint8_t size); 
....................    uint32_t can2_get_id(BUFFER buffer, int1 ext); 
....................    int1 can2_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t priority, int1 ext, int1 rtr); 
....................    int1 can2_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat & stat); 
....................    void can2_enable_b_transfer(BUFFER b); 
....................    void can2_enable_b_receiver(BUFFER b); 
....................    void can2_enable_rtr(BUFFER b); 
....................    void can2_disable_rtr(BUFFER b); 
....................    void can2_load_rtr (BUFFER b, uint8_t *data, uint8_t len); 
....................    void can2_enable_filter(CAN_FILTER_CONTROL filter); 
....................    void can2_disable_filter(CAN_FILTER_CONTROL filter); 
....................    void can2_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter); 
....................    void can2_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATION mask, CAN_FILTER_ASSOCIATION filter); 
....................    int1 can2_fifo_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat ); 
....................    void can2_config_DMA(void); 
....................    void can2_enable_interrupts(INTERRUPT setting); 
....................    void can2_disable_interrupt(INTERRUPT setting); 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
.................... //macros 
.................... #define can_kbhit() (((uint16_t)C1RXFUL1) || ((uint16_t)C1RXFUL2)) 
....................                          
.................... #define can_tbe() ((C1TR01CON.txenm && !C1TR01CON.txreqm) || (C1TR01CON.txenn && !C1TR01CON.txreqn) || (C1TR23CON.txenm && !C1TR23CON.txreqm) || (C1TR23CON.txenn && !C1TR23CON.txreqn) || (C1TR45CON.txenm && !C1TR45CON.txreqm) || (C1TR45CON.txenn && !C1TR45CON.txreqn) || ( C1TR67CON.txenm && !C1TR67CON.txreqm) || (C1TR67CON.txenn && !C1TR67CON.txreqn)) 
.................... #define can_abort()                 (C1CTRL1.abat=1) 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #define can2_kbhit() (((uint16_t)C2RXFUL1) || ((uint16_t)C2RXFUL2))    
....................    #define can2_tbe() ((C2TR01CON.txenm && !C2TR01CON.txreqm) || (C2TR01CON.txenn && !C2TR01CON.txreqn) || (C2TR23CON.txenm && !C2TR23CON.txreqm) || (C2TR23CON.txenn && !C2TR23CON.txreqn) || (C2TR45CON.txenm && !C2TR45CON.txreqm) || (C2TR45CON.txenn && !C2TR45CON.txreqn) || ( C2TR67CON.txenm && !C2TR67CON.txreqm) || (C2TR67CON.txenn && !C2TR67CON.txreqn)) 
....................    #define can2_abort()                 (C2CTRL1.abat=1) 
.................... #endif 
....................  
.................... // current mode variable 
.................... // used by many of the device drivers to prevent damage from the mode 
.................... CAN_OP_MODE curmode; 
....................  
.................... // Buffer for CAN1 
.................... #if CAN_BUFFER_SIZE==4  
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[4][8]; 
.................... #elif CAN_BUFFER_SIZE==6 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[6][8]; 
.................... #elif CAN_BUFFER_SIZE==8 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[8][8]; 
.................... #elif CAN_BUFFER_SIZE==12 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[12][8]; 
.................... #elif CAN_BUFFER_SIZE==16 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[16][8]; 
.................... #elif CAN_BUFFER_SIZE==24 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[24][8]; 
.................... #else 
....................    #BANK_DMA 
....................    uint16_t ecan1_message_buffer[32][8]; 
.................... #endif 
....................  
.................... // Buffer for CAN2 
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #if CAN2_BUFFER_SIZE==4  
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[4][8]; 
....................    #elif CAN2_BUFFER_SIZE==6 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[6][8]; 
....................    #elif CAN2_BUFFER_SIZE==8 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[8][8]; 
....................    #elif CAN2_BUFFER_SIZE==12 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[12][8]; 
....................    #elif CAN2_BUFFER_SIZE==16 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[16][8]; 
....................    #elif CAN2_BUFFER_SIZE==24 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[24][8]; 
....................    #else 
....................       #BANK_DMA 
....................       uint16_t ecan2_message_buffer[32][8]; 
....................    #endif 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // can2_init() 
.................... // 
.................... // Initializes PIC24 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs. Enables Filter 0 and associates 
.................... // it with the FIFO buffer. 
.................... // 
.................... // The constant (CAN_ENABLE_CAN_CAPTURE) are given a default define in the  
.................... // can-PIC24.h file.  These default values can be overwritten in the main code,  
.................... // but most applications will be fine with these defaults. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0165E:  MOV.B   #4,W0L
01660:  MOV.B   W0L,87E
01662:  CALL    1308
....................     
....................    C1CTRL1.cancap=CAN_ENABLE_CAN_CAPTURE; 
01666:  BCLR.B  400.3
....................    C1CTRL1.cancks=CAN_CANCKS; 
01668:  BSET.B  401.3
....................    can_set_baud(); 
0166A:  CALL    1324
....................     
....................    can_set_buffer_size(CAN_BUFFER_SIZE);      // sets size of DMA buffer to use 
0166E:  MOV.B   #20,W0L
01670:  MOV.B   W0L,86C
01672:  CALL    1360
....................    can_config_DMA();    
01676:  CALL    13F2
....................     
....................    can_set_id(&C1RXM0, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
0167A:  CLR.B   872
0167C:  MOV     #432,W4
0167E:  MOV     W4,86C
01680:  CLR     86E
01682:  CLR     870
01684:  CALL    142A
....................    can_set_id(&C1RXM1, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01688:  CLR.B   872
0168A:  MOV     #436,W4
0168C:  MOV     W4,86C
0168E:  CLR     86E
01690:  CLR     870
01692:  CALL    142A
....................    can_set_id(&C1RXM2, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 2 
01696:  CLR.B   872
01698:  MOV     #436,W4
0169A:  MOV     W4,86C
0169C:  CLR     86E
0169E:  CLR     870
016A0:  CALL    142A
....................     
....................    // set dynamic filters 
....................    can_set_id(&C1RXF0, 0, CAN_USE_EXTENDED_ID);  
016A4:  CLR.B   872
016A6:  MOV     #442,W4
016A8:  MOV     W4,86C
016AA:  CLR     86E
016AC:  CLR     870
016AE:  CALL    142A
....................    can_set_id(&C1RXF1, 0, CAN_USE_EXTENDED_ID); 
016B2:  CLR.B   872
016B4:  MOV     #446,W4
016B6:  MOV     W4,86C
016B8:  CLR     86E
016BA:  CLR     870
016BC:  CALL    142A
....................    can_set_id(&C1RXF2, 0, CAN_USE_EXTENDED_ID); 
016C0:  CLR.B   872
016C2:  MOV     #44A,W4
016C4:  MOV     W4,86C
016C6:  CLR     86E
016C8:  CLR     870
016CA:  CALL    142A
....................    can_set_id(&C1RXF3, 0, CAN_USE_EXTENDED_ID); 
016CE:  CLR.B   872
016D0:  MOV     #44E,W4
016D2:  MOV     W4,86C
016D4:  CLR     86E
016D6:  CLR     870
016D8:  CALL    142A
....................    can_set_id(&C1RXF4, 0, CAN_USE_EXTENDED_ID); 
016DC:  CLR.B   872
016DE:  MOV     #452,W4
016E0:  MOV     W4,86C
016E2:  CLR     86E
016E4:  CLR     870
016E6:  CALL    142A
....................    can_set_id(&C1RXF5, 0, CAN_USE_EXTENDED_ID); 
016EA:  CLR.B   872
016EC:  MOV     #456,W4
016EE:  MOV     W4,86C
016F0:  CLR     86E
016F2:  CLR     870
016F4:  CALL    142A
....................    can_set_id(&C1RXF6, 0, CAN_USE_EXTENDED_ID); 
016F8:  CLR.B   872
016FA:  MOV     #45A,W4
016FC:  MOV     W4,86C
016FE:  CLR     86E
01700:  CLR     870
01702:  CALL    142A
....................    can_set_id(&C1RXF7, 0, CAN_USE_EXTENDED_ID); 
01706:  CLR.B   872
01708:  MOV     #45E,W4
0170A:  MOV     W4,86C
0170C:  CLR     86E
0170E:  CLR     870
01710:  CALL    142A
....................    can_set_id(&C1RXF8, 0, CAN_USE_EXTENDED_ID); 
01714:  CLR.B   872
01716:  MOV     #462,W4
01718:  MOV     W4,86C
0171A:  CLR     86E
0171C:  CLR     870
0171E:  CALL    142A
....................    can_set_id(&C1RXF9, 0, CAN_USE_EXTENDED_ID); 
01722:  CLR.B   872
01724:  MOV     #466,W4
01726:  MOV     W4,86C
01728:  CLR     86E
0172A:  CLR     870
0172C:  CALL    142A
....................    can_set_id(&C1RXF10, 0, CAN_USE_EXTENDED_ID); 
01730:  CLR.B   872
01732:  MOV     #46A,W4
01734:  MOV     W4,86C
01736:  CLR     86E
01738:  CLR     870
0173A:  CALL    142A
....................    can_set_id(&C1RXF11, 0, CAN_USE_EXTENDED_ID); 
0173E:  CLR.B   872
01740:  MOV     #46E,W4
01742:  MOV     W4,86C
01744:  CLR     86E
01746:  CLR     870
01748:  CALL    142A
....................    can_set_id(&C1RXF12, 0, CAN_USE_EXTENDED_ID); 
0174C:  CLR.B   872
0174E:  MOV     #472,W4
01750:  MOV     W4,86C
01752:  CLR     86E
01754:  CLR     870
01756:  CALL    142A
....................    can_set_id(&C1RXF13, 0, CAN_USE_EXTENDED_ID); 
0175A:  CLR.B   872
0175C:  MOV     #476,W4
0175E:  MOV     W4,86C
01760:  CLR     86E
01762:  CLR     870
01764:  CALL    142A
....................    can_set_id(&C1RXF14, 0, CAN_USE_EXTENDED_ID); 
01768:  CLR.B   872
0176A:  MOV     #47A,W4
0176C:  MOV     W4,86C
0176E:  CLR     86E
01770:  CLR     870
01772:  CALL    142A
....................    can_set_id(&C1RXF15, 0, CAN_USE_EXTENDED_ID); 
01776:  CLR.B   872
01778:  MOV     #47E,W4
0177A:  MOV     W4,86C
0177C:  CLR     86E
0177E:  CLR     870
01780:  CALL    142A
....................     
....................    C1FEN1=0; 
01784:  CLR     414
....................     
....................    can_associate_filter_to_buffer(AFIFO,F0BP); 
01786:  MOV.B   #F,W0L
01788:  MOV.B   W0L,86C
0178A:  CLR.B   86D
0178C:  CALL    14D8
....................    can_enable_filter(FLTEN0); 
01790:  MOV     #1,W4
01792:  MOV     W4,86C
01794:  CALL    1630
....................     
....................    can_set_mode(CAN_OP_NORMAL); 
01798:  CLR.B   87E
0179A:  CALL    1308
0179E:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_init(void) { 
....................       can2_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
....................        
....................       C2CTRL1.cancap=CAN_ENABLE_CAN_CAPTURE; 
....................       C2CTRL1.cancks=CAN2_CANCKS; 
....................       can2_set_baud(); 
....................        
....................       can2_set_buffer_size(CAN2_BUFFER_SIZE);      // sets size of DMA buffer to use 
....................       can2_config_DMA();    
....................           
....................       can2_set_id(&C2RXM0, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
....................       can2_set_id(&C2RXM1, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
....................       can2_set_id(&C2RXM2, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 2 
....................        
....................       // set dynamic filters 
....................       can2_set_id(&C2RXF0, 0, CAN_USE_EXTENDED_ID);  
....................       can2_set_id(&C2RXF1, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF2, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF3, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF4, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF5, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF6, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF7, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF8, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF9, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF10, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF11, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF12, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF13, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF14, 0, CAN_USE_EXTENDED_ID); 
....................       can2_set_id(&C2RXF15, 0, CAN_USE_EXTENDED_ID); 
....................        
....................       C2FEN1=0; 
....................        
....................       can2_associate_filter_to_buffer(AFIFO,F0BP); 
....................       can2_enable_filter(FLTEN0); 
....................        
....................       can2_set_mode(CAN_OP_NORMAL); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // can2_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-PIC24.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set for 62.5 kBits if the PIC is running at 20 MHz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    C1CFG1.brp=CAN_BRG_PRESCALAR; 
*
01324:  MOV     410,W4
01326:  AND     #3C0,W4
01328:  IOR     #0,W4
0132A:  MOV.B   W4L,W0L
0132C:  MOV.B   W0L,410
....................    C1CFG1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0132E:  MOV     410,W4
01330:  AND     #33F,W4
01332:  IOR     #0,W4
01334:  MOV.B   W4L,W0L
01336:  MOV.B   W0L,410
....................  
....................    C1CFG2.prseg=CAN_BRG_PROPAGATION_TIME; 
01338:  MOV     412,W4
0133A:  AND     #3F8,W4
0133C:  IOR     #1,W4
0133E:  MOV.B   W4L,W0L
01340:  MOV.B   W0L,412
....................    C1CFG2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
01342:  MOV     412,W4
01344:  AND     #3C7,W4
01346:  IOR     #20,W4
01348:  MOV.B   W4L,W0L
0134A:  MOV.B   W0L,412
....................    C1CFG2.sam=CAN_BRG_SAM; 
0134C:  BCLR.B  412.6
....................    C1CFG2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0134E:  BSET.B  412.7
....................    C1CFG2.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
01350:  MOV     412,W4
01352:  LSR     W4,#8,W4
01354:  AND     #3F8,W4
01356:  IOR     #1,W4
01358:  MOV.B   W4L,W0L
0135A:  MOV.B   W0L,413
....................    C1CFG2.wakfil=CAN_BRG_WAKE_FILTER; 
0135C:  BCLR.B  413.6
0135E:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_set_baud(void) { 
....................       C2CFG1.brp=CAN2_BRG_PRESCALAR; 
....................       C2CFG1.sjw=CAN2_BRG_SYNCH_JUMP_WIDTH; 
....................     
....................       C2CFG2.prseg=CAN2_BRG_PROPAGATION_TIME; 
....................       C2CFG2.seg1ph=CAN2_BRG_PHASE_SEGMENT_1; 
....................       C2CFG2.sam=CAN2_BRG_SAM; 
....................       C2CFG2.seg2phts=CAN2_BRG_SEG_2_PHASE_TS; 
....................       C2CFG2.seg2ph=CAN2_BRG_PHASE_SEGMENT_2; 
....................       C2CFG2.wakfil=CAN2_BRG_WAKE_FILTER; 
....................    } 
.................... #endif 
....................     
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_mode() 
.................... // can2_set_mode() 
.................... // 
.................... // This function first sets the three bits (reqop2:reqop0) to the mode given  
.................... // through the argument. 
.................... // 
.................... // The reqop bits do not immediately change the mode of operation, the 
.................... // opmode bits in the C1CTRL1 or C2CTRL1 register (opmode2:opmode0) must change  
.................... // to reflect the actual change in mode, therefore a while statement is  
.................... // used to check if the C1CTRL1 or C2CTRL1 opmode bits have changed to reflect  
.................... // the change in mode. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_mode(CAN_OP_MODE mode) { 
*
01308:  MOV     W5,[W15++]
....................    C1CTRL1.reqop=mode; 
0130A:  MOV     #FFF8,W0
0130C:  AND.B   401
0130E:  MOV.B   87E,W0L
01310:  AND     #7,W0
01312:  IOR.B   401
....................    while( (C1CTRL1.opmode) != mode ); 
01314:  MOV.B   400,W0L
01316:  LSR     W0,#5,W4
01318:  AND     #7,W4
0131A:  MOV.B   W4L,W0L
0131C:  CP.B    87E
0131E:  BRA     NZ,1314
01320:  MOV     [--W15],W5
01322:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_set_mode(CAN_OP_MODE mode) { 
....................       C2CTRL1.reqop=mode; 
....................       while( (C2CTRL1.opmode) != mode ); 
....................    } 
.................... #endif 
....................     
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // can2_set_id() 
.................... // 
.................... // Configures the xxxxEID and xxxxSID registers to configure the defined  
.................... // acceptance filter or acceptance filter mask to the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEID. 
.................... //            For example, a pointer to C1RXF0 
.................... // 
.................... //     id - ID to set filter or mask to 
.................... //     ext - Set to TRUE if this filter or mask uses an extended ID,  
.................... //     FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(uint16_t *addr, uint32_t id, int1 ext)  
*
0142A:  MOV     W5,[W15++]
0142C:  MOV     W6,[W15++]
.................... { 
....................    uint16_t temp; 
....................    curmode=C1CTRL1.opmode; 
0142E:  MOV.B   400,W0L
01430:  LSR     W0,#5,W4
01432:  AND     #7,W4
01434:  PUSH    800
01436:  MOV.B   W4L,[W15-#2]
01438:  POP     800
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
0143A:  MOV.B   #4,W0L
0143C:  MOV.B   W0L,87E
0143E:  CALL    1308
....................     
....................    C1CTRL1.win=1; 
01442:  BSET.B  400.0
....................     
....................    if (ext) {  //extended 
01444:  CP0.B   872
01446:  BRA     Z,148E
....................       //eid 
....................       *addr=(id & 0xffff);                         //0:15 
01448:  MOV     86C,W5
0144A:  CLR     W1
0144C:  MOV     86E,W0
0144E:  MOV     W0,[W5]
....................     
....................       //sid 
....................       addr-=1; 
01450:  MOV     86C,W4
01452:  SUB     W4,#2,W0
01454:  MOV     W0,86C
....................       *addr&=0x1C; 
01456:  MOV     86C,W5
01458:  MOV     [W5],W0
0145A:  AND     W0,#1C,W0
0145C:  MOV     W0,[W5]
....................       temp=((id & 0x30000) >> 16); 
0145E:  CLR     W5
01460:  MOV     870,W0
01462:  AND     W0,#3,W6
01464:  MOV     W6,874
....................       temp|=((id & 0x1FFC0000) >> 13); 
01466:  CLR     W5
01468:  MOV     #1FFC,W0
0146A:  AND     870,W0
0146C:  MOV     W0,W6
0146E:  MOV     #D,W4
01470:  MOV     W5,W0
01472:  MOV     W6,W1
01474:  INC     W4,W4
01476:  DEC     W4,W4
01478:  BRA     Z,1480
0147A:  LSR     W1,W1
0147C:  RRC     W0,W0
0147E:  BRA     1476
01480:  IOR     874
....................       *addr|=temp;                                 //16:28 
01482:  MOV     86C,W5
01484:  MOV     [W5],W0
01486:  IOR     874,W0
01488:  MOV     W0,[W5]
....................    } 
0148A:  GOTO    14C8
....................        
....................    else {   //standard 
....................       //eid 
....................       *addr=0; 
0148E:  MOV     86C,W5
01490:  CLR.B   [W5]
01492:  MOV.B   #0,W0L
01494:  MOV.B   W0L,[W5+#1]
....................  
....................       //sid 
....................       addr-=1; 
01496:  MOV     86C,W4
01498:  SUB     W4,#2,W0
0149A:  MOV     W0,86C
....................       *addr&=0x1C; 
0149C:  MOV     86C,W5
0149E:  MOV     [W5],W0
014A0:  AND     W0,#1C,W0
014A2:  MOV     W0,[W5]
....................       temp=((id & 0x7FF) << 5); 
014A4:  MOV     #7FF,W0
014A6:  AND     86E,W0
014A8:  MOV     W0,W5
014AA:  CLR     W6
014AC:  MOV     #5,W4
014AE:  MOV     W5,W0
014B0:  MOV     W6,W1
014B2:  INC     W4,W4
014B4:  DEC     W4,W4
014B6:  BRA     Z,14BE
014B8:  SL      W0,W0
014BA:  RLC     W1,W1
014BC:  BRA     14B4
014BE:  MOV     W0,874
....................       *addr|=temp;                              //0:10 
014C0:  MOV     86C,W5
014C2:  MOV     [W5],W0
014C4:  IOR     874,W0
014C6:  MOV     W0,[W5]
....................    } 
....................    C1CTRL1.win=0; 
014C8:  BCLR.B  400.0
....................     
....................    can_set_mode(curmode); 
014CA:  MOV.B   800,W0L
014CC:  MOV.B   W0L,87E
014CE:  CALL    1308
014D2:  MOV     [--W15],W6
014D4:  MOV     [--W15],W5
014D6:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_set_id(uint16_t *addr, uint32_t id, int1 ext)  
....................    { 
....................       uint16_t temp; 
....................       curmode=C2CTRL1.opmode; 
....................     
....................       can2_set_mode(CAN_OP_CONFIG); 
....................        
....................       C2CTRL1.win=1; 
....................        
....................       if (ext) {  //extended 
....................          //eid 
....................          *addr=(id & 0xffff);                         //0:15 
....................        
....................          //sid 
....................          addr-=1; 
....................          *addr&=0x1C; 
....................          temp=((id & 0x30000) >> 16); 
....................          temp|=((id & 0x1FFC0000) >> 13); 
....................          *addr|=temp;                                 //16:28 
....................       } 
....................           
....................       else {   //standard 
....................          //eid 
....................          *addr=0; 
....................     
....................          //sid 
....................          addr-=1; 
....................          *addr&=0x1C; 
....................          temp=((id & 0x7FF) << 5); 
....................          *addr|=temp;                              //0:10 
....................       } 
....................       C2CTRL1.win=0; 
....................        
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_buffer_id() 
.................... // can2_set_buffer_id() 
.................... // 
.................... // Configures the defined buffer to use the specified ID 
.................... // 
.................... // Parameters: 
.................... //       buffer - the desired buffer 
.................... //        enumerated as TRB0-TRB7 
.................... // 
.................... //       id - ID to set buffer to 
.................... //       ext - Set to TRUE is this buffer uses an extended ID, False if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_buffer_id(BUFFER buffer, uint32_t id, int1 ext) 
.................... { 
....................    uint16_t *ptr; 
....................    uint16_t temp; 
....................     
....................    ptr=&ecan1_message_buffer[buffer][2]; 
....................  
....................    if (ext) 
....................    { 
....................       //eid 
....................       *ptr&=0x20F; 
....................       temp=((id & 0x3F) << 10); 
....................       *ptr|=temp; 
....................       ptr-=1; 
....................       temp=((id & 0x3FFC0) >> 6); 
....................       *ptr=temp; 
....................        
....................       //sid 
....................       ptr-=1; 
....................       *ptr&=0x2; 
....................       temp=(((id & 0x1FFC0000) >> 16) | ext); 
....................       *ptr|=temp; 
....................    } 
....................    else 
....................    { 
....................       //eid 
....................       *ptr&=0x20F; 
....................       ptr-=1; 
....................       *ptr=0; 
....................       
....................       //sid 
....................       ptr-=1; 
....................       *ptr&=0x2; 
....................       temp=(((id & 0x7FF) << 2) | ext); 
....................       *ptr|=temp; 
....................    } 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_set_buffer_id(BUFFER buffer, uint32_t id, int1 ext) 
....................    { 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       ptr=&ecan2_message_buffer[buffer][2]; 
....................     
....................       if (ext) 
....................       { 
....................          //eid 
....................          *ptr&=0x20F; 
....................          temp=((id & 0x3F) << 10); 
....................          *ptr|=temp; 
....................          ptr-=1; 
....................          temp=((id & 0x3FFC0) >> 6); 
....................          *ptr=temp; 
....................           
....................          //sid 
....................          ptr-=1; 
....................          *ptr&=0x2; 
....................          temp=(((id & 0x1FFC0000) >> 16) | ext); 
....................          *ptr|=temp; 
....................       } 
....................       else 
....................       { 
....................          //eid 
....................          *ptr&=0x20F; 
....................          ptr-=1; 
....................          *ptr=0; 
....................          
....................          //sid 
....................          ptr-=1; 
....................          *ptr&=0x2; 
....................          temp=(((id & 0x7FF) << 2) | ext); 
....................          *ptr|=temp; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_buffer_size() 
.................... // can2_set_buffer_size() 
.................... // 
.................... // Configures the number of DMA buffers the ECAN module uses. 
.................... // 
.................... // Parameters: 
.................... //       size - the desired buffer size to be used. Valid sizes 4, 6, 8, 12, 16, 
.................... //              24, and 32 
.................... // 
.................... // Returns: 
.................... //       void 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_buffer_size(uint8_t size) 
.................... { 
....................    if (size==4) 
*
01360:  MOV     86C,W4
01362:  CP.B    W4L,#4
01364:  BRA     NZ,1376
....................       C1FCTRL.dmabs=0; 
01366:  MOV     406,W4
01368:  LSR     W4,#8,W4
0136A:  AND     #31F,W4
0136C:  IOR     #0,W4
0136E:  MOV.B   W4L,W0L
01370:  MOV.B   W0L,407
01372:  GOTO    13F0
....................    else if (size==6) 
01376:  MOV     86C,W4
01378:  CP.B    W4L,#6
0137A:  BRA     NZ,138C
....................       C1FCTRL.dmabs=1; 
0137C:  MOV     406,W4
0137E:  LSR     W4,#8,W4
01380:  AND     #31F,W4
01382:  IOR     #20,W4
01384:  MOV.B   W4L,W0L
01386:  MOV.B   W0L,407
01388:  GOTO    13F0
....................    else if (size==8) 
0138C:  MOV     86C,W4
0138E:  CP.B    W4L,#8
01390:  BRA     NZ,13A2
....................       C1FCTRL.dmabs=2; 
01392:  MOV     406,W4
01394:  LSR     W4,#8,W4
01396:  AND     #31F,W4
01398:  IOR     #40,W4
0139A:  MOV.B   W4L,W0L
0139C:  MOV.B   W0L,407
0139E:  GOTO    13F0
....................    else if (size==12) 
013A2:  MOV     86C,W4
013A4:  CP.B    W4L,#C
013A6:  BRA     NZ,13B8
....................       C1FCTRL.dmabs=3; 
013A8:  MOV     406,W4
013AA:  LSR     W4,#8,W4
013AC:  AND     #31F,W4
013AE:  IOR     #60,W4
013B0:  MOV.B   W4L,W0L
013B2:  MOV.B   W0L,407
013B4:  GOTO    13F0
....................    else if (size==16) 
013B8:  MOV     86C,W4
013BA:  CP.B    W4L,#10
013BC:  BRA     NZ,13CE
....................       C1FCTRL.dmabs=4; 
013BE:  MOV     406,W4
013C0:  LSR     W4,#8,W4
013C2:  AND     #31F,W4
013C4:  IOR     #80,W4
013C6:  MOV.B   W4L,W0L
013C8:  MOV.B   W0L,407
013CA:  GOTO    13F0
....................    else if (size==24) 
013CE:  MOV     86C,W4
013D0:  CP.B    W4L,#18
013D2:  BRA     NZ,13E4
....................       C1FCTRL.dmabs=5; 
013D4:  MOV     406,W4
013D6:  LSR     W4,#8,W4
013D8:  AND     #31F,W4
013DA:  IOR     #A0,W4
013DC:  MOV.B   W4L,W0L
013DE:  MOV.B   W0L,407
013E0:  GOTO    13F0
....................    else 
....................       C1FCTRL.dmabs=6; 
013E4:  MOV     406,W4
013E6:  LSR     W4,#8,W4
013E8:  AND     #31F,W4
013EA:  IOR     #C0,W4
013EC:  MOV.B   W4L,W0L
013EE:  MOV.B   W0L,407
013F0:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_set_buffer_size(uint8_t size) 
....................    { 
....................       if (size==4) 
....................          C2FCTRL.dmabs=0; 
....................       else if (size==6) 
....................          C2FCTRL.dmabs=1; 
....................       else if (size==8) 
....................          C2FCTRL.dmabs=2; 
....................       else if (size==12) 
....................          C2FCTRL.dmabs=3; 
....................       else if (size==16) 
....................          C2FCTRL.dmabs=4; 
....................       else if (size==24) 
....................          C2FCTRL.dmabs=5; 
....................       else 
....................          C2FCTRL.dmabs=6; 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_filter() 
.................... // can2_enable_filter() 
.................... // 
.................... // Enables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be enabled 
.................... //         enumerated as - FLTEN0-FLTEN15 
.................... // 
.................... // Returns: 
.................... //    void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC24H Family  
.................... // Reference Manual, Section 21 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_filter(CAN_FILTER_CONTROL filter) 
*
01630:  MOV     W5,[W15++]
.................... { 
....................    uint16_t *ptr; 
....................  
....................    curmode=C1CTRL1.opmode; 
01632:  MOV.B   400,W0L
01634:  LSR     W0,#5,W4
01636:  AND     #7,W4
01638:  PUSH    800
0163A:  MOV.B   W4L,[W15-#2]
0163C:  POP     800
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
0163E:  MOV.B   #4,W0L
01640:  MOV.B   W0L,87E
01642:  CALL    1308
....................  
....................    ptr = &C1FEN1; 
01646:  MOV     #414,W4
01648:  MOV     W4,86E
....................  
....................    *ptr|=filter; 
0164A:  MOV     86E,W5
0164C:  MOV     [W5],W0
0164E:  IOR     86C,W0
01650:  MOV     W0,[W5]
....................  
....................    can_set_mode(curmode); 
01652:  MOV.B   800,W0L
01654:  MOV.B   W0L,87E
01656:  CALL    1308
0165A:  MOV     [--W15],W5
0165C:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_enable_filter(CAN_FILTER_CONTROL filter) 
....................    { 
....................       uint16_t *ptr; 
....................     
....................       curmode=C2CTRL1.opmode; 
....................     
....................       can2_set_mode(CAN_OP_CONFIG); 
....................     
....................       ptr = &C2FEN1; 
....................     
....................       *ptr|=filter; 
....................     
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_filter() 
.................... // can2_disable_filter() 
.................... // 
.................... // Disables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be disabled 
.................... //        enumerated as - FLTEN0-FLTEN15 
.................... // 
.................... // Returns: 
.................... //      void; 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC24H Family  
.................... // Reference Manual, Section 21 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_disable_filter(CAN_FILTER_CONTROL filter) 
.................... { 
....................    uint16_t *ptr; 
....................  
....................    curmode=C1CTRL1.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &C1FEN1; 
....................  
....................    *ptr&=~filter; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_disable_filter(CAN_FILTER_CONTROL filter) 
....................    { 
....................       uint16_t *ptr; 
....................     
....................       curmode=C2CTRL1.opmode; 
....................     
....................       can2_set_mode(CAN_OP_CONFIG); 
....................     
....................       ptr = &C2FEN1; 
....................     
....................       *ptr&=~filter; 
....................     
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_buffer() 
.................... // can2_associate_filter_to_buffer() 
.................... // 
.................... // Associates a given buffer with a given filter register 
.................... // 
.................... // Parameters: 
.................... //      buffer - the buffer that is to be associated with the filter 
.................... //        enumerated as 
.................... //               ATRB0-ATRB7 - Programmable receive Buffers 0 - 7 
.................... //               ARB8-ARB14 - Dedicated receive buffers 8-14 
.................... //               AFIFO - FIFO buffer 
.................... // 
.................... //      filter - the filter that is to be associated with the buffer 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... // Returns: 
.................... //      void 
.................... //  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    curmode=C1CTRL1.opmode; 
*
014D8:  MOV.B   400,W0L
014DA:  LSR     W0,#5,W4
014DC:  AND     #7,W4
014DE:  PUSH    800
014E0:  MOV.B   W4L,[W15-#2]
014E2:  POP     800
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
014E4:  MOV.B   #4,W0L
014E6:  MOV.B   W0L,87E
014E8:  CALL    1308
....................     
....................    C1CTRL1.win=1; 
014EC:  BSET.B  400.0
....................     
....................    switch(filter) 
014EE:  MOV.B   86D,W0L
014F0:  CLR.B   1
014F2:  XOR     #0,W0
014F4:  BRA     Z,1534
014F6:  XOR     #1,W0
014F8:  BRA     Z,1542
014FA:  XOR     #3,W0
014FC:  BRA     Z,1552
014FE:  XOR     #1,W0
01500:  BRA     Z,1560
01502:  XOR     #7,W0
01504:  BRA     Z,1570
01506:  XOR     #1,W0
01508:  BRA     Z,157E
0150A:  XOR     #3,W0
0150C:  BRA     Z,158E
0150E:  XOR     #1,W0
01510:  BRA     Z,159C
01512:  XOR     #F,W0
01514:  BRA     Z,15AC
01516:  XOR     #1,W0
01518:  BRA     Z,15BA
0151A:  XOR     #3,W0
0151C:  BRA     Z,15CA
0151E:  XOR     #1,W0
01520:  BRA     Z,15D8
01522:  XOR     #7,W0
01524:  BRA     Z,15E8
01526:  XOR     #1,W0
01528:  BRA     Z,15F6
0152A:  XOR     #3,W0
0152C:  BRA     Z,1606
0152E:  XOR     #1,W0
01530:  BRA     Z,1614
01532:  BRA     1624
....................    { 
....................       case 0: 
....................          C1BUFPNT1.f0bp=buffer; 
01534:  MOV     #FFF0,W0
01536:  AND.B   420
01538:  MOV.B   86C,W0L
0153A:  AND     #F,W0
0153C:  IOR.B   420
....................          break; 
0153E:  GOTO    1624
....................       case 1: 
....................          C1BUFPNT1.f1bp=buffer; 
01542:  MOV     #FF0F,W0
01544:  AND.B   420
01546:  MOV.B   86C,W0L
01548:  AND     #F,W0
0154A:  SL      W0,#4,W0
0154C:  IOR.B   420
....................          break; 
0154E:  GOTO    1624
....................       case 2: 
....................          C1BUFPNT1.f2bp=buffer; 
01552:  MOV     #FFF0,W0
01554:  AND.B   421
01556:  MOV.B   86C,W0L
01558:  AND     #F,W0
0155A:  IOR.B   421
....................          break; 
0155C:  GOTO    1624
....................       case 3: 
....................          C1BUFPNT1.f3bp=buffer; 
01560:  MOV     #FF0F,W0
01562:  AND.B   421
01564:  MOV.B   86C,W0L
01566:  AND     #F,W0
01568:  SL      W0,#4,W0
0156A:  IOR.B   421
....................          break; 
0156C:  GOTO    1624
....................       case 4: 
....................          C1BUFPNT2.f4bp=buffer; 
01570:  MOV     #FFF0,W0
01572:  AND.B   422
01574:  MOV.B   86C,W0L
01576:  AND     #F,W0
01578:  IOR.B   422
....................          break; 
0157A:  GOTO    1624
....................       case 5: 
....................          C1BUFPNT2.f5bp=buffer; 
0157E:  MOV     #FF0F,W0
01580:  AND.B   422
01582:  MOV.B   86C,W0L
01584:  AND     #F,W0
01586:  SL      W0,#4,W0
01588:  IOR.B   422
....................          break; 
0158A:  GOTO    1624
....................       case 6: 
....................          C1BUFPNT2.f6bp=buffer; 
0158E:  MOV     #FFF0,W0
01590:  AND.B   423
01592:  MOV.B   86C,W0L
01594:  AND     #F,W0
01596:  IOR.B   423
....................          break; 
01598:  GOTO    1624
....................       case 7: 
....................          C1BUFPNT2.f7bp=buffer; 
0159C:  MOV     #FF0F,W0
0159E:  AND.B   423
015A0:  MOV.B   86C,W0L
015A2:  AND     #F,W0
015A4:  SL      W0,#4,W0
015A6:  IOR.B   423
....................          break; 
015A8:  GOTO    1624
....................       case 8: 
....................          C1BUFPNT3.f8bp=buffer; 
015AC:  MOV     #FFF0,W0
015AE:  AND.B   424
015B0:  MOV.B   86C,W0L
015B2:  AND     #F,W0
015B4:  IOR.B   424
....................          break; 
015B6:  GOTO    1624
....................       case 9: 
....................          C1BUFPNT3.f9bp=buffer; 
015BA:  MOV     #FF0F,W0
015BC:  AND.B   424
015BE:  MOV.B   86C,W0L
015C0:  AND     #F,W0
015C2:  SL      W0,#4,W0
015C4:  IOR.B   424
....................          break; 
015C6:  GOTO    1624
....................       case 10: 
....................          C1BUFPNT3.f10bp=buffer; 
015CA:  MOV     #FFF0,W0
015CC:  AND.B   425
015CE:  MOV.B   86C,W0L
015D0:  AND     #F,W0
015D2:  IOR.B   425
....................          break; 
015D4:  GOTO    1624
....................       case 11: 
....................          C1BUFPNT3.f11bp=buffer; 
015D8:  MOV     #FF0F,W0
015DA:  AND.B   425
015DC:  MOV.B   86C,W0L
015DE:  AND     #F,W0
015E0:  SL      W0,#4,W0
015E2:  IOR.B   425
....................          break; 
015E4:  GOTO    1624
....................       case 12: 
....................          C1BUFPNT4.f12bp=buffer; 
015E8:  MOV     #FFF0,W0
015EA:  AND.B   426
015EC:  MOV.B   86C,W0L
015EE:  AND     #F,W0
015F0:  IOR.B   426
....................          break; 
015F2:  GOTO    1624
....................       case 13: 
....................          C1BUFPNT4.f13bp=buffer; 
015F6:  MOV     #FF0F,W0
015F8:  AND.B   426
015FA:  MOV.B   86C,W0L
015FC:  AND     #F,W0
015FE:  SL      W0,#4,W0
01600:  IOR.B   426
....................          break; 
01602:  GOTO    1624
....................       case 14: 
....................          C1BUFPNT4.f14bp=buffer; 
01606:  MOV     #FFF0,W0
01608:  AND.B   427
0160A:  MOV.B   86C,W0L
0160C:  AND     #F,W0
0160E:  IOR.B   427
....................          break; 
01610:  GOTO    1624
....................       case 15: 
....................          C1BUFPNT4.f15bp=buffer; 
01614:  MOV     #FF0F,W0
01616:  AND.B   427
01618:  MOV.B   86C,W0L
0161A:  AND     #F,W0
0161C:  SL      W0,#4,W0
0161E:  IOR.B   427
....................          break; 
01620:  GOTO    1624
....................    } 
....................    C1CTRL1.win=0; 
01624:  BCLR.B  400.0
....................     
....................    can_set_mode(curmode); 
01626:  MOV.B   800,W0L
01628:  MOV.B   W0L,87E
0162A:  CALL    1308
0162E:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter) 
....................    { 
....................       curmode=C2CTRL1.opmode; 
....................     
....................       can2_set_mode(CAN_OP_CONFIG); 
....................        
....................       C2CTRL1.win=1; 
....................        
....................       switch(filter) 
....................       { 
....................          case 0: 
....................             C2BUFPNT1.f0bp=buffer; 
....................             break; 
....................          case 1: 
....................             C2BUFPNT1.f1bp=buffer; 
....................             break; 
....................          case 2: 
....................             C2BUFPNT1.f2bp=buffer; 
....................             break; 
....................          case 3: 
....................             C2BUFPNT1.f3bp=buffer; 
....................             break; 
....................          case 4: 
....................             C2BUFPNT2.f4bp=buffer; 
....................             break; 
....................          case 5: 
....................             C2BUFPNT2.f5bp=buffer; 
....................             break; 
....................          case 6: 
....................             C2BUFPNT2.f6bp=buffer; 
....................             break; 
....................          case 7: 
....................             C2BUFPNT2.f7bp=buffer; 
....................             break; 
....................          case 8: 
....................             C2BUFPNT3.f8bp=buffer; 
....................             break; 
....................          case 9: 
....................             C2BUFPNT3.f9bp=buffer; 
....................             break; 
....................          case 10: 
....................             C2BUFPNT3.f10bp=buffer; 
....................             break; 
....................          case 11: 
....................             C2BUFPNT3.f11bp=buffer; 
....................             break; 
....................          case 12: 
....................             C2BUFPNT4.f12bp=buffer; 
....................             break; 
....................          case 13: 
....................             C2BUFPNT4.f13bp=buffer; 
....................             break; 
....................          case 14: 
....................             C2BUFPNT4.f14bp=buffer; 
....................             break; 
....................          case 15: 
....................             C2BUFPNT4.f15bp=buffer; 
....................             break; 
....................       } 
....................       C2CTRL1.win=0; 
....................        
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_mask() 
.................... // can2_associate_filter_to_mask() 
.................... // 
.................... //   Associates a given filter to a given mask 
.................... // 
.................... //   Parameters: 
.................... //      mask - the mask that is to be associated with the filter 
.................... //         enumerated as 
.................... //            ACCEPTANCE_MASK_0 
.................... //            ACCEPTANCE_MASK_1 
.................... //            ACCEPTANCE_MASK_2 
.................... //            NO_MASK 
.................... // 
.................... //      filter - the filter that is to be associated with the mask 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... //   Returns: 
.................... //      void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC24H Family  
.................... // Reference Manual, Section 21 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATION mask, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    curmode = C1CTRL1.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................     
....................    switch(filter) 
....................    { 
....................       case 0: 
....................          C1FMSKSEL1.f0msk=mask; 
....................          break; 
....................       case 1: 
....................          C1FMSKSEL1.f1msk=mask; 
....................          break; 
....................       case 2: 
....................          C1FMSKSEL1.f2msk=mask; 
....................          break; 
....................       case 3: 
....................          C1FMSKSEL1.f3msk=mask; 
....................          break; 
....................       case 4: 
....................          C1FMSKSEL1.f4msk=mask; 
....................          break; 
....................       case 5: 
....................          C1FMSKSEL1.f5msk=mask; 
....................          break; 
....................       case 6: 
....................          C1FMSKSEL1.f6msk=mask; 
....................          break; 
....................       case 7: 
....................          C1FMSKSEL1.f7msk=mask; 
....................          break; 
....................       case 8: 
....................          C1FMSKSEL2.f8msk=mask; 
....................          break; 
....................       case 9: 
....................          C1FMSKSEL2.f9msk=mask; 
....................          break; 
....................       case 10: 
....................          C1FMSKSEL2.f10msk=mask; 
....................          break; 
....................       case 11: 
....................          C1FMSKSEL2.f11msk=mask; 
....................          break; 
....................       case 12: 
....................          C1FMSKSEL2.f12msk=mask; 
....................          break; 
....................       case 13: 
....................          C1FMSKSEL2.f13msk=mask; 
....................          break; 
....................       case 14: 
....................          C1FMSKSEL2.f14msk=mask; 
....................          break; 
....................       case 15: 
....................          C1FMSKSEL2.f15msk=mask; 
....................          break; 
....................    } 
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATION mask, CAN_FILTER_ASSOCIATION filter) 
....................    { 
....................       curmode = C2CTRL1.opmode; 
....................     
....................       can2_set_mode(CAN_OP_CONFIG); 
....................        
....................       switch(filter) 
....................       { 
....................          case 0: 
....................             C2FMSKSEL1.f0msk=mask; 
....................             break; 
....................          case 1: 
....................             C2FMSKSEL1.f1msk=mask; 
....................             break; 
....................          case 2: 
....................             C2FMSKSEL1.f2msk=mask; 
....................             break; 
....................          case 3: 
....................             C2FMSKSEL1.f3msk=mask; 
....................             break; 
....................          case 4: 
....................             C2FMSKSEL1.f4msk=mask; 
....................             break; 
....................          case 5: 
....................             C2FMSKSEL1.f5msk=mask; 
....................             break; 
....................          case 6: 
....................             C2FMSKSEL1.f6msk=mask; 
....................             break; 
....................          case 7: 
....................             C2FMSKSEL1.f7msk=mask; 
....................             break; 
....................          case 8: 
....................             C2FMSKSEL2.f8msk=mask; 
....................             break; 
....................          case 9: 
....................             C2FMSKSEL2.f9msk=mask; 
....................             break; 
....................          case 10: 
....................             C2FMSKSEL2.f10msk=mask; 
....................             break; 
....................          case 11: 
....................             C2FMSKSEL2.f11msk=mask; 
....................             break; 
....................          case 12: 
....................             C2FMSKSEL2.f12msk=mask; 
....................             break; 
....................          case 13: 
....................             C2FMSKSEL2.f13msk=mask; 
....................             break; 
....................          case 14: 
....................             C2FMSKSEL2.f14msk=mask; 
....................             break; 
....................          case 15: 
....................             C2FMSKSEL2.f15msk=mask; 
....................             break; 
....................       } 
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // can2_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If unsuccessful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t priority, int1 ext, int1 rtr)  
*
019D2:  MOV     W5,[W15++]
019D4:  MOV     W6,[W15++]
019D6:  MOV     W7,[W15++]
019D8:  MOV     W8,[W15++]
.................... { 
....................    uint16_t *ptr; 
....................    uint16_t i; 
....................    uint16_t port; 
....................    uint16_t temp; 
....................        
....................     // find empty transmitter 
....................    if (C1TR01CON.txenm && !C1TR01CON.txreqm && !C1TR01CON.rtrenm) 
019DA:  BTSS.B  430.7
019DC:  BRA     19EC
019DE:  BTSC.B  430.3
019E0:  BRA     19EC
019E2:  BTSC.B  430.2
019E4:  BRA     19EC
....................       port=0; 
019E6:  CLR     87E
019E8:  GOTO    1A7C
....................    else if (C1TR01CON.txenn && !C1TR01CON.txreqn && !C1TR01CON.rtrenn) 
019EC:  BTSS.B  431.7
019EE:  BRA     1A00
019F0:  BTSC.B  431.3
019F2:  BRA     1A00
019F4:  BTSC.B  431.2
019F6:  BRA     1A00
....................       port=1; 
019F8:  MOV     #1,W4
019FA:  MOV     W4,87E
019FC:  GOTO    1A7C
....................    else if (C1TR23CON.txenm && !C1TR23CON.txreqm && !C1TR23CON.rtrenm) 
01A00:  BTSS.B  432.7
01A02:  BRA     1A14
01A04:  BTSC.B  432.3
01A06:  BRA     1A14
01A08:  BTSC.B  432.2
01A0A:  BRA     1A14
....................       port=2; 
01A0C:  MOV     #2,W4
01A0E:  MOV     W4,87E
01A10:  GOTO    1A7C
....................    else if (C1TR23CON.txenn && !C1TR23CON.txreqn && !C1TR23CON.rtrenn) 
01A14:  BTSS.B  433.7
01A16:  BRA     1A28
01A18:  BTSC.B  433.3
01A1A:  BRA     1A28
01A1C:  BTSC.B  433.2
01A1E:  BRA     1A28
....................       port=3; 
01A20:  MOV     #3,W4
01A22:  MOV     W4,87E
01A24:  GOTO    1A7C
....................    else if (C1TR45CON.txenm && !C1TR45CON.txreqm && !C1TR45CON.rtrenm) 
01A28:  BTSS.B  434.7
01A2A:  BRA     1A3C
01A2C:  BTSC.B  434.3
01A2E:  BRA     1A3C
01A30:  BTSC.B  434.2
01A32:  BRA     1A3C
....................       port=4; 
01A34:  MOV     #4,W4
01A36:  MOV     W4,87E
01A38:  GOTO    1A7C
....................    else if (C1TR45CON.txenn && !C1TR45CON.txreqn && !C1TR45CON.rtrenn) 
01A3C:  BTSS.B  435.7
01A3E:  BRA     1A50
01A40:  BTSC.B  435.3
01A42:  BRA     1A50
01A44:  BTSC.B  435.2
01A46:  BRA     1A50
....................       port=5; 
01A48:  MOV     #5,W4
01A4A:  MOV     W4,87E
01A4C:  GOTO    1A7C
....................    else if (C1TR67CON.txenm && !C1TR67CON.txreqm && !C1TR67CON.rtrenm) 
01A50:  BTSS.B  436.7
01A52:  BRA     1A64
01A54:  BTSC.B  436.3
01A56:  BRA     1A64
01A58:  BTSC.B  436.2
01A5A:  BRA     1A64
....................       port=6; 
01A5C:  MOV     #6,W4
01A5E:  MOV     W4,87E
01A60:  GOTO    1A7C
....................    else if (C1TR67CON.txenn && !C1TR67CON.txreqn && !C1TR67CON.rtrenn) 
01A64:  BTSS.B  437.7
01A66:  BRA     1A78
01A68:  BTSC.B  437.3
01A6A:  BRA     1A78
01A6C:  BTSC.B  437.2
01A6E:  BRA     1A78
....................       port=7; 
01A70:  MOV     #7,W4
01A72:  MOV     W4,87E
01A74:  GOTO    1A7C
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
01A78:  CLR.B   0
01A7A:  BRA     1C8E
....................    } 
....................     
....................    // load data into correct buffer 
....................    if(ext) 
01A7C:  CP0.B   878
01A7E:  BRA     Z,1B1A
....................    { 
....................       temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
01A80:  CLR     W5
01A82:  MOV     #1FFC,W0
01A84:  AND     872,W0
01A86:  MOV     W0,W6
01A88:  MOV     W6,W5
01A8A:  MOV     #0,W6
01A8C:  MOV.B   879,W0L
01A8E:  MOV.B   W0L,W7L
01A90:  CLR.B   F
01A92:  SL      W7,#1,W7
01A94:  MOV.B   878,W0L
01A96:  CLR.B   1
01A98:  IOR      W7,  W0,W0
01A9A:  IOR      W5,  W0,W5
01A9C:  MOV     #1FFF,W0
01A9E:  AND     W0,W5,W0
01AA0:  MOV     W0,880
....................       ecan1_message_buffer[port][0]=temp; 
01AA2:  MOV     87E,W5
01AA4:  SL      W5,#4,W5
01AA6:  MOV     #2000,W4
01AA8:  ADD     W5,W4,W6
01AAA:  MOV     880,W4
01AAC:  MOV     W4,[W6+#0]
....................       temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
01AAE:  MOV     #FFC0,W0
01AB0:  AND     870,W0
01AB2:  MOV     W0,W5
01AB4:  MOV     872,W0
01AB6:  AND     W0,#3,W6
01AB8:  MOV     #6,W4
01ABA:  INC     W4,W4
01ABC:  DEC     W4,W4
01ABE:  BRA     Z,1AC6
01AC0:  LSR     W6,W6
01AC2:  RRC     W5,W5
01AC4:  BRA     1ABC
01AC6:  MOV     #FFF,W0
01AC8:  AND     W0,W5,W0
01ACA:  MOV     W0,880
....................       ecan1_message_buffer[port][1]=temp; 
01ACC:  MOV     87E,W5
01ACE:  SL      W5,#4,W5
01AD0:  ADD     W5,#2,W5
01AD2:  MOV     W5,W0
01AD4:  MOV     #2000,W4
01AD6:  ADD     W0,W4,W5
01AD8:  MOV     880,W4
01ADA:  MOV     W4,[W5+#0]
....................       temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
01ADC:  MOV     870,W5
01ADE:  AND     #3F,W5
01AE0:  CLR     W6
01AE2:  MOV     #A,W4
01AE4:  INC     W4,W4
01AE6:  DEC     W4,W4
01AE8:  BRA     Z,1AF0
01AEA:  SL      W5,W5
01AEC:  RLC     W6,W6
01AEE:  BRA     1AE6
01AF0:  MOV.B   879,W0L
01AF2:  MOV.B   W0L,W7L
01AF4:  CLR.B   F
01AF6:  SL      W7,#9,W7
01AF8:  MOV.B   876,W0L
01AFA:  CLR.B   1
01AFC:  IOR      W7,  W0,W0
01AFE:  IOR      W5,  W0,W5
01B00:  MOV     #FF1F,W0
01B02:  AND     W0,W5,W0
01B04:  MOV     W0,880
....................       ecan1_message_buffer[port][2]=temp; 
01B06:  MOV     87E,W5
01B08:  SL      W5,#4,W5
01B0A:  ADD     W5,#4,W5
01B0C:  MOV     W5,W0
01B0E:  MOV     #2000,W4
01B10:  ADD     W0,W4,W5
01B12:  MOV     880,W4
01B14:  MOV     W4,[W5+#0]
....................    } 
01B16:  GOTO    1B88
....................    else 
....................    {   
....................       temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
01B1A:  MOV     #7FF,W0
01B1C:  AND     870,W0
01B1E:  MOV     W0,W5
01B20:  CLR     W6
01B22:  MOV     #2,W4
01B24:  INC     W4,W4
01B26:  DEC     W4,W4
01B28:  BRA     Z,1B30
01B2A:  SL      W5,W5
01B2C:  RLC     W6,W6
01B2E:  BRA     1B26
01B30:  MOV.B   879,W0L
01B32:  MOV.B   W0L,W7L
01B34:  CLR.B   F
01B36:  SL      W7,#1,W7
01B38:  MOV.B   878,W0L
01B3A:  CLR.B   1
01B3C:  IOR      W7,  W0,W0
01B3E:  IOR      W5,  W0,W5
01B40:  MOV     #1FFF,W0
01B42:  AND     W0,W5,W0
01B44:  MOV     W0,880
....................       ecan1_message_buffer[port][0]=temp; 
01B46:  MOV     87E,W5
01B48:  SL      W5,#4,W5
01B4A:  MOV     #2000,W4
01B4C:  ADD     W5,W4,W6
01B4E:  MOV     880,W4
01B50:  MOV     W4,[W6+#0]
....................       ecan1_message_buffer[port][1]=0x0000; 
01B52:  MOV     87E,W5
01B54:  SL      W5,#4,W5
01B56:  ADD     W5,#2,W5
01B58:  MOV     W5,W0
01B5A:  MOV     #2000,W4
01B5C:  ADD     W0,W4,W5
01B5E:  CLR.B   [W5]
01B60:  MOV.B   #0,W0L
01B62:  MOV.B   W0L,[W5+#1]
....................       temp=(((uint16_t)rtr << 9) | (uint16_t)len) & 0xFF1F; 
01B64:  MOV.B   879,W0L
01B66:  MOV.B   W0L,W5L
01B68:  CLR.B   B
01B6A:  SL      W5,#9,W5
01B6C:  MOV.B   876,W0L
01B6E:  CLR.B   1
01B70:  IOR      W5,  W0,W5
01B72:  MOV     #FF1F,W0
01B74:  AND     W0,W5,W0
01B76:  MOV     W0,880
....................       ecan1_message_buffer[port][2]=temp; 
01B78:  MOV     87E,W5
01B7A:  SL      W5,#4,W5
01B7C:  ADD     W5,#4,W5
01B7E:  MOV     W5,W0
01B80:  MOV     #2000,W4
01B82:  ADD     W0,W4,W5
01B84:  MOV     880,W4
01B86:  MOV     W4,[W5+#0]
....................    } 
....................     
....................    ptr=&ecan1_message_buffer[port][3]; 
01B88:  MOV     87E,W5
01B8A:  SL      W5,#4,W5
01B8C:  ADD     W5,#6,W5
01B8E:  MOV     W5,W0
01B90:  MOV     #2000,W4
01B92:  ADD     W0,W4,W0
01B94:  MOV     W0,87A
....................    for(i=0;i<len;i+=2) 
01B96:  CLR     87C
01B98:  MOV     87C,W0
01B9A:  MOV     876,W4
01B9C:  CLR.B   9
01B9E:  CP      W4,W0
01BA0:  BRA     LEU,1BE6
....................    { 
....................       if (i+1==len) 
01BA2:  MOV     87C,W4
01BA4:  ADD     W4,#1,W4
01BA6:  MOV     W4,W5
01BA8:  MOV     876,W4
01BAA:  CLR.B   9
01BAC:  CP      W4,W5
01BAE:  BRA     NZ,1BC2
....................          *ptr=make16(0,data[i]); 
01BB0:  MOV     87A,W5
01BB2:  MOV     87C,W0
01BB4:  ADD     874,W0
01BB6:  MOV.B   [W0],W6L
01BB8:  MOV.B   W6L,[W5]
01BBA:  MOV.B   #0,W0L
01BBC:  MOV.B   W0L,[W5+#1]
01BBE:  GOTO    1BDA
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
01BC2:  MOV     87A,W5
01BC4:  MOV     87C,W4
01BC6:  ADD     W4,#1,W4
01BC8:  MOV     W4,W6
01BCA:  MOV     W6,W0
01BCC:  ADD     874,W0
01BCE:  MOV.B   [W0],W7L
01BD0:  MOV     87C,W0
01BD2:  ADD     874,W0
01BD4:  MOV.B   [W0],W8L
01BD6:  MOV.B   W8L,[W5]
01BD8:  MOV.B   W7L,[W5+#1]
....................       ptr++; 
01BDA:  INC2    087A
01BDC:  MOV     87C,W4
01BDE:  ADD     W4,#2,W4
01BE0:  MOV     W4,87C
01BE2:  GOTO    1B98
....................    } 
....................     
....................    switch(port) 
01BE6:  MOV     87E,W0
01BE8:  XOR     #0,W0
01BEA:  BRA     Z,1C0A
01BEC:  XOR     #1,W0
01BEE:  BRA     Z,1C1A
01BF0:  XOR     #3,W0
01BF2:  BRA     Z,1C2A
01BF4:  XOR     #1,W0
01BF6:  BRA     Z,1C3A
01BF8:  XOR     #7,W0
01BFA:  BRA     Z,1C4A
01BFC:  XOR     #1,W0
01BFE:  BRA     Z,1C5A
01C00:  XOR     #3,W0
01C02:  BRA     Z,1C6A
01C04:  XOR     #1,W0
01C06:  BRA     Z,1C7A
01C08:  BRA     1C8A
....................    { 
....................       case  0: 
....................          C1TR01CON.txmpri=priority;          //set priority DMA buffer 0 
01C0A:  MOV     #FFFC,W0
01C0C:  AND.B   430
01C0E:  MOV.B   877,W0L
01C10:  AND     #3,W0
01C12:  IOR.B   430
....................          C1TR01CON.txreqm=1;                 //enable transmission buffer 0 
01C14:  BSET.B  430.3
....................          break; 
01C16:  GOTO    1C8A
....................       case 1: 
....................          C1TR01CON.txnpri=priority;          //set priority DMA buffer 1 
01C1A:  MOV     #FFFC,W0
01C1C:  AND.B   431
01C1E:  MOV.B   877,W0L
01C20:  AND     #3,W0
01C22:  IOR.B   431
....................          C1TR01CON.txreqn=1;                 //enable transmission buffer 1 
01C24:  BSET.B  431.3
....................          break; 
01C26:  GOTO    1C8A
....................       case 2: 
....................          C1TR23CON.txmpri=priority;          //set priority DMA buffer 2 
01C2A:  MOV     #FFFC,W0
01C2C:  AND.B   432
01C2E:  MOV.B   877,W0L
01C30:  AND     #3,W0
01C32:  IOR.B   432
....................          C1TR23CON.txreqm=1;                 //enable transmission buffer 2 
01C34:  BSET.B  432.3
....................          break; 
01C36:  GOTO    1C8A
....................       case 3: 
....................          C1TR23CON.txnpri=priority;          //set priority DMA buffer 3 
01C3A:  MOV     #FFFC,W0
01C3C:  AND.B   433
01C3E:  MOV.B   877,W0L
01C40:  AND     #3,W0
01C42:  IOR.B   433
....................          C1TR23CON.txreqn=1;                 //enable transmission buffer 3 
01C44:  BSET.B  433.3
....................          break; 
01C46:  GOTO    1C8A
....................       case 4: 
....................          C1TR45CON.txmpri=priority;          //set priority DMA buffer 4 
01C4A:  MOV     #FFFC,W0
01C4C:  AND.B   434
01C4E:  MOV.B   877,W0L
01C50:  AND     #3,W0
01C52:  IOR.B   434
....................          C1TR45CON.txreqm=1;                 //enable transmission buffer 4 
01C54:  BSET.B  434.3
....................          break; 
01C56:  GOTO    1C8A
....................       case 5: 
....................          C1TR45CON.txnpri=priority;          //set priority DMA buffer 5 
01C5A:  MOV     #FFFC,W0
01C5C:  AND.B   435
01C5E:  MOV.B   877,W0L
01C60:  AND     #3,W0
01C62:  IOR.B   435
....................          C1TR45CON.txreqn=1;                 //enable transmission buffer 5 
01C64:  BSET.B  435.3
....................          break; 
01C66:  GOTO    1C8A
....................       case 6: 
....................          C1TR67CON.txmpri=priority;          //set priority DMA buffer 6 
01C6A:  MOV     #FFFC,W0
01C6C:  AND.B   436
01C6E:  MOV.B   877,W0L
01C70:  AND     #3,W0
01C72:  IOR.B   436
....................          C1TR67CON.txreqm=1;                 //enable transmission buffer 6 
01C74:  BSET.B  436.3
....................          break; 
01C76:  GOTO    1C8A
....................       case 7: 
....................          C1TR67CON.txnpri=priority;          //set priority DMA buffer 7 
01C7A:  MOV     #FFFC,W0
01C7C:  AND.B   437
01C7E:  MOV.B   877,W0L
01C80:  AND     #3,W0
01C82:  IOR.B   437
....................          C1TR67CON.txreqn=1;                 //enable transmission buffer 7 
01C84:  BSET.B  437.3
....................          break; 
01C86:  GOTO    1C8A
....................    } 
....................         
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif  
....................  
....................    return(1); 
01C8A:  MOV.B   #1,W0L
01C8C:  MOV.B   W0L,0
01C8E:  MOV     [--W15],W8
01C90:  MOV     [--W15],W7
01C92:  MOV     [--W15],W6
01C94:  MOV     [--W15],W5
01C96:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t priority, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t *ptr; 
....................       uint16_t i; 
....................       uint16_t port; 
....................       uint16_t temp; 
....................           
....................        // find empty transmitter 
....................       if (C2TR01CON.txenm && !C2TR01CON.txreqm && !C2TR01CON.rtrenm) 
....................          port=0; 
....................       else if (C2TR01CON.txenn && !C2TR01CON.txreqn && !C2TR01CON.rtrenn) 
....................          port=1; 
....................       else if (C2TR23CON.txenm && !C2TR23CON.txreqm && !C2TR23CON.rtrenm) 
....................          port=2; 
....................       else if (C2TR23CON.txenn && !C2TR23CON.txreqn && !C2TR23CON.rtrenn) 
....................          port=3; 
....................       else if (C2TR45CON.txenm && !C2TR45CON.txreqm && !C2TR45CON.rtrenm) 
....................          port=4; 
....................       else if (C2TR45CON.txenn && !C2TR45CON.txreqn && !C2TR45CON.rtrenn) 
....................          port=5; 
....................       else if (C2TR67CON.txenm && !C2TR67CON.txreqm && !C2TR67CON.rtrenm) 
....................          port=6; 
....................       else if (C2TR67CON.txenn && !C2TR67CON.txreqn && !C2TR67CON.rtrenn) 
....................          port=7; 
....................       else { 
....................          #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN2_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................          #endif 
....................          return(0); 
....................       } 
....................        
....................       // load data into correct buffer 
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[port][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan2_message_buffer[port][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan2_message_buffer[port][2]=temp; 
....................       } 
....................       else 
....................       {   
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[port][0]=temp; 
....................          ecan2_message_buffer[port][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len) & 0xFF1F; 
....................          ecan2_message_buffer[port][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan2_message_buffer[port][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       switch(port) 
....................       { 
....................          case  0: 
....................             C2TR01CON.txmpri=priority;          //set priority DMA buffer 0 
....................             C2TR01CON.txreqm=1;                 //enable transmission buffer 0 
....................             break; 
....................          case 1: 
....................             C2TR01CON.txnpri=priority;          //set priority DMA buffer 1 
....................             C2TR01CON.txreqn=1;                 //enable transmission buffer 1 
....................             break; 
....................          case 2: 
....................             C2TR23CON.txmpri=priority;          //set priority DMA buffer 2 
....................             C2TR23CON.txreqm=1;                 //enable transmission buffer 2 
....................             break; 
....................          case 3: 
....................             C2TR23CON.txnpri=priority;          //set priority DMA buffer 3 
....................             C2TR23CON.txreqn=1;                 //enable transmission buffer 3 
....................             break; 
....................          case 4: 
....................             C2TR45CON.txmpri=priority;          //set priority DMA buffer 4 
....................             C2TR45CON.txreqm=1;                 //enable transmission buffer 4 
....................             break; 
....................          case 5: 
....................             C2TR45CON.txnpri=priority;          //set priority DMA buffer 5 
....................             C2TR45CON.txreqn=1;                 //enable transmission buffer 5 
....................             break; 
....................          case 6: 
....................             C2TR67CON.txmpri=priority;          //set priority DMA buffer 6 
....................             C2TR67CON.txreqm=1;                 //enable transmission buffer 6 
....................             break; 
....................          case 7: 
....................             C2TR67CON.txnpri=priority;          //set priority DMA buffer 7 
....................             C2TR67CON.txreqn=1;                 //enable transmission buffer 7 
....................             break; 
....................       } 
....................            
....................       #if CAN_DO_DEBUG 
....................                can_debug("\r\nCAN2_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................                if ((len)&&(!rtr)) { 
....................                   can_debug("  DATA = "); 
....................                   for (i=0;i<len;i++) { 
....................                      can_debug("%X ",*data); 
....................                      data++; 
....................                   } 
....................                   can_debug("\r\n"); 
....................                } 
....................       #endif  
....................     
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // can2_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Parameters: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................    int1 temp; 
....................                
....................    if (C1RXFUL1.rxful0) 
*
00DFC:  BTSS.B  420.0
00DFE:  BRA     E0E
....................    { 
....................       stat.buffer=0; 
00E00:  CLR.B   85D
....................       stat.err_ovfl=C1RXOVF1.rxovf0; 
00E02:  BCLR.B  85E.0
00E04:  BTSC.B  428.0
00E06:  BSET.B  85E.0
....................       C1RXOVF1.rxovf0=0; 
00E08:  BCLR.B  428.0
....................    } 
00E0A:  GOTO    107E
....................    else if (C1RXFUL1.rxful1) 
00E0E:  BTSS.B  420.1
00E10:  BRA     E22
....................    { 
....................       stat.buffer=1; 
00E12:  MOV.B   #1,W0L
00E14:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf1; 
00E16:  BCLR.B  85E.0
00E18:  BTSC.B  428.1
00E1A:  BSET.B  85E.0
....................       C1RXOVF1.rxovf1=0; 
00E1C:  BCLR.B  428.1
....................    } 
00E1E:  GOTO    107E
....................    else if (C1RXFUL1.rxful2) 
00E22:  BTSS.B  420.2
00E24:  BRA     E36
....................    { 
....................       stat.buffer=2; 
00E26:  MOV.B   #2,W0L
00E28:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf2; 
00E2A:  BCLR.B  85E.0
00E2C:  BTSC.B  428.2
00E2E:  BSET.B  85E.0
....................       C1RXOVF1.rxovf2=0; 
00E30:  BCLR.B  428.2
....................    } 
00E32:  GOTO    107E
....................    else if (C1RXFUL1.rxful3) 
00E36:  BTSS.B  420.3
00E38:  BRA     E4A
....................    { 
....................       stat.buffer=3; 
00E3A:  MOV.B   #3,W0L
00E3C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf3; 
00E3E:  BCLR.B  85E.0
00E40:  BTSC.B  428.3
00E42:  BSET.B  85E.0
....................       C1RXOVF1.rxovf3=0; 
00E44:  BCLR.B  428.3
....................    } 
00E46:  GOTO    107E
....................    else if (C1RXFUL1.rxful4) 
00E4A:  BTSS.B  420.4
00E4C:  BRA     E5E
....................    { 
....................       stat.buffer=4; 
00E4E:  MOV.B   #4,W0L
00E50:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf4; 
00E52:  BCLR.B  85E.0
00E54:  BTSC.B  428.4
00E56:  BSET.B  85E.0
....................       C1RXOVF1.rxovf4=0; 
00E58:  BCLR.B  428.4
....................    } 
00E5A:  GOTO    107E
....................    else if (C1RXFUL1.rxful5) 
00E5E:  BTSS.B  420.5
00E60:  BRA     E72
....................    { 
....................       stat.buffer=5; 
00E62:  MOV.B   #5,W0L
00E64:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf5; 
00E66:  BCLR.B  85E.0
00E68:  BTSC.B  428.5
00E6A:  BSET.B  85E.0
....................       C1RXOVF1.rxovf5=0; 
00E6C:  BCLR.B  428.5
....................    }    
00E6E:  GOTO    107E
....................    else if (C1RXFUL1.rxful6) 
00E72:  BTSS.B  420.6
00E74:  BRA     E86
....................    { 
....................       stat.buffer=6; 
00E76:  MOV.B   #6,W0L
00E78:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf6; 
00E7A:  BCLR.B  85E.0
00E7C:  BTSC.B  428.6
00E7E:  BSET.B  85E.0
....................       C1RXOVF1.rxovf6=0; 
00E80:  BCLR.B  428.6
....................    } 
00E82:  GOTO    107E
....................    else if (C1RXFUL1.rxful7) 
00E86:  BTSS.B  420.7
00E88:  BRA     E9A
....................    { 
....................       stat.buffer=7; 
00E8A:  MOV.B   #7,W0L
00E8C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf7; 
00E8E:  BCLR.B  85E.0
00E90:  BTSC.B  428.7
00E92:  BSET.B  85E.0
....................       C1RXOVF1.rxovf7=0; 
00E94:  BCLR.B  428.7
....................    } 
00E96:  GOTO    107E
....................    else if (C1RXFUL1.rxful8) 
00E9A:  BTSS.B  421.0
00E9C:  BRA     EAE
....................    { 
....................       stat.buffer=8; 
00E9E:  MOV.B   #8,W0L
00EA0:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf8; 
00EA2:  BCLR.B  85E.0
00EA4:  BTSC.B  429.0
00EA6:  BSET.B  85E.0
....................       C1RXOVF1.rxovf8=0; 
00EA8:  BCLR.B  429.0
....................    } 
00EAA:  GOTO    107E
....................    else if (C1RXFUL1.rxful9) 
00EAE:  BTSS.B  421.1
00EB0:  BRA     EC2
....................    { 
....................       stat.buffer=9; 
00EB2:  MOV.B   #9,W0L
00EB4:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf9; 
00EB6:  BCLR.B  85E.0
00EB8:  BTSC.B  429.1
00EBA:  BSET.B  85E.0
....................       C1RXOVF1.rxovf9=0; 
00EBC:  BCLR.B  429.1
....................    } 
00EBE:  GOTO    107E
....................    else if (C1RXFUL1.rxful10) 
00EC2:  BTSS.B  421.2
00EC4:  BRA     ED6
....................    { 
....................       stat.buffer=10; 
00EC6:  MOV.B   #A,W0L
00EC8:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf10; 
00ECA:  BCLR.B  85E.0
00ECC:  BTSC.B  429.2
00ECE:  BSET.B  85E.0
....................       C1RXOVF1.rxovf10=0; 
00ED0:  BCLR.B  429.2
....................    } 
00ED2:  GOTO    107E
....................    else if (C1RXFUL1.rxful11) 
00ED6:  BTSS.B  421.3
00ED8:  BRA     EEA
....................    { 
....................       stat.buffer=11; 
00EDA:  MOV.B   #B,W0L
00EDC:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf11; 
00EDE:  BCLR.B  85E.0
00EE0:  BTSC.B  429.3
00EE2:  BSET.B  85E.0
....................       C1RXOVF1.rxovf11=0; 
00EE4:  BCLR.B  429.3
....................    } 
00EE6:  GOTO    107E
....................    else if (C1RXFUL1.rxful12) 
00EEA:  BTSS.B  421.4
00EEC:  BRA     EFE
....................    { 
....................       stat.buffer=12; 
00EEE:  MOV.B   #C,W0L
00EF0:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf12; 
00EF2:  BCLR.B  85E.0
00EF4:  BTSC.B  429.4
00EF6:  BSET.B  85E.0
....................       C1RXOVF1.rxovf12=0; 
00EF8:  BCLR.B  429.4
....................    } 
00EFA:  GOTO    107E
....................    else if (C1RXFUL1.rxful13) 
00EFE:  BTSS.B  421.5
00F00:  BRA     F12
....................    { 
....................       stat.buffer=13; 
00F02:  MOV.B   #D,W0L
00F04:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf13; 
00F06:  BCLR.B  85E.0
00F08:  BTSC.B  429.5
00F0A:  BSET.B  85E.0
....................       C1RXOVF1.rxovf13=0; 
00F0C:  BCLR.B  429.5
....................    } 
00F0E:  GOTO    107E
....................    else if (C1RXFUL1.rxful14) 
00F12:  BTSS.B  421.6
00F14:  BRA     F26
....................    { 
....................       stat.buffer=14; 
00F16:  MOV.B   #E,W0L
00F18:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf14; 
00F1A:  BCLR.B  85E.0
00F1C:  BTSC.B  429.6
00F1E:  BSET.B  85E.0
....................       C1RXOVF1.rxovf14=0; 
00F20:  BCLR.B  429.6
....................    } 
00F22:  GOTO    107E
....................    else if (C1RXFUL1.rxful15) 
00F26:  BTSS.B  421.7
00F28:  BRA     F3A
....................    { 
....................       stat.buffer=15; 
00F2A:  MOV.B   #F,W0L
00F2C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF1.rxovf15; 
00F2E:  BCLR.B  85E.0
00F30:  BTSC.B  429.7
00F32:  BSET.B  85E.0
....................       C1RXOVF1.rxovf15=0; 
00F34:  BCLR.B  429.7
....................    } 
00F36:  GOTO    107E
....................    else if (C1RXFUL2.rxful16) 
00F3A:  BTSS.B  422.0
00F3C:  BRA     F4E
....................    { 
....................       stat.buffer=16; 
00F3E:  MOV.B   #10,W0L
00F40:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf16; 
00F42:  BCLR.B  85E.0
00F44:  BTSC.B  42A.0
00F46:  BSET.B  85E.0
....................       C1RXOVF2.rxovf16=0; 
00F48:  BCLR.B  42A.0
....................    } 
00F4A:  GOTO    107E
....................    else if (C1RXFUL2.rxful17) 
00F4E:  BTSS.B  422.1
00F50:  BRA     F62
....................    { 
....................       stat.buffer=17; 
00F52:  MOV.B   #11,W0L
00F54:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf17; 
00F56:  BCLR.B  85E.0
00F58:  BTSC.B  42A.1
00F5A:  BSET.B  85E.0
....................       C1RXOVF2.rxovf17=0; 
00F5C:  BCLR.B  42A.1
....................    } 
00F5E:  GOTO    107E
....................    else if (C1RXFUL2.rxful18) 
00F62:  BTSS.B  422.2
00F64:  BRA     F76
....................    { 
....................       stat.buffer=18; 
00F66:  MOV.B   #12,W0L
00F68:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf18; 
00F6A:  BCLR.B  85E.0
00F6C:  BTSC.B  42A.2
00F6E:  BSET.B  85E.0
....................       C1RXOVF2.rxovf18=0; 
00F70:  BCLR.B  42A.2
....................    } 
00F72:  GOTO    107E
....................    else if (C1RXFUL2.rxful19) 
00F76:  BTSS.B  422.3
00F78:  BRA     F8A
....................    { 
....................       stat.buffer=19; 
00F7A:  MOV.B   #13,W0L
00F7C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf19; 
00F7E:  BCLR.B  85E.0
00F80:  BTSC.B  42A.3
00F82:  BSET.B  85E.0
....................       C1RXOVF2.rxovf19=0; 
00F84:  BCLR.B  42A.3
....................    } 
00F86:  GOTO    107E
....................    else if (C1RXFUL2.rxful20) 
00F8A:  BTSS.B  422.4
00F8C:  BRA     F9E
....................    { 
....................       stat.buffer=20; 
00F8E:  MOV.B   #14,W0L
00F90:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf20; 
00F92:  BCLR.B  85E.0
00F94:  BTSC.B  42A.4
00F96:  BSET.B  85E.0
....................       C1RXOVF2.rxovf20=0; 
00F98:  BCLR.B  42A.4
....................    } 
00F9A:  GOTO    107E
....................    else if (C1RXFUL2.rxful21) 
00F9E:  BTSS.B  422.5
00FA0:  BRA     FB2
....................    { 
....................       stat.buffer=21; 
00FA2:  MOV.B   #15,W0L
00FA4:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf21; 
00FA6:  BCLR.B  85E.0
00FA8:  BTSC.B  42A.5
00FAA:  BSET.B  85E.0
....................       C1RXOVF2.rxovf21=0; 
00FAC:  BCLR.B  42A.5
....................    } 
00FAE:  GOTO    107E
....................    else if (C1RXFUL2.rxful22) 
00FB2:  BTSS.B  422.6
00FB4:  BRA     FC6
....................    { 
....................       stat.buffer=22; 
00FB6:  MOV.B   #16,W0L
00FB8:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf22; 
00FBA:  BCLR.B  85E.0
00FBC:  BTSC.B  42A.6
00FBE:  BSET.B  85E.0
....................       C1RXOVF2.rxovf22=0; 
00FC0:  BCLR.B  42A.6
....................    } 
00FC2:  GOTO    107E
....................    else if (C1RXFUL2.rxful23) 
00FC6:  BTSS.B  422.7
00FC8:  BRA     FDA
....................    { 
....................       stat.buffer=23; 
00FCA:  MOV.B   #17,W0L
00FCC:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf23; 
00FCE:  BCLR.B  85E.0
00FD0:  BTSC.B  42A.7
00FD2:  BSET.B  85E.0
....................       C1RXOVF2.rxovf23=0; 
00FD4:  BCLR.B  42A.7
....................    } 
00FD6:  GOTO    107E
....................    else if (C1RXFUL2.rxful24) 
00FDA:  BTSS.B  423.0
00FDC:  BRA     FEE
....................    { 
....................       stat.buffer=24; 
00FDE:  MOV.B   #18,W0L
00FE0:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf24; 
00FE2:  BCLR.B  85E.0
00FE4:  BTSC.B  42B.0
00FE6:  BSET.B  85E.0
....................       C1RXOVF2.rxovf24=0; 
00FE8:  BCLR.B  42B.0
....................    } 
00FEA:  GOTO    107E
....................    else if (C1RXFUL2.rxful25) 
00FEE:  BTSS.B  423.1
00FF0:  BRA     1002
....................    { 
....................       stat.buffer=25; 
00FF2:  MOV.B   #19,W0L
00FF4:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf25; 
00FF6:  BCLR.B  85E.0
00FF8:  BTSC.B  42B.1
00FFA:  BSET.B  85E.0
....................       C1RXOVF2.rxovf25=0; 
00FFC:  BCLR.B  42B.1
....................    } 
00FFE:  GOTO    107E
....................    else if (C1RXFUL2.rxful26) 
01002:  BTSS.B  423.2
01004:  BRA     1016
....................    { 
....................       stat.buffer=26; 
01006:  MOV.B   #1A,W0L
01008:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf26; 
0100A:  BCLR.B  85E.0
0100C:  BTSC.B  42B.2
0100E:  BSET.B  85E.0
....................       C1RXOVF2.rxovf26=0; 
01010:  BCLR.B  42B.2
....................    } 
01012:  GOTO    107E
....................    else if (C1RXFUL2.rxful27) 
01016:  BTSS.B  423.3
01018:  BRA     102A
....................    { 
....................       stat.buffer=27; 
0101A:  MOV.B   #1B,W0L
0101C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf27; 
0101E:  BCLR.B  85E.0
01020:  BTSC.B  42B.3
01022:  BSET.B  85E.0
....................       C1RXOVF2.rxovf27=0; 
01024:  BCLR.B  42B.3
....................    } 
01026:  GOTO    107E
....................    else if (C1RXFUL2.rxful28) 
0102A:  BTSS.B  423.4
0102C:  BRA     103E
....................    { 
....................       stat.buffer=28; 
0102E:  MOV.B   #1C,W0L
01030:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf28; 
01032:  BCLR.B  85E.0
01034:  BTSC.B  42B.4
01036:  BSET.B  85E.0
....................       C1RXOVF2.rxovf28=0; 
01038:  BCLR.B  42B.4
....................    } 
0103A:  GOTO    107E
....................    else if (C1RXFUL2.rxful29) 
0103E:  BTSS.B  423.5
01040:  BRA     1052
....................    { 
....................       stat.buffer=29; 
01042:  MOV.B   #1D,W0L
01044:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf29; 
01046:  BCLR.B  85E.0
01048:  BTSC.B  42B.5
0104A:  BSET.B  85E.0
....................       C1RXOVF2.rxovf29=0; 
0104C:  BCLR.B  42B.5
....................    } 
0104E:  GOTO    107E
....................    else if (C1RXFUL2.rxful30) 
01052:  BTSS.B  423.6
01054:  BRA     1066
....................    { 
....................       stat.buffer=30; 
01056:  MOV.B   #1E,W0L
01058:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf30; 
0105A:  BCLR.B  85E.0
0105C:  BTSC.B  42B.6
0105E:  BSET.B  85E.0
....................       C1RXOVF2.rxovf30=0; 
01060:  BCLR.B  42B.6
....................    } 
01062:  GOTO    107E
....................    else if (C1RXFUL2.rxful31) 
01066:  BTSS.B  423.7
01068:  BRA     107A
....................    { 
....................       stat.buffer=31; 
0106A:  MOV.B   #1F,W0L
0106C:  MOV.B   W0L,85D
....................       stat.err_ovfl=C1RXOVF2.rxovf31; 
0106E:  BCLR.B  85E.0
01070:  BTSC.B  42B.7
01072:  BSET.B  85E.0
....................       C1RXOVF2.rxovf31=0; 
01074:  BCLR.B  42B.7
....................    } 
01076:  GOTO    107E
....................    else 
....................     { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
0107A:  CLR.B   0
0107C:  BRA     12A2
....................     } 
....................     
....................    C1INTF.rbif=0; 
0107E:  BCLR.B  40A.1
....................     
....................    ptr=&ecan1_message_buffer[stat.buffer][0]; 
01080:  MOV.B   85D,W0L
01082:  CLR.B   1
01084:  SL      W0,#4,W5
01086:  MOV     #2000,W4
01088:  ADD     W5,W4,W0
0108A:  MOV     W0,8D4
....................    stat.ext=(*ptr & 0x1); 
0108C:  MOV     8D4,W0
0108E:  MOV     [W0],W5
01090:  AND     W5,#1,W0
01092:  BCLR.B  85E.2
01094:  BTSC.B  0.0
01096:  BSET.B  85E.2
....................    temp=(*ptr & 0x1); 
01098:  MOV     8D4,W0
0109A:  MOV     [W0],W5
0109C:  AND     W5,#1,W0
0109E:  BCLR.B  8D6.0
010A0:  BTSC.B  0.0
010A2:  BSET.B  8D6.0
....................       
....................    ptr+=2; 
010A4:  MOV     8D4,W4
010A6:  ADD     W4,#4,W4
010A8:  MOV     W4,8D4
....................    len=(*ptr & 0xF); 
010AA:  MOV     8D4,W0
010AC:  MOV     [W0],W5
010AE:  AND.B   W5L,#F,W0L
010B0:  MOV.B   W0L,857
....................    stat.rtr=((make8(*ptr,1) & 0x2) >> 1); 
010B2:  MOV     8D4,W0
010B4:  MOV     [W0],W5
010B6:  MOV.B   B,W0L
010B8:  MOV.B   W0L,W0L
010BA:  CLR.B   1
010BC:  AND     W0,#2,W6
010BE:  LSR     W6,#1,W0
010C0:  BCLR.B  85E.1
010C2:  BTSC.B  0.0
010C4:  BSET.B  85E.1
....................     
....................    ptr+=5; 
010C6:  MOV     8D4,W4
010C8:  ADD     W4,#A,W4
010CA:  MOV     W4,8D4
....................    stat.filthit=(make8(*ptr,1) & 0x1F); 
010CC:  MOV     8D4,W0
010CE:  MOV     [W0],W5
010D0:  MOV.B   B,W0L
010D2:  MOV.B   W0L,W0L
010D4:  AND.B   W0L,#1F,W0L
010D6:  MOV.B   W0L,85C
....................        
....................    id=can_get_id(stat.buffer,temp); 
010D8:  CLR     W0
010DA:  BTSC.B  8D6.0
010DC:  INC     W0,W0
010DE:  MOV.B   W0L,W5L
010E0:  MOV     W0,[W15++]
010E2:  MOV.B   85D,W0L
010E4:  MOV.B   W0L,8E6
010E6:  MOV     [--W15],W0
010E8:  PUSH    8E6
010EA:  MOV.B   W5L,[W15-#1]
010EC:  POP     8E6
010EE:  CALL    D60
010F2:  MOV     W0,860
010F4:  MOV     W1,862
....................     
....................    ptr=&ecan1_message_buffer[stat.buffer][3]; 
010F6:  MOV.B   85D,W0L
010F8:  CLR.B   1
010FA:  SL      W0,#4,W5
010FC:  ADD     W5,#6,W5
010FE:  MOV     W5,W0
01100:  MOV     #2000,W4
01102:  ADD     W0,W4,W0
01104:  MOV     W0,8D4
....................    for(i=0;i<len;i+=2) 
01106:  CLR     8D2
01108:  MOV.B   857,W0L
0110A:  CLR.B   1
0110C:  MOV     8D2,W4
0110E:  CP      W4,W0
01110:  BRA     C,1150
....................    { 
....................       data[i]=make8(*ptr,0); 
01112:  MOV     8D2,W0
01114:  ADD     8D0,W0
01116:  MOV     W0,W5
01118:  MOV     8D4,W0
0111A:  MOV     [W0],W6
0111C:  MOV.B   W6L,W0L
0111E:  MOV.B   W0L,[W5]
....................       if (i+1!=len) 
01120:  MOV     8D2,W4
01122:  ADD     W4,#1,W4
01124:  MOV     W4,W5
01126:  MOV.B   857,W0L
01128:  CLR.B   1
0112A:  CP      W0,W5
0112C:  BRA     Z,1144
....................          data[i+1]=make8(*ptr,1); 
0112E:  MOV     8D2,W4
01130:  ADD     W4,#1,W4
01132:  MOV     W4,W5
01134:  MOV     W5,W0
01136:  ADD     8D0,W0
01138:  MOV     W0,W6
0113A:  MOV     8D4,W0
0113C:  MOV     [W0],W7
0113E:  MOV.B   F,W0L
01140:  MOV.B   W0L,W0L
01142:  MOV.B   W0L,[W6]
....................       ptr++; 
01144:  INC2    08D4
01146:  MOV     8D2,W4
01148:  ADD     W4,#2,W4
0114A:  MOV     W4,8D2
0114C:  GOTO    1108
....................    } 
....................     
....................    stat.inv=C1INTF.ivrif; 
01150:  BCLR.B  85E.3
01152:  BTSC.B  40A.7
01154:  BSET.B  85E.3
....................    C1INTF.ivrif=0; 
01156:  BCLR.B  40A.7
....................     
....................    switch(stat.buffer) 
01158:  MOV.B   85D,W0L
0115A:  CLR.B   1
0115C:  XOR     #0,W0
0115E:  BRA     Z,11DE
01160:  XOR     #1,W0
01162:  BRA     Z,11E4
01164:  XOR     #3,W0
01166:  BRA     Z,11EA
01168:  XOR     #1,W0
0116A:  BRA     Z,11F0
0116C:  XOR     #7,W0
0116E:  BRA     Z,11F6
01170:  XOR     #1,W0
01172:  BRA     Z,11FC
01174:  XOR     #3,W0
01176:  BRA     Z,1202
01178:  XOR     #1,W0
0117A:  BRA     Z,1208
0117C:  XOR     #F,W0
0117E:  BRA     Z,120E
01180:  XOR     #1,W0
01182:  BRA     Z,1214
01184:  XOR     #3,W0
01186:  BRA     Z,121A
01188:  XOR     #1,W0
0118A:  BRA     Z,1220
0118C:  XOR     #7,W0
0118E:  BRA     Z,1226
01190:  XOR     #1,W0
01192:  BRA     Z,122C
01194:  XOR     #3,W0
01196:  BRA     Z,1232
01198:  XOR     #1,W0
0119A:  BRA     Z,1238
0119C:  XOR     #1F,W0
0119E:  BRA     Z,123E
011A0:  XOR     #1,W0
011A2:  BRA     Z,1244
011A4:  XOR     #3,W0
011A6:  BRA     Z,124A
011A8:  XOR     #1,W0
011AA:  BRA     Z,1250
011AC:  XOR     #7,W0
011AE:  BRA     Z,1256
011B0:  XOR     #1,W0
011B2:  BRA     Z,125C
011B4:  XOR     #3,W0
011B6:  BRA     Z,1262
011B8:  XOR     #1,W0
011BA:  BRA     Z,1268
011BC:  XOR     #F,W0
011BE:  BRA     Z,126E
011C0:  XOR     #1,W0
011C2:  BRA     Z,1274
011C4:  XOR     #3,W0
011C6:  BRA     Z,127A
011C8:  XOR     #1,W0
011CA:  BRA     Z,1280
011CC:  XOR     #7,W0
011CE:  BRA     Z,1286
011D0:  XOR     #1,W0
011D2:  BRA     Z,128C
011D4:  XOR     #3,W0
011D6:  BRA     Z,1292
011D8:  XOR     #1,W0
011DA:  BRA     Z,1298
011DC:  BRA     129E
....................    { 
....................       case 0: 
....................          C1RXFUL1.rxful0=0; 
011DE:  BCLR.B  420.0
....................          break; 
011E0:  GOTO    129E
....................       case 1: 
....................          C1RXFUL1.rxful1=0; 
011E4:  BCLR.B  420.1
....................          break; 
011E6:  GOTO    129E
....................       case 2: 
....................          C1RXFUL1.rxful2=0; 
011EA:  BCLR.B  420.2
....................          break; 
011EC:  GOTO    129E
....................       case 3: 
....................          C1RXFUL1.rxful3=0; 
011F0:  BCLR.B  420.3
....................          break; 
011F2:  GOTO    129E
....................       case 4: 
....................          C1RXFUL1.rxful4=0; 
011F6:  BCLR.B  420.4
....................          break; 
011F8:  GOTO    129E
....................       case 5: 
....................          C1RXFUL1.rxful5=0; 
011FC:  BCLR.B  420.5
....................          break; 
011FE:  GOTO    129E
....................       case 6: 
....................          C1RXFUL1.rxful6=0; 
01202:  BCLR.B  420.6
....................          break; 
01204:  GOTO    129E
....................       case 7: 
....................          C1RXFUL1.rxful7=0; 
01208:  BCLR.B  420.7
....................          break; 
0120A:  GOTO    129E
....................       case 8: 
....................          C1RXFUL1.rxful8=0; 
0120E:  BCLR.B  421.0
....................          break; 
01210:  GOTO    129E
....................       case 9: 
....................          C1RXFUL1.rxful9=0; 
01214:  BCLR.B  421.1
....................          break; 
01216:  GOTO    129E
....................       case 10: 
....................          C1RXFUL1.rxful10=0; 
0121A:  BCLR.B  421.2
....................          break; 
0121C:  GOTO    129E
....................       case 11: 
....................          C1RXFUL1.rxful11=0; 
01220:  BCLR.B  421.3
....................          break; 
01222:  GOTO    129E
....................       case 12: 
....................          C1RXFUL1.rxful12=0; 
01226:  BCLR.B  421.4
....................          break; 
01228:  GOTO    129E
....................       case 13: 
....................          C1RXFUL1.rxful13=0; 
0122C:  BCLR.B  421.5
....................          break; 
0122E:  GOTO    129E
....................       case 14: 
....................          C1RXFUL1.rxful14=0; 
01232:  BCLR.B  421.6
....................          break; 
01234:  GOTO    129E
....................       case 15: 
....................          C1RXFUL1.rxful15=0; 
01238:  BCLR.B  421.7
....................          break; 
0123A:  GOTO    129E
....................       case 16: 
....................          C1RXFUL2.rxful16=0; 
0123E:  BCLR.B  422.0
....................          break; 
01240:  GOTO    129E
....................       case 17: 
....................          C1RXFUL2.rxful17=0; 
01244:  BCLR.B  422.1
....................          break; 
01246:  GOTO    129E
....................       case 18: 
....................          C1RXFUL2.rxful18=0; 
0124A:  BCLR.B  422.2
....................          break; 
0124C:  GOTO    129E
....................       case 19: 
....................          C1RXFUL2.rxful19=0; 
01250:  BCLR.B  422.3
....................          break; 
01252:  GOTO    129E
....................       case 20: 
....................          C1RXFUL2.rxful20=0; 
01256:  BCLR.B  422.4
....................          break; 
01258:  GOTO    129E
....................       case 21: 
....................          C1RXFUL2.rxful21=0; 
0125C:  BCLR.B  422.5
....................          break; 
0125E:  GOTO    129E
....................       case 22: 
....................          C1RXFUL2.rxful22=0; 
01262:  BCLR.B  422.6
....................          break; 
01264:  GOTO    129E
....................       case 23: 
....................          C1RXFUL2.rxful23=0; 
01268:  BCLR.B  422.7
....................          break; 
0126A:  GOTO    129E
....................       case 24: 
....................          C1RXFUL2.rxful24=0; 
0126E:  BCLR.B  423.0
....................          break; 
01270:  GOTO    129E
....................       case 25: 
....................          C1RXFUL2.rxful25=0; 
01274:  BCLR.B  423.1
....................          break; 
01276:  GOTO    129E
....................       case 26: 
....................          C1RXFUL2.rxful26=0; 
0127A:  BCLR.B  423.2
....................          break; 
0127C:  GOTO    129E
....................       case 27: 
....................          C1RXFUL2.rxful27=0; 
01280:  BCLR.B  423.3
....................          break; 
01282:  GOTO    129E
....................       case 28: 
....................          C1RXFUL2.rxful28=0; 
01286:  BCLR.B  423.4
....................          break; 
01288:  GOTO    129E
....................       case 29: 
....................          C1RXFUL2.rxful29=0; 
0128C:  BCLR.B  423.5
....................          break; 
0128E:  GOTO    129E
....................       case 30: 
....................          C1RXFUL2.rxful30=0; 
01292:  BCLR.B  423.6
....................          break; 
01294:  GOTO    129E
....................       case 31: 
....................          C1RXFUL2.rxful31=0; 
01298:  BCLR.B  423.7
....................          break; 
0129A:  GOTO    129E
....................    }       
....................     
....................    #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif  
....................      
....................     return(1); 
0129E:  MOV.B   #1,W0L
012A0:  MOV.B   W0L,0
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       int1 temp; 
....................                   
....................       if (C2RXFUL1.rxful0) 
....................       { 
....................          stat.buffer=0; 
....................          stat.err_ovfl=C2RXOVF1.rxovf0; 
....................          C2RXOVF1.rxovf0=0; 
....................       } 
....................       else if (C2RXFUL1.rxful1) 
....................       { 
....................          stat.buffer=1; 
....................          stat.err_ovfl=C2RXOVF1.rxovf1; 
....................          C2RXOVF1.rxovf1=0; 
....................       } 
....................       else if (C2RXFUL1.rxful2) 
....................       { 
....................          stat.buffer=2; 
....................          stat.err_ovfl=C2RXOVF1.rxovf2; 
....................          C2RXOVF1.rxovf2=0; 
....................       } 
....................       else if (C2RXFUL1.rxful3) 
....................       { 
....................          stat.buffer=3; 
....................          stat.err_ovfl=C2RXOVF1.rxovf3; 
....................          C2RXOVF1.rxovf3=0; 
....................       } 
....................       else if (C2RXFUL1.rxful4) 
....................       { 
....................          stat.buffer=4; 
....................          stat.err_ovfl=C2RXOVF1.rxovf4; 
....................          C2RXOVF1.rxovf4=0; 
....................       } 
....................       else if (C2RXFUL1.rxful5) 
....................       { 
....................          stat.buffer=5; 
....................          stat.err_ovfl=C2RXOVF1.rxovf5; 
....................          C2RXOVF1.rxovf5=0; 
....................       }    
....................       else if (C2RXFUL1.rxful6) 
....................       { 
....................          stat.buffer=6; 
....................          stat.err_ovfl=C2RXOVF1.rxovf6; 
....................          C2RXOVF1.rxovf6=0; 
....................       } 
....................       else if (C2RXFUL1.rxful7) 
....................       { 
....................          stat.buffer=7; 
....................          stat.err_ovfl=C2RXOVF1.rxovf7; 
....................          C2RXOVF1.rxovf7=0; 
....................       } 
....................       else if (C2RXFUL1.rxful8) 
....................       { 
....................          stat.buffer=8; 
....................          stat.err_ovfl=C2RXOVF1.rxovf8; 
....................          C2RXOVF1.rxovf8=0; 
....................       } 
....................       else if (C2RXFUL1.rxful9) 
....................       { 
....................          stat.buffer=9; 
....................          stat.err_ovfl=C2RXOVF1.rxovf9; 
....................          C2RXOVF1.rxovf9=0; 
....................       } 
....................       else if (C2RXFUL1.rxful10) 
....................       { 
....................          stat.buffer=10; 
....................          stat.err_ovfl=C2RXOVF1.rxovf10; 
....................          C2RXOVF1.rxovf10=0; 
....................       } 
....................       else if (C2RXFUL1.rxful11) 
....................       { 
....................          stat.buffer=11; 
....................          stat.err_ovfl=C2RXOVF1.rxovf11; 
....................          C2RXOVF1.rxovf11=0; 
....................       } 
....................       else if (C2RXFUL1.rxful12) 
....................       { 
....................          stat.buffer=12; 
....................          stat.err_ovfl=C2RXOVF1.rxovf12; 
....................          C2RXOVF1.rxovf12=0; 
....................       } 
....................       else if (C2RXFUL1.rxful13) 
....................       { 
....................          stat.buffer=13; 
....................          stat.err_ovfl=C2RXOVF1.rxovf13; 
....................          C2RXOVF1.rxovf13=0; 
....................       } 
....................       else if (C2RXFUL1.rxful14) 
....................       { 
....................          stat.buffer=14; 
....................          stat.err_ovfl=C2RXOVF1.rxovf14; 
....................          C2RXOVF1.rxovf14=0; 
....................       } 
....................       else if (C2RXFUL1.rxful15) 
....................       { 
....................          stat.buffer=15; 
....................          stat.err_ovfl=C2RXOVF1.rxovf15; 
....................          C2RXOVF1.rxovf15=0; 
....................       } 
....................       else if (C2RXFUL2.rxful16) 
....................       { 
....................          stat.buffer=16; 
....................          stat.err_ovfl=C2RXOVF2.rxovf16; 
....................          C2RXOVF2.rxovf16=0; 
....................       } 
....................       else if (C2RXFUL2.rxful17) 
....................       { 
....................          stat.buffer=17; 
....................          stat.err_ovfl=C2RXOVF2.rxovf17; 
....................          C2RXOVF2.rxovf17=0; 
....................       } 
....................       else if (C2RXFUL2.rxful18) 
....................       { 
....................          stat.buffer=18; 
....................          stat.err_ovfl=C2RXOVF2.rxovf18; 
....................          C2RXOVF2.rxovf18=0; 
....................       } 
....................       else if (C2RXFUL2.rxful19) 
....................       { 
....................          stat.buffer=19; 
....................          stat.err_ovfl=C2RXOVF2.rxovf19; 
....................          C2RXOVF2.rxovf19=0; 
....................       } 
....................       else if (C2RXFUL2.rxful20) 
....................       { 
....................          stat.buffer=20; 
....................          stat.err_ovfl=C2RXOVF2.rxovf20; 
....................          C2RXOVF2.rxovf20=0; 
....................       } 
....................       else if (C2RXFUL2.rxful21) 
....................       { 
....................          stat.buffer=21; 
....................          stat.err_ovfl=C2RXOVF2.rxovf21; 
....................          C2RXOVF2.rxovf21=0; 
....................       } 
....................       else if (C2RXFUL2.rxful22) 
....................       { 
....................          stat.buffer=22; 
....................          stat.err_ovfl=C2RXOVF2.rxovf22; 
....................          C2RXOVF2.rxovf22=0; 
....................       } 
....................       else if (C2RXFUL2.rxful23) 
....................       { 
....................          stat.buffer=23; 
....................          stat.err_ovfl=C2RXOVF2.rxovf23; 
....................          C2RXOVF2.rxovf23=0; 
....................       } 
....................       else if (C2RXFUL2.rxful24) 
....................       { 
....................          stat.buffer=24; 
....................          stat.err_ovfl=C2RXOVF2.rxovf24; 
....................          C2RXOVF2.rxovf24=0; 
....................       } 
....................       else if (C2RXFUL2.rxful25) 
....................       { 
....................          stat.buffer=25; 
....................          stat.err_ovfl=C2RXOVF2.rxovf25; 
....................          C2RXOVF2.rxovf25=0; 
....................       } 
....................       else if (C2RXFUL2.rxful26) 
....................       { 
....................          stat.buffer=26; 
....................          stat.err_ovfl=C2RXOVF2.rxovf26; 
....................          C2RXOVF2.rxovf26=0; 
....................       } 
....................       else if (C2RXFUL2.rxful27) 
....................       { 
....................          stat.buffer=27; 
....................          stat.err_ovfl=C2RXOVF2.rxovf27; 
....................          C2RXOVF2.rxovf27=0; 
....................       } 
....................       else if (C2RXFUL2.rxful28) 
....................       { 
....................          stat.buffer=28; 
....................          stat.err_ovfl=C2RXOVF2.rxovf28; 
....................          C2RXOVF2.rxovf28=0; 
....................       } 
....................       else if (C2RXFUL2.rxful29) 
....................       { 
....................          stat.buffer=29; 
....................          stat.err_ovfl=C2RXOVF2.rxovf29; 
....................          C2RXOVF2.rxovf29=0; 
....................       } 
....................       else if (C2RXFUL2.rxful30) 
....................       { 
....................          stat.buffer=30; 
....................          stat.err_ovfl=C2RXOVF2.rxovf30; 
....................          C2RXOVF2.rxovf30=0; 
....................       } 
....................       else if (C2RXFUL2.rxful31) 
....................       { 
....................          stat.buffer=31; 
....................          stat.err_ovfl=C2RXOVF2.rxovf31; 
....................          C2RXOVF2.rxovf31=0; 
....................       } 
....................       else 
....................        { 
....................          #if CAN_DO_DEBUG 
....................             can_debug("\r\nFAIL ON CAN2_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................          #endif 
....................          return (0); 
....................        } 
....................        
....................       C2INTF.rbif=0; 
....................        
....................       ptr=&ecan2_message_buffer[stat.buffer][0]; 
....................       stat.ext=(*ptr & 0x1); 
....................       temp=(*ptr & 0x1); 
....................          
....................       ptr+=2; 
....................       len=(*ptr & 0xF); 
....................       stat.rtr=((make8(*ptr,1) & 0x2) >> 1); 
....................        
....................       ptr+=5; 
....................       stat.filthit=(make8(*ptr,1) & 0x1F); 
....................           
....................       id=can2_get_id(stat.buffer,temp); 
....................        
....................       ptr=&ecan2_message_buffer[stat.buffer][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          data[i]=make8(*ptr,0); 
....................          if (i+1!=len) 
....................             data[i+1]=make8(*ptr,1); 
....................          ptr++; 
....................       } 
....................        
....................       stat.inv=C2INTF.ivrif; 
....................       C2INTF.ivrif=0; 
....................        
....................       switch(stat.buffer) 
....................       { 
....................          case 0: 
....................             C2RXFUL1.rxful0=0; 
....................             break; 
....................          case 1: 
....................             C2RXFUL1.rxful1=0; 
....................             break; 
....................          case 2: 
....................             C2RXFUL1.rxful2=0; 
....................             break; 
....................          case 3: 
....................             C2RXFUL1.rxful3=0; 
....................             break; 
....................          case 4: 
....................             C2RXFUL1.rxful4=0; 
....................             break; 
....................          case 5: 
....................             C2RXFUL1.rxful5=0; 
....................             break; 
....................          case 6: 
....................             C2RXFUL1.rxful6=0; 
....................             break; 
....................          case 7: 
....................             C2RXFUL1.rxful7=0; 
....................             break; 
....................          case 8: 
....................             C2RXFUL1.rxful8=0; 
....................             break; 
....................          case 9: 
....................             C2RXFUL1.rxful9=0; 
....................             break; 
....................          case 10: 
....................             C2RXFUL1.rxful10=0; 
....................             break; 
....................          case 11: 
....................             C2RXFUL1.rxful11=0; 
....................             break; 
....................          case 12: 
....................             C2RXFUL1.rxful12=0; 
....................             break; 
....................          case 13: 
....................             C2RXFUL1.rxful13=0; 
....................             break; 
....................          case 14: 
....................             C2RXFUL1.rxful14=0; 
....................             break; 
....................          case 15: 
....................             C2RXFUL1.rxful15=0; 
....................             break; 
....................          case 16: 
....................             C2RXFUL2.rxful16=0; 
....................             break; 
....................          case 17: 
....................             C2RXFUL2.rxful17=0; 
....................             break; 
....................          case 18: 
....................             C2RXFUL2.rxful18=0; 
....................             break; 
....................          case 19: 
....................             C2RXFUL2.rxful19=0; 
....................             break; 
....................          case 20: 
....................             C2RXFUL2.rxful20=0; 
....................             break; 
....................          case 21: 
....................             C2RXFUL2.rxful21=0; 
....................             break; 
....................          case 22: 
....................             C2RXFUL2.rxful22=0; 
....................             break; 
....................          case 23: 
....................             C2RXFUL2.rxful23=0; 
....................             break; 
....................          case 24: 
....................             C2RXFUL2.rxful24=0; 
....................             break; 
....................          case 25: 
....................             C2RXFUL2.rxful25=0; 
....................             break; 
....................          case 26: 
....................             C2RXFUL2.rxful26=0; 
....................             break; 
....................          case 27: 
....................             C2RXFUL2.rxful27=0; 
....................             break; 
....................          case 28: 
....................             C2RXFUL2.rxful28=0; 
....................             break; 
....................          case 29: 
....................             C2RXFUL2.rxful29=0; 
....................             break; 
....................          case 30: 
....................             C2RXFUL2.rxful30=0; 
....................             break; 
....................          case 31: 
....................             C2RXFUL2.rxful31=0; 
....................             break; 
....................       }       
....................        
....................       #if CAN_DO_DEBUG 
....................           can_debug("\r\nCAN2_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................           can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................           if ((len)&&(!stat.rtr)) { 
....................              can_debug("\r\n    DATA = "); 
....................              for (i=0;i<len;i++) { 
....................                can_debug("%X ",*data); 
....................                data++; 
....................              } 
....................           } 
....................           can_debug("\r\n"); 
....................        #endif  
....................         
....................        return(1); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // can2_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer. (The opposite of can_set_buffer_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     buffer - number of specified buffer 
.................... //      enumerated as TRB0-TRB7 and RB8-RB31 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... uint32_t can_get_id(BUFFER buffer, int1 ext) 
*
00D60:  MOV     W5,[W15++]
00D62:  CLR     8E8
00D64:  CLR     8EA
.................... { 
....................    uint32_t ret=0; 
....................    uint16_t *ptr; 
....................    uint16_t temp, temp1; 
....................     
....................    ptr=&ecan1_message_buffer[buffer][2]; 
00D66:  MOV.B   8E6,W0L
00D68:  CLR.B   1
00D6A:  SL      W0,#4,W5
00D6C:  ADD     W5,#4,W5
00D6E:  MOV     W5,W0
00D70:  MOV     #2000,W4
00D72:  ADD     W0,W4,W0
00D74:  MOV     W0,8EC
....................        
....................    if (ext) 
00D76:  CP0.B   8E7
00D78:  BRA     Z,DC2
....................    { 
....................       //EID 
....................       temp=((*ptr & 0xFC00) >> 10)& 0x3F; 
00D7A:  MOV     8EC,W0
00D7C:  MOV     [W0],W5
00D7E:  MOV     #FC00,W0
00D80:  AND     W0,W5,W5
00D82:  LSR     W5,#A,W5
00D84:  MOV     W5,W4
00D86:  AND     #3F,W4
00D88:  MOV     W4,8EE
....................        
....................       ptr-=1; 
00D8A:  MOV     8EC,W4
00D8C:  SUB     W4,#2,W0
00D8E:  MOV     W0,8EC
....................       temp|=((*ptr & 0x3FF) << 6); 
00D90:  MOV     8EC,W0
00D92:  MOV     [W0],W5
00D94:  AND     #3FF,W5
00D96:  SL      W5,#6,W0
00D98:  IOR     8EE
....................       temp1=(*ptr&0xC00)>>10; 
00D9A:  MOV     8EC,W0
00D9C:  MOV     [W0],W5
00D9E:  MOV     #C00,W0
00DA0:  AND     W0,W5,W5
00DA2:  LSR     W5,#A,W0
00DA4:  MOV     W0,8F0
....................        
....................       //SID 
....................       ptr-=1; 
00DA6:  MOV     8EC,W4
00DA8:  SUB     W4,#2,W0
00DAA:  MOV     W0,8EC
....................       temp1|=*ptr&0x1FFC; 
00DAC:  MOV     8EC,W0
00DAE:  MOV     [W0],W5
00DB0:  MOV     #1FFC,W0
00DB2:  AND     W0,W5,W0
00DB4:  IOR     8F0
....................       ret=make32(temp1,temp); 
00DB6:  PUSH    8F0
00DB8:  POP     8EA
00DBA:  PUSH    8EE
00DBC:  POP     8E8
....................    } 
00DBE:  GOTO    DDA
....................    else  
....................    { 
....................       //SID 
....................       ptr-=2; 
00DC2:  MOV     8EC,W4
00DC4:  SUB     W4,#4,W0
00DC6:  MOV     W0,8EC
....................       ret=((*ptr & 0x1FFC) >> 2) & 0x7FF; 
00DC8:  MOV     8EC,W0
00DCA:  MOV     [W0],W5
00DCC:  MOV     #1FFC,W0
00DCE:  AND     W0,W5,W5
00DD0:  LSR     W5,#2,W5
00DD2:  MOV     #7FF,W0
00DD4:  AND     W0,W5,W0
00DD6:  MOV     W0,8E8
00DD8:  CLR     8EA
....................    } 
....................     
....................    return(ret); 
00DDA:  MOV     8E8,W0
00DDC:  MOV     8EA,W1
00DDE:  MOV     [--W15],W5
00DE0:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    uint32_t can2_get_id(BUFFER buffer, int1 ext) 
....................    { 
....................       uint32_t ret=0; 
....................       uint16_t *ptr; 
....................       uint16_t temp, temp1; 
....................        
....................       ptr=&ecan2_message_buffer[buffer][2]; 
....................           
....................       if (ext) 
....................       { 
....................          //EID 
....................          temp=((*ptr & 0xFC00) >> 10)& 0x3F; 
....................           
....................          ptr-=1; 
....................          temp|=((*ptr & 0x3FF) << 6); 
....................          temp1=(*ptr&0xC00)>>10; 
....................           
....................          //SID 
....................          ptr-=1; 
....................          temp1|=*ptr&0x1FFC; 
....................          ret=make32(temp1,temp); 
....................       } 
....................       else  
....................       { 
....................          //SID 
....................          ptr-=2; 
....................          ret=((*ptr & 0x1FFC) >> 2) & 0x7FF; 
....................       } 
....................        
....................       return(ret); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_transfer() 
.................... // can2_enable_b_transfer() 
.................... // 
.................... // Sets one of the 8 programmable buffers to be a transfer buffer, and sets the  
.................... // start of the FIFO buffer to be the first buffer after the highest buffer set  
.................... // as a transmit buffer.  
.................... // 
.................... // Parameters: 
.................... //      b - the buffer which is to become a transfer buffer 
.................... //       enumerated as TRB0-TRB7 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_b_transfer(BUFFER b) 
.................... { 
....................    switch(b) 
*
017A0:  MOV.B   86C,W0L
017A2:  CLR.B   1
017A4:  XOR     #0,W0
017A6:  BRA     Z,17C6
017A8:  XOR     #1,W0
017AA:  BRA     Z,17CC
017AC:  XOR     #3,W0
017AE:  BRA     Z,17D2
017B0:  XOR     #1,W0
017B2:  BRA     Z,17D8
017B4:  XOR     #7,W0
017B6:  BRA     Z,17DE
017B8:  XOR     #1,W0
017BA:  BRA     Z,17E4
017BC:  XOR     #3,W0
017BE:  BRA     Z,17EA
017C0:  XOR     #1,W0
017C2:  BRA     Z,17F0
017C4:  BRA     17F6
....................    { 
....................       case 0: 
....................          C1TR01CON.txenm=1; 
017C6:  BSET.B  430.7
....................          break; 
017C8:  GOTO    17F6
....................       case 1: 
....................          C1TR01CON.txenn=1; 
017CC:  BSET.B  431.7
....................          break; 
017CE:  GOTO    17F6
....................       case 2: 
....................          C1TR23CON.txenm=1; 
017D2:  BSET.B  432.7
....................          break; 
017D4:  GOTO    17F6
....................       case 3: 
....................          C1TR23CON.txenn=1; 
017D8:  BSET.B  433.7
....................          break; 
017DA:  GOTO    17F6
....................       case 4: 
....................          C1TR45CON.txenm=1; 
017DE:  BSET.B  434.7
....................          break; 
017E0:  GOTO    17F6
....................       case 5: 
....................          C1TR45CON.txenn=1; 
017E4:  BSET.B  435.7
....................          break; 
017E6:  GOTO    17F6
....................       case 6: 
....................          C1TR67CON.txenm=1; 
017EA:  BSET.B  436.7
....................          break; 
017EC:  GOTO    17F6
....................       case 7: 
....................          C1TR67CON.txenn=1; 
017F0:  BSET.B  437.7
....................          break; 
017F2:  GOTO    17F6
....................    } 
....................    if(C1TR67CON.txenn) 
017F6:  BTSS.B  437.7
017F8:  BRA     1808
....................       C1FCTRL.fsa=8; 
017FA:  MOV     406,W4
017FC:  AND     #3E0,W4
017FE:  IOR     #8,W4
01800:  MOV.B   W4L,W0L
01802:  MOV.B   W0L,406
01804:  GOTO    187E
....................    else if (C1TR67CON.txenm) 
01808:  BTSS.B  436.7
0180A:  BRA     181A
....................       C1FCTRL.fsa=7; 
0180C:  MOV     406,W4
0180E:  AND     #3E0,W4
01810:  IOR     #7,W4
01812:  MOV.B   W4L,W0L
01814:  MOV.B   W0L,406
01816:  GOTO    187E
....................    else if (C1TR45CON.txenn) 
0181A:  BTSS.B  435.7
0181C:  BRA     182C
....................       C1FCTRL.fsa=6; 
0181E:  MOV     406,W4
01820:  AND     #3E0,W4
01822:  IOR     #6,W4
01824:  MOV.B   W4L,W0L
01826:  MOV.B   W0L,406
01828:  GOTO    187E
....................    else if (C1TR45CON.txenm) 
0182C:  BTSS.B  434.7
0182E:  BRA     183E
....................       C1FCTRL.fsa=5; 
01830:  MOV     406,W4
01832:  AND     #3E0,W4
01834:  IOR     #5,W4
01836:  MOV.B   W4L,W0L
01838:  MOV.B   W0L,406
0183A:  GOTO    187E
....................    else if (C1TR23CON.txenn) 
0183E:  BTSS.B  433.7
01840:  BRA     1850
....................       C1FCTRL.fsa=4; 
01842:  MOV     406,W4
01844:  AND     #3E0,W4
01846:  IOR     #4,W4
01848:  MOV.B   W4L,W0L
0184A:  MOV.B   W0L,406
0184C:  GOTO    187E
....................    else if (C1TR23CON.txenm) 
01850:  BTSS.B  432.7
01852:  BRA     1862
....................       C1FCTRL.fsa=3; 
01854:  MOV     406,W4
01856:  AND     #3E0,W4
01858:  IOR     #3,W4
0185A:  MOV.B   W4L,W0L
0185C:  MOV.B   W0L,406
0185E:  GOTO    187E
....................    else if (C1TR01CON.txenn) 
01862:  BTSS.B  431.7
01864:  BRA     1874
....................       C1FCTRL.fsa=2; 
01866:  MOV     406,W4
01868:  AND     #3E0,W4
0186A:  IOR     #2,W4
0186C:  MOV.B   W4L,W0L
0186E:  MOV.B   W0L,406
01870:  GOTO    187E
....................    else  
....................       C1FCTRL.fsa=1;    
01874:  MOV     406,W4
01876:  AND     #3E0,W4
01878:  IOR     #1,W4
0187A:  MOV.B   W4L,W0L
0187C:  MOV.B   W0L,406
0187E:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_enable_b_transfer(BUFFER b) 
....................    { 
....................       switch(b) 
....................       { 
....................          case 0: 
....................             C2TR01CON.txenm=1; 
....................             break; 
....................          case 1: 
....................             C2TR01CON.txenn=1; 
....................             break; 
....................          case 2: 
....................             C2TR23CON.txenm=1; 
....................             break; 
....................          case 3: 
....................             C2TR23CON.txenn=1; 
....................             break; 
....................          case 4: 
....................             C2TR45CON.txenm=1; 
....................             break; 
....................          case 5: 
....................             C2TR45CON.txenn=1; 
....................             break; 
....................          case 6: 
....................             C2TR67CON.txenm=1; 
....................             break; 
....................          case 7: 
....................             C2TR67CON.txenn=1; 
....................             break; 
....................       } 
....................       if(C2TR67CON.txenn) 
....................          C2FCTRL.fsa=8; 
....................       else if (C2TR67CON.txenm) 
....................          C2FCTRL.fsa=7; 
....................       else if (C2TR45CON.txenn) 
....................          C2FCTRL.fsa=6; 
....................       else if (C2TR45CON.txenm) 
....................          C2FCTRL.fsa=5; 
....................       else if (C2TR23CON.txenn) 
....................          C2FCTRL.fsa=4; 
....................       else if (C2TR23CON.txenm) 
....................          C2FCTRL.fsa=3; 
....................       else if (C2TR01CON.txenn) 
....................          C2FCTRL.fsa=2; 
....................       else  
....................          C2FCTRL.fsa=1;    
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_receiver() 
.................... // can2_enable_b_receiver() 
.................... // 
.................... // Sets one of the 8 programmable buffers to be a receiver buffer, and sets the  
.................... // start of the FIFO buffer to be the first buffer after the highest buffer set  
.................... // as a transmit buffer. 
.................... // 
.................... // Parameters: 
.................... //       b - the buffer which is to become a receiver buffer 
.................... //        enumerated as TRB0-TRB7 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_b_receiver(BUFFER b) 
.................... { 
....................    switch(b) 
....................    { 
....................       case 0: 
....................          C1TR01CON.txenm=0; 
....................          break; 
....................       case 1: 
....................          C1TR01CON.txenn=0; 
....................          break; 
....................       case 2: 
....................          C1TR23CON.txenm=0; 
....................          break; 
....................       case 3: 
....................          C1TR23CON.txenn=0; 
....................          break; 
....................       case 4: 
....................          C1TR45CON.txenm=0; 
....................          break; 
....................       case 5: 
....................          C1TR45CON.txenn=0; 
....................          break; 
....................       case 6: 
....................          C1TR67CON.txenm=0; 
....................          break; 
....................       case 7: 
....................          C1TR67CON.txenn=0; 
....................          break; 
....................    } 
....................    if(C1TR67CON.txenn) 
....................       C1FCTRL.fsa=8; 
....................    else if (C1TR67CON.txenm) 
....................       C1FCTRL.fsa=7; 
....................    else if (C1TR45CON.txenn) 
....................       C1FCTRL.fsa=6; 
....................    else if (C1TR45CON.txenm) 
....................       C1FCTRL.fsa=5; 
....................    else if (C1TR23CON.txenn) 
....................       C1FCTRL.fsa=4; 
....................    else if (C1TR23CON.txenm) 
....................       C1FCTRL.fsa=3; 
....................    else if (C1TR01CON.txenn) 
....................       C1FCTRL.fsa=2; 
....................    else if (C1TR01CON.txenm) 
....................       C1FCTRL.fsa=1; 
....................    else 
....................       C1FCTRL.fsa=0; 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_enable_b_receiver(BUFFER b) 
....................    { 
....................       switch(b) 
....................       { 
....................          case 0: 
....................             C2TR01CON.txenm=0; 
....................             break; 
....................          case 1: 
....................             C2TR01CON.txenn=0; 
....................             break; 
....................          case 2: 
....................             C2TR23CON.txenm=0; 
....................             break; 
....................          case 3: 
....................             C2TR23CON.txenn=0; 
....................             break; 
....................          case 4: 
....................             C2TR45CON.txenm=0; 
....................             break; 
....................          case 5: 
....................             C2TR45CON.txenn=0; 
....................             break; 
....................          case 6: 
....................             C2TR67CON.txenm=0; 
....................             break; 
....................          case 7: 
....................             C2TR67CON.txenn=0; 
....................             break; 
....................       } 
....................       if(C2TR67CON.txenn) 
....................          C2FCTRL.fsa=8; 
....................       else if (C2TR67CON.txenm) 
....................          C2FCTRL.fsa=7; 
....................       else if (C2TR45CON.txenn) 
....................          C2FCTRL.fsa=6; 
....................       else if (C2TR45CON.txenm) 
....................          C2FCTRL.fsa=5; 
....................       else if (C2TR23CON.txenn) 
....................          C2FCTRL.fsa=4; 
....................       else if (C2TR23CON.txenm) 
....................          C2FCTRL.fsa=3; 
....................       else if (C2TR01CON.txenn) 
....................          C2FCTRL.fsa=2; 
....................       else if (C2TR01CON.txenm) 
....................          C2FCTRL.fsa=1; 
....................       else 
....................          C2FCTRL.fsa=0; 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_rtr() 
.................... // can2_enable_rtr() 
.................... // 
.................... // Sets the desired programmable buffer to be used as an Auto-rtr buffer. 
.................... // 
.................... // Parameters 
.................... //       b - the programmable buffer to be set to Auto-rtr mode 
.................... //       enumerated as TRB0-TRB7 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_rtr(BUFFER b) 
.................... { 
....................    switch(b) 
....................    { 
....................       case 0: 
....................          C1TR01CON.rtrenm=1; 
....................          break; 
....................       case 1: 
....................          C1TR01CON.rtrenn=1; 
....................          break; 
....................       case 2: 
....................          C1TR23CON.rtrenm=1; 
....................          break; 
....................       case 3: 
....................          C1TR23CON.rtrenn=1; 
....................          break; 
....................       case 4: 
....................          C1TR45CON.rtrenm=1; 
....................          break; 
....................       case 5: 
....................          C1TR45CON.rtrenn=1; 
....................          break; 
....................       case 6: 
....................          C1TR67CON.rtrenm=1; 
....................          break; 
....................       case 7: 
....................          C1TR67CON.rtrenn=1; 
....................          break; 
....................    } 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_enable_rtr(BUFFER b) 
....................    { 
....................       switch(b) 
....................       { 
....................          case 0: 
....................             C2TR01CON.rtrenm=1; 
....................             break; 
....................          case 1: 
....................             C2TR01CON.rtrenn=1; 
....................             break; 
....................          case 2: 
....................             C2TR23CON.rtrenm=1; 
....................             break; 
....................          case 3: 
....................             C2TR23CON.rtrenn=1; 
....................             break; 
....................          case 4: 
....................             C2TR45CON.rtrenm=1; 
....................             break; 
....................          case 5: 
....................             C2TR45CON.rtrenn=1; 
....................             break; 
....................          case 6: 
....................             C2TR67CON.rtrenm=1; 
....................             break; 
....................          case 7: 
....................             C2TR67CON.rtrenn=1; 
....................             break; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_rtr() 
.................... // can2_disable_rtr() 
.................... // 
.................... // Disables specified programmable buffer from being used as Auto-rtr buffer. 
.................... // 
.................... // Parameters: 
.................... //      b - the programmable buffer to be disabled from Auto-rtr mode 
.................... //       enumerated as TRB0-TRB7 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_disable_rtr(BUFFER b) 
.................... { 
....................    switch(b) 
....................    { 
....................       case 0: 
....................          C1TR01CON.rtrenm=0; 
....................          break; 
....................       case 1: 
....................          C1TR01CON.rtrenn=0; 
....................          break; 
....................       case 2: 
....................          C1TR23CON.rtrenm=0; 
....................          break; 
....................       case 3: 
....................          C1TR23CON.rtrenn=0; 
....................          break; 
....................       case 4: 
....................          C1TR45CON.rtrenm=0; 
....................          break; 
....................       case 5: 
....................          C1TR45CON.rtrenn=0; 
....................          break; 
....................       case 6: 
....................          C1TR67CON.rtrenm=0; 
....................          break; 
....................       case 7: 
....................          C1TR67CON.rtrenn=0; 
....................          break; 
....................    } 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_disable_rtr(BUFFER b) 
....................    { 
....................       switch(b) 
....................       { 
....................          case 0: 
....................             C2TR01CON.rtrenm=0; 
....................             break; 
....................          case 1: 
....................             C2TR01CON.rtrenn=0; 
....................             break; 
....................          case 2: 
....................             C2TR23CON.rtrenm=0; 
....................             break; 
....................          case 3: 
....................             C2TR23CON.rtrenn=0; 
....................             break; 
....................          case 4: 
....................             C2TR45CON.rtrenm=0; 
....................             break; 
....................          case 5: 
....................             C2TR45CON.rtrenn=0; 
....................             break; 
....................          case 6: 
....................             C2TR67CON.rtrenm=0; 
....................             break; 
....................          case 7: 
....................             C2TR67CON.rtrenn=0; 
....................             break; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_load_rtr() 
.................... // can2_load_rtr() 
.................... // 
.................... //   Loads a SINGLE b buffer with data to be sent on the occurrence of an rtr. 
.................... // 
.................... // Parameters: 
.................... // 
.................... //      b - The programmable buffer to be filled 
.................... //       enumerated as TRB0-TRB7 
.................... //      data - the address of the first data byte 
.................... //      len - the number of data bytes to be copied 
.................... // 
.................... // Returns: 
.................... //      void 
.................... // 
.................... //   Note, the programmer must set the appropriate rtr registers in order for the 
.................... //         rtr function to work.  This function does not set any of those 
.................... //         registers.  For example, to enable TRB0 as an Auto-rtr buffer, the 
.................... //         functions: 
.................... // 
.................... //         can_enable_b_transfer(TRB0); 
.................... //         can_enable_rtr(TRB0); 
.................... //         function to link acceptance filter to TRB0 
.................... // 
.................... //         needs to be called. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_load_rtr (BUFFER b, uint8_t *data, uint8_t len) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................     
....................    curmode=C1CTRL1.opmode; 
....................     
....................    can_set_mode(CAN_OP_CONFIG); 
....................     
....................    ptr=&ecan1_message_buffer[b][2]; 
....................     
....................    *ptr&=0xFFF0; 
....................    *ptr|=len; 
....................     
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       ptr+=1; 
....................       if (i+1==len) 
....................          *ptr=make16(0,data[i]); 
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
....................    } 
....................     
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_load_rtr (BUFFER b, uint8_t *data, uint8_t len) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................        
....................       curmode=C2CTRL1.opmode; 
....................        
....................       can2_set_mode(CAN_OP_CONFIG); 
....................        
....................       ptr=&ecan2_message_buffer[b][2]; 
....................        
....................       *ptr&=0xFFF0; 
....................       *ptr|=len; 
....................        
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          ptr+=1; 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................       } 
....................        
....................       can2_set_mode(curmode); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_fifo_getd() 
.................... // can2_fifo_getd() 
.................... // 
.................... //    Retrieves data in FIFO mode 
.................... // 
.................... // Parameters: 
.................... //      id - The ID of the sender 
.................... //      data - Address of the array to store the data in 
.................... //      len - number of data bytes to read 
.................... //      stat - status structure to return information about the receive register 
.................... // 
.................... // Returns: 
.................... //      int1 - TRUE if there was data in the buffer, FALSE if there wasn't 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_fifo_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat ) 
.................... { 
....................    uint16_t i, temp1; 
....................    uint16_t *ptr; 
....................    int1 temp; 
....................     
....................    temp1=C1FIFO.fnrb; 
....................     
....................    switch(temp1) 
....................    { 
....................       case 0: 
....................          if(!C1RXFUL1.rxful0) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf0; 
....................             C1RXOVF1.rxovf0=0; 
....................          } 
....................          break; 
....................       case 1: 
....................          if(!C1RXFUL1.rxful1) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf1; 
....................             C1RXOVF1.rxovf1=0; 
....................          } 
....................          break; 
....................       case 2: 
....................          if(!C1RXFUL1.rxful2) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf2; 
....................             C1RXOVF1.rxovf2=0; 
....................          } 
....................          break; 
....................       case 3: 
....................          if(!C1RXFUL1.rxful3) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf3; 
....................             C1RXOVF1.rxovf3=0; 
....................          } 
....................          break; 
....................       case 4: 
....................          if(!C1RXFUL1.rxful4) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf4; 
....................             C1RXOVF1.rxovf4=0; 
....................          } 
....................          break; 
....................       case 5: 
....................          if(!C1RXFUL1.rxful5) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf5; 
....................             C1RXOVF1.rxovf5=0; 
....................          } 
....................          break; 
....................       case 6: 
....................          if(!C1RXFUL1.rxful6) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf6; 
....................             C1RXOVF1.rxovf6=0; 
....................          } 
....................          break; 
....................       case 7: 
....................          if(!C1RXFUL1.rxful7) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf7; 
....................             C1RXOVF1.rxovf7=0; 
....................          } 
....................          break; 
....................       case 8: 
....................          if(!C1RXFUL1.rxful8) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf8; 
....................             C1RXOVF1.rxovf8=0; 
....................          } 
....................          break; 
....................       case 9: 
....................          if(!C1RXFUL1.rxful9) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf9; 
....................             C1RXOVF1.rxovf9=0; 
....................          } 
....................          break; 
....................       case 10: 
....................          if(!C1RXFUL1.rxful10) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf10; 
....................             C1RXOVF1.rxovf10=0; 
....................          } 
....................          break; 
....................       case 11: 
....................          if(!C1RXFUL1.rxful11) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf11; 
....................             C1RXOVF1.rxovf11=0; 
....................          } 
....................          break; 
....................       case 12: 
....................          if(!C1RXFUL1.rxful12) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf12; 
....................             C1RXOVF1.rxovf12=0; 
....................          } 
....................          break; 
....................       case 13: 
....................          if(!C1RXFUL1.rxful13) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf13; 
....................             C1RXOVF1.rxovf13=0; 
....................          } 
....................          break; 
....................       case 14: 
....................          if(!C1RXFUL1.rxful14) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf14; 
....................             C1RXOVF1.rxovf14=0; 
....................          } 
....................          break; 
....................       case 15: 
....................          if(!C1RXFUL1.rxful15) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF1.rxovf15; 
....................             C1RXOVF1.rxovf15=0; 
....................          } 
....................          break; 
....................       case 16: 
....................          if(!C1RXFUL2.rxful16) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf16; 
....................             C1RXOVF2.rxovf16=0; 
....................          } 
....................          break; 
....................       case 17: 
....................          if(!C1RXFUL2.rxful17) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf17; 
....................             C1RXOVF2.rxovf17=0; 
....................          } 
....................          break; 
....................       case 18: 
....................          if(!C1RXFUL2.rxful18) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf18; 
....................             C1RXOVF2.rxovf18=0; 
....................          } 
....................          break; 
....................       case 19: 
....................          if(!C1RXFUL2.rxful19) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf19; 
....................             C1RXOVF2.rxovf19=0; 
....................          } 
....................          break; 
....................       case 20: 
....................          if(!C1RXFUL2.rxful20) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf20; 
....................             C1RXOVF2.rxovf20=0; 
....................          } 
....................          break; 
....................       case 21: 
....................          if(!C1RXFUL2.rxful21) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf21; 
....................             C1RXOVF2.rxovf21=0; 
....................          } 
....................          break; 
....................       case 22: 
....................          if(!C1RXFUL2.rxful22) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf22; 
....................             C1RXOVF2.rxovf22=0; 
....................          } 
....................          break; 
....................       case 23: 
....................          if(!C1RXFUL2.rxful23) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf23; 
....................             C1RXOVF2.rxovf23=0; 
....................          } 
....................          break; 
....................       case 24: 
....................          if(!C1RXFUL2.rxful24) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf24; 
....................             C1RXOVF2.rxovf24=0; 
....................          } 
....................          break; 
....................       case 25: 
....................          if(!C1RXFUL2.rxful25) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf25; 
....................             C1RXOVF2.rxovf25=0; 
....................          } 
....................          break; 
....................       case 26: 
....................          if(!C1RXFUL2.rxful26) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf26; 
....................             C1RXOVF2.rxovf26=0; 
....................          } 
....................          break; 
....................       case 27: 
....................          if(!C1RXFUL2.rxful27) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf27; 
....................             C1RXOVF2.rxovf27=0; 
....................          } 
....................          break; 
....................       case 28: 
....................          if(!C1RXFUL2.rxful28) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf28; 
....................             C1RXOVF2.rxovf28=0; 
....................          } 
....................          break; 
....................       case 29: 
....................          if(!C1RXFUL2.rxful29) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf29; 
....................             C1RXOVF2.rxovf29=0; 
....................          } 
....................          break; 
....................       case 30: 
....................          if(!C1RXFUL2.rxful30) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf30; 
....................             C1RXOVF2.rxovf30=0; 
....................          } 
....................          break; 
....................       case 31: 
....................          if(!C1RXFUL2.rxful31) 
....................             return(0); 
....................          else { 
....................             stat.err_ovfl=C1RXOVF2.rxovf31; 
....................             C1RXOVF2.rxovf31=0; 
....................          } 
....................          break; 
....................    } 
....................     
....................    C1INTF.rbif=0; 
....................     
....................    stat.buffer=C1FIFO.fnrb; 
....................     
....................    ptr=&ecan1_message_buffer[stat.buffer][0]; 
....................    stat.ext=(*ptr & 0x1); 
....................    temp=(*ptr & 0x1); 
....................       
....................    ptr+=2; 
....................    len=(*ptr & 0xF); 
....................    stat.rtr=((make8(*ptr,1) & 0x2) >> 1); 
....................     
....................    ptr+=5; 
....................    stat.filthit=(make8(*ptr,1) & 0x1F); 
....................        
....................    id=can_get_id(stat.buffer,temp); 
....................     
....................    ptr=&ecan1_message_buffer[stat.buffer][3]; 
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       data[i]=make8(*ptr,0); 
....................       if (i+1!=len) 
....................          data[i+1]=make8(*ptr,1); 
....................       ptr++; 
....................    } 
....................     
....................    stat.inv=C1INTF.ivrif; 
....................    C1INTF.ivrif=0; 
....................     
....................    switch(stat.buffer) 
....................    { 
....................       case 0: 
....................          C1RXFUL1.rxful0=0; 
....................          break; 
....................       case 1: 
....................          C1RXFUL1.rxful1=0; 
....................          break; 
....................       case 2: 
....................          C1RXFUL1.rxful2=0; 
....................          break; 
....................       case 3: 
....................          C1RXFUL1.rxful3=0; 
....................          break; 
....................       case 4: 
....................          C1RXFUL1.rxful4=0; 
....................          break; 
....................       case 5: 
....................          C1RXFUL1.rxful5=0; 
....................          break; 
....................       case 6: 
....................          C1RXFUL1.rxful6=0; 
....................          break; 
....................       case 7: 
....................          C1RXFUL1.rxful7=0; 
....................          break; 
....................       case 8: 
....................          C1RXFUL1.rxful8=0; 
....................          break; 
....................       case 9: 
....................          C1RXFUL1.rxful9=0; 
....................          break; 
....................       case 10: 
....................          C1RXFUL1.rxful10=0; 
....................          break; 
....................       case 11: 
....................          C1RXFUL1.rxful11=0; 
....................          break; 
....................       case 12: 
....................          C1RXFUL1.rxful12=0; 
....................          break; 
....................       case 13: 
....................          C1RXFUL1.rxful13=0; 
....................          break; 
....................       case 14: 
....................          C1RXFUL1.rxful14=0; 
....................          break; 
....................       case 15: 
....................          C1RXFUL1.rxful15=0; 
....................          break; 
....................       case 16: 
....................          C1RXFUL2.rxful16=0; 
....................          break; 
....................       case 17: 
....................          C1RXFUL2.rxful17=0; 
....................          break; 
....................       case 18: 
....................          C1RXFUL2.rxful18=0; 
....................          break; 
....................       case 19: 
....................          C1RXFUL2.rxful19=0; 
....................          break; 
....................       case 20: 
....................          C1RXFUL2.rxful20=0; 
....................          break; 
....................       case 21: 
....................          C1RXFUL2.rxful21=0; 
....................          break; 
....................       case 22: 
....................          C1RXFUL2.rxful22=0; 
....................          break; 
....................       case 23: 
....................          C1RXFUL2.rxful23=0; 
....................          break; 
....................       case 24: 
....................          C1RXFUL2.rxful24=0; 
....................          break; 
....................       case 25: 
....................          C1RXFUL2.rxful25=0; 
....................          break; 
....................       case 26: 
....................          C1RXFUL2.rxful26=0; 
....................          break; 
....................       case 27: 
....................          C1RXFUL2.rxful27=0; 
....................          break; 
....................       case 28: 
....................          C1RXFUL2.rxful28=0; 
....................          break; 
....................       case 29: 
....................          C1RXFUL2.rxful29=0; 
....................          break; 
....................       case 30: 
....................          C1RXFUL2.rxful30=0; 
....................          break; 
....................       case 31: 
....................          C1RXFUL2.rxful31=0; 
....................          break; 
....................    } 
....................     
....................    return(1); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_fifo_getd(uint32_t &id, uint8_t *data, uint8_t &len, struct rx_stat &stat ) 
....................    { 
....................       uint16_t i, temp1; 
....................       uint16_t *ptr; 
....................       int1 temp; 
....................        
....................       temp1=C2FIFO.fnrb; 
....................        
....................       switch(temp1) 
....................       { 
....................          case 0: 
....................             if(!C2RXFUL1.rxful0) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf0; 
....................                C2RXOVF1.rxovf0=0; 
....................             } 
....................             break; 
....................          case 1: 
....................             if(!C2RXFUL1.rxful1) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf1; 
....................                C2RXOVF1.rxovf1=0; 
....................             } 
....................             break; 
....................          case 2: 
....................             if(!C2RXFUL1.rxful2) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf2; 
....................                C2RXOVF1.rxovf2=0; 
....................             } 
....................             break; 
....................          case 3: 
....................             if(!C2RXFUL1.rxful3) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf3; 
....................                C2RXOVF1.rxovf3=0; 
....................             } 
....................             break; 
....................          case 4: 
....................             if(!C2RXFUL1.rxful4) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf4; 
....................                C2RXOVF1.rxovf4=0; 
....................             } 
....................             break; 
....................          case 5: 
....................             if(!C2RXFUL1.rxful5) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf5; 
....................                C2RXOVF1.rxovf5=0; 
....................             } 
....................             break; 
....................          case 6: 
....................             if(!C2RXFUL1.rxful6) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf6; 
....................                C2RXOVF1.rxovf6=0; 
....................             } 
....................             break; 
....................          case 7: 
....................             if(!C2RXFUL1.rxful7) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf7; 
....................                C2RXOVF1.rxovf7=0; 
....................             } 
....................             break; 
....................          case 8: 
....................             if(!C2RXFUL1.rxful8) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf8; 
....................                C2RXOVF1.rxovf8=0; 
....................             } 
....................             break; 
....................          case 9: 
....................             if(!C2RXFUL1.rxful9) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf9; 
....................                C2RXOVF1.rxovf9=0; 
....................             } 
....................             break; 
....................          case 10: 
....................             if(!C2RXFUL1.rxful10) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf10; 
....................                C2RXOVF1.rxovf10=0; 
....................             } 
....................             break; 
....................          case 11: 
....................             if(!C2RXFUL1.rxful11) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf11; 
....................                C2RXOVF1.rxovf11=0; 
....................             } 
....................             break; 
....................          case 12: 
....................             if(!C2RXFUL1.rxful12) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf12; 
....................                C2RXOVF1.rxovf12=0; 
....................             } 
....................             break; 
....................          case 13: 
....................             if(!C2RXFUL1.rxful13) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf13; 
....................                C2RXOVF1.rxovf13=0; 
....................             } 
....................             break; 
....................          case 14: 
....................             if(!C2RXFUL1.rxful14) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf14; 
....................                C2RXOVF1.rxovf14=0; 
....................             } 
....................             break; 
....................          case 15: 
....................             if(!C2RXFUL1.rxful15) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF1.rxovf15; 
....................                C2RXOVF1.rxovf15=0; 
....................             } 
....................             break; 
....................          case 16: 
....................             if(!C2RXFUL2.rxful16) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf16; 
....................                C2RXOVF2.rxovf16=0; 
....................             } 
....................             break; 
....................          case 17: 
....................             if(!C2RXFUL2.rxful17) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf17; 
....................                C2RXOVF2.rxovf17=0; 
....................             } 
....................             break; 
....................          case 18: 
....................             if(!C2RXFUL2.rxful18) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf18; 
....................                C2RXOVF2.rxovf18=0; 
....................             } 
....................             break; 
....................          case 19: 
....................             if(!C2RXFUL2.rxful19) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf19; 
....................                C2RXOVF2.rxovf19=0; 
....................             } 
....................             break; 
....................          case 20: 
....................             if(!C2RXFUL2.rxful20) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf20; 
....................                C2RXOVF2.rxovf20=0; 
....................             } 
....................             break; 
....................          case 21: 
....................             if(!C2RXFUL2.rxful21) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf21; 
....................                C2RXOVF2.rxovf21=0; 
....................             } 
....................             break; 
....................          case 22: 
....................             if(!C2RXFUL2.rxful22) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf22; 
....................                C2RXOVF2.rxovf22=0; 
....................             } 
....................             break; 
....................          case 23: 
....................             if(!C2RXFUL2.rxful23) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf23; 
....................                C2RXOVF2.rxovf23=0; 
....................             } 
....................             break; 
....................          case 24: 
....................             if(!C2RXFUL2.rxful24) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf24; 
....................                C2RXOVF2.rxovf24=0; 
....................             } 
....................             break; 
....................          case 25: 
....................             if(!C2RXFUL2.rxful25) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf25; 
....................                C2RXOVF2.rxovf25=0; 
....................             } 
....................             break; 
....................          case 26: 
....................             if(!C2RXFUL2.rxful26) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf26; 
....................                C2RXOVF2.rxovf26=0; 
....................             } 
....................             break; 
....................          case 27: 
....................             if(!C2RXFUL2.rxful27) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf27; 
....................                C2RXOVF2.rxovf27=0; 
....................             } 
....................             break; 
....................          case 28: 
....................             if(!C2RXFUL2.rxful28) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf28; 
....................                C2RXOVF2.rxovf28=0; 
....................             } 
....................             break; 
....................          case 29: 
....................             if(!C2RXFUL2.rxful29) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf29; 
....................                C2RXOVF2.rxovf29=0; 
....................             } 
....................             break; 
....................          case 30: 
....................             if(!C2RXFUL2.rxful30) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf30; 
....................                C2RXOVF2.rxovf30=0; 
....................             } 
....................             break; 
....................          case 31: 
....................             if(!C2RXFUL2.rxful31) 
....................                return(0); 
....................             else { 
....................                stat.err_ovfl=C2RXOVF2.rxovf31; 
....................                C2RXOVF2.rxovf31=0; 
....................             } 
....................             break; 
....................       } 
....................        
....................       C2INTF.rbif=0; 
....................        
....................       stat.buffer=C2FIFO.fnrb; 
....................        
....................       ptr=&ecan2_message_buffer[stat.buffer][0]; 
....................       stat.ext=(*ptr & 0x1); 
....................       temp=(*ptr & 0x1); 
....................          
....................       ptr+=2; 
....................       len=(*ptr & 0xF); 
....................       stat.rtr=((make8(*ptr,1) & 0x2) >> 1); 
....................        
....................       ptr+=5; 
....................       stat.filthit=(make8(*ptr,1) & 0x1F); 
....................           
....................       id=can2_get_id(stat.buffer,temp); 
....................        
....................       ptr=&ecan2_message_buffer[stat.buffer][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          data[i]=make8(*ptr,0); 
....................          if (i+1!=len) 
....................             data[i+1]=make8(*ptr,1); 
....................          ptr++; 
....................       } 
....................        
....................       stat.inv=C2INTF.ivrif; 
....................       C2INTF.ivrif=0; 
....................        
....................       switch(stat.buffer) 
....................       { 
....................          case 0: 
....................             C2RXFUL1.rxful0=0; 
....................             break; 
....................          case 1: 
....................             C2RXFUL1.rxful1=0; 
....................             break; 
....................          case 2: 
....................             C2RXFUL1.rxful2=0; 
....................             break; 
....................          case 3: 
....................             C2RXFUL1.rxful3=0; 
....................             break; 
....................          case 4: 
....................             C2RXFUL1.rxful4=0; 
....................             break; 
....................          case 5: 
....................             C2RXFUL1.rxful5=0; 
....................             break; 
....................          case 6: 
....................             C2RXFUL1.rxful6=0; 
....................             break; 
....................          case 7: 
....................             C2RXFUL1.rxful7=0; 
....................             break; 
....................          case 8: 
....................             C2RXFUL1.rxful8=0; 
....................             break; 
....................          case 9: 
....................             C2RXFUL1.rxful9=0; 
....................             break; 
....................          case 10: 
....................             C2RXFUL1.rxful10=0; 
....................             break; 
....................          case 11: 
....................             C2RXFUL1.rxful11=0; 
....................             break; 
....................          case 12: 
....................             C2RXFUL1.rxful12=0; 
....................             break; 
....................          case 13: 
....................             C2RXFUL1.rxful13=0; 
....................             break; 
....................          case 14: 
....................             C2RXFUL1.rxful14=0; 
....................             break; 
....................          case 15: 
....................             C2RXFUL1.rxful15=0; 
....................             break; 
....................          case 16: 
....................             C2RXFUL2.rxful16=0; 
....................             break; 
....................          case 17: 
....................             C2RXFUL2.rxful17=0; 
....................             break; 
....................          case 18: 
....................             C2RXFUL2.rxful18=0; 
....................             break; 
....................          case 19: 
....................             C2RXFUL2.rxful19=0; 
....................             break; 
....................          case 20: 
....................             C2RXFUL2.rxful20=0; 
....................             break; 
....................          case 21: 
....................             C2RXFUL2.rxful21=0; 
....................             break; 
....................          case 22: 
....................             C2RXFUL2.rxful22=0; 
....................             break; 
....................          case 23: 
....................             C2RXFUL2.rxful23=0; 
....................             break; 
....................          case 24: 
....................             C2RXFUL2.rxful24=0; 
....................             break; 
....................          case 25: 
....................             C2RXFUL2.rxful25=0; 
....................             break; 
....................          case 26: 
....................             C2RXFUL2.rxful26=0; 
....................             break; 
....................          case 27: 
....................             C2RXFUL2.rxful27=0; 
....................             break; 
....................          case 28: 
....................             C2RXFUL2.rxful28=0; 
....................             break; 
....................          case 29: 
....................             C2RXFUL2.rxful29=0; 
....................             break; 
....................          case 30: 
....................             C2RXFUL2.rxful30=0; 
....................             break; 
....................          case 31: 
....................             C2RXFUL2.rxful31=0; 
....................             break; 
....................       } 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_trb0_putd - can_trb7_putd 
.................... // can2_trb0_putd - can2_trb7_putd 
.................... // 
.................... // Places data to be transferred in a specified buffer 
.................... // 
.................... // Parameters: 
.................... //      id - id that will be sent with the data 
.................... //    data - pointer to the data 
.................... //      len - number of data bytes (0-8) 
.................... //      pri - priority (0-3) 
.................... //      ext - extended or not 
.................... //    rtr - request remote transfer 
.................... // 
.................... // Returns: 
.................... //      TRUE if data is successfully loaded into the buffer 
.................... //      FALSE if data can not be loaded into the buffer 
.................... // 
.................... //   Notes 
.................... //      - make sure that the desired buffer is set to be a transfer buffer 
.................... //        using the can_enable_b_transfer ( ) function 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // programmable transfer buffer TRB0 
.................... int1 can_trb0_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................    uint16_t temp; 
....................     
....................    if(C1TR01CON.txreqm || !C1TR01CON.txenm) 
....................       return(0); 
....................        
....................    C1TR01CON.txmpri=pri; 
....................     
....................    if(ext) 
....................    { 
....................       temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[0][0]=temp; 
....................       temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................       ecan1_message_buffer[0][1]=temp; 
....................       temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................       ecan1_message_buffer[0][2]=temp; 
....................    } 
....................    else 
....................    { 
....................       temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[0][0]=temp; 
....................       ecan1_message_buffer[0][1]=0x0000; 
....................       temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................       ecan1_message_buffer[0][2]=temp; 
....................    } 
....................     
....................    ptr=&ecan1_message_buffer[0][3]; 
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       if (i+1==len) 
....................          *ptr=make16(0,data[i]); 
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
....................       ptr++; 
....................    } 
....................     
....................    C1TR01CON.txreqm=1; 
....................     
....................    return(1); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_trb0_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C2TR01CON.txreqm || !C2TR01CON.txenm) 
....................          return(0); 
....................           
....................       C2TR01CON.txmpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[0][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan2_message_buffer[0][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan2_message_buffer[0][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[0][0]=temp; 
....................          ecan2_message_buffer[0][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan2_message_buffer[0][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan2_message_buffer[0][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C2TR01CON.txreqm=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB1 
.................... int1 can_trb1_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................    uint16_t temp; 
....................     
....................    if(C1TR01CON.txreqn || !C1TR01CON.txenn) 
....................       return(0); 
....................        
....................    C1TR01CON.txnpri=pri; 
....................     
....................    if(ext) 
....................    { 
....................       temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[1][0]=temp; 
....................       temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................       ecan1_message_buffer[1][1]=temp; 
....................       temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................       ecan1_message_buffer[1][2]=temp; 
....................    } 
....................    else 
....................    {   
....................       temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[1][0]=temp; 
....................       ecan1_message_buffer[1][1]=0x0000; 
....................       temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................       ecan1_message_buffer[1][2]=temp; 
....................    } 
....................     
....................    ptr=&ecan1_message_buffer[1][3]; 
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       if (i+1==len) 
....................          *ptr=make16(0,data[i]); 
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
....................       ptr++; 
....................    } 
....................     
....................    C1TR01CON.txreqn=1; 
....................     
....................    return(1); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_trb1_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C2TR01CON.txreqn || !C2TR01CON.txenn) 
....................          return(0); 
....................           
....................       C2TR01CON.txnpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[1][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan2_message_buffer[1][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan2_message_buffer[1][2]=temp; 
....................       } 
....................       else 
....................       {   
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[1][0]=temp; 
....................          ecan2_message_buffer[1][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan2_message_buffer[1][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan2_message_buffer[1][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C2TR01CON.txreqn=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB2 
.................... int1 can_trb2_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................    uint16_t temp; 
....................     
....................    if(C1TR23CON.txreqm || !C1TR23CON.txenm) 
....................       return(0); 
....................        
....................    C1TR23CON.txmpri=pri; 
....................     
....................    if(ext) 
....................    { 
....................       temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[2][0]=temp; 
....................       temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................       ecan1_message_buffer[2][1]=temp; 
....................       temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................       ecan1_message_buffer[2][2]=temp; 
....................    } 
....................    else 
....................    { 
....................       temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[2][0]=temp; 
....................       ecan1_message_buffer[2][1]=0x0000; 
....................       temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................       ecan1_message_buffer[2][2]=temp; 
....................    } 
....................     
....................    ptr=&ecan1_message_buffer[2][3]; 
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       if (i+1==len) 
....................          *ptr=make16(0,data[i]); 
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
....................       ptr++; 
....................    } 
....................     
....................    C1TR23CON.txreqm=1; 
....................     
....................    return(1); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_trb2_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C2TR23CON.txreqm || !C2TR23CON.txenm) 
....................          return(0); 
....................           
....................       C2TR23CON.txmpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[2][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan2_message_buffer[2][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan2_message_buffer[2][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[2][0]=temp; 
....................          ecan2_message_buffer[2][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan2_message_buffer[2][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan2_message_buffer[2][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C2TR23CON.txreqm=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB3 
.................... int1 can_trb3_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
.................... { 
....................    uint16_t i; 
....................    uint16_t *ptr; 
....................    uint16_t temp; 
....................     
....................    if(C1TR23CON.txreqn || !C1TR23CON.txenn) 
....................       return(0); 
....................        
....................    C1TR23CON.txnpri=pri; 
....................     
....................    if(ext) 
....................    { 
....................       temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[3][0]=temp; 
....................       temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................       ecan1_message_buffer[3][1]=temp; 
....................       temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................       ecan1_message_buffer[3][2]=temp; 
....................    } 
....................    else 
....................    { 
....................       temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................       ecan1_message_buffer[3][0]=temp; 
....................       ecan1_message_buffer[3][1]=0x0000; 
....................       temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................       ecan1_message_buffer[3][2]=temp; 
....................    } 
....................     
....................    ptr=&ecan1_message_buffer[3][3]; 
....................    for(i=0;i<len;i+=2) 
....................    { 
....................       if (i+1==len) 
....................          *ptr=make16(0,data[i]); 
....................       else 
....................          *ptr=make16(data[i+1],data[i]); 
....................       ptr++; 
....................    } 
....................     
....................    C1TR23CON.txreqn=1; 
....................     
....................    return(1); 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    int1 can2_trb3_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C2TR23CON.txreqn || !C2TR23CON.txenn) 
....................          return(0); 
....................           
....................       C2TR23CON.txnpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[3][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan2_message_buffer[3][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan2_message_buffer[3][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan2_message_buffer[3][0]=temp; 
....................          ecan2_message_buffer[3][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan2_message_buffer[3][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan2_message_buffer[3][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C2TR23CON.txreqn=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB4 
.................... #if CAN_BUFFER_SIZE>4 
....................    int1 can_trb4_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C1TR45CON.txreqm || !C1TR45CON.txenm) 
....................          return(0); 
....................           
....................       C1TR45CON.txmpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[4][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan1_message_buffer[4][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan1_message_buffer[4][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[4][0]=temp; 
....................          ecan1_message_buffer[4][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan1_message_buffer[4][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan1_message_buffer[4][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C1TR45CON.txreqm=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #if CAN2_BUFFER_SIZE>4 
....................       int1 can2_trb4_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................       { 
....................          uint16_t i; 
....................          uint16_t *ptr; 
....................          uint16_t temp; 
....................           
....................          if(C2TR45CON.txreqm || !C2TR45CON.txenm) 
....................             return(0); 
....................              
....................          C2TR45CON.txmpri=pri; 
....................           
....................          if(ext) 
....................          { 
....................             temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[4][0]=temp; 
....................             temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................             ecan2_message_buffer[4][1]=temp; 
....................             temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................             ecan2_message_buffer[4][2]=temp; 
....................          } 
....................          else 
....................          { 
....................             temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[4][0]=temp; 
....................             ecan2_message_buffer[4][1]=0x0000; 
....................             temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................             ecan2_message_buffer[4][2]=temp; 
....................          } 
....................           
....................          ptr=&ecan2_message_buffer[4][3]; 
....................          for(i=0;i<len;i+=2) 
....................          { 
....................             if (i+1==len) 
....................                *ptr=make16(0,data[i]); 
....................             else 
....................                *ptr=make16(data[i+1],data[i]); 
....................             ptr++; 
....................          } 
....................           
....................          C2TR45CON.txreqm=1; 
....................           
....................          return(1); 
....................       } 
....................    #endif 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB5 
.................... #if CAN_BUFFER_SIZE>4 
....................    int1 can_trb5_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C1TR45CON.txreqn || !C1TR45CON.txenn) 
....................          return(0); 
....................           
....................       C1TR45CON.txnpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[5][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan1_message_buffer[5][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan1_message_buffer[5][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[5][0]=temp; 
....................          ecan1_message_buffer[5][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan1_message_buffer[5][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan1_message_buffer[5][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C1TR45CON.txreqn=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #if CAN2_BUFFER_SIZE>4 
....................       int1 can2_trb5_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................       { 
....................          uint16_t i; 
....................          uint16_t *ptr; 
....................          uint16_t temp; 
....................           
....................          if(C2TR45CON.txreqn || !C2TR45CON.txenn) 
....................             return(0); 
....................              
....................          C2TR45CON.txnpri=pri; 
....................           
....................          if(ext) 
....................          { 
....................             temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[5][0]=temp; 
....................             temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................             ecan2_message_buffer[5][1]=temp; 
....................             temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................             ecan2_message_buffer[5][2]=temp; 
....................          } 
....................          else 
....................          { 
....................             temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[5][0]=temp; 
....................             ecan2_message_buffer[5][1]=0x0000; 
....................             temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................             ecan2_message_buffer[5][2]=temp; 
....................          } 
....................           
....................          ptr=&ecan2_message_buffer[5][3]; 
....................          for(i=0;i<len;i+=2) 
....................          { 
....................             if (i+1==len) 
....................                *ptr=make16(0,data[i]); 
....................             else 
....................                *ptr=make16(data[i+1],data[i]); 
....................             ptr++; 
....................          } 
....................           
....................          C2TR45CON.txreqn=1; 
....................           
....................          return(1); 
....................       } 
....................    #endif 
.................... #endif 
....................     
.................... // programmable transfer buffer TRB6 
.................... #if CAN_BUFFER_SIZE>6 
....................    int1 can_trb6_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C1TR67CON.txreqm || !C1TR67CON.txenm) 
....................          return(0); 
....................           
....................       C1TR67CON.txmpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[6][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan1_message_buffer[6][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan1_message_buffer[6][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[6][0]=temp; 
....................          ecan1_message_buffer[6][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan1_message_buffer[6][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan1_message_buffer[6][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C1TR67CON.txreqm=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #if CAN2_BUFFER_SIZE>6 
....................       int1 can2_trb6_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................       { 
....................          uint16_t i; 
....................          uint16_t *ptr; 
....................          uint16_t temp; 
....................           
....................          if(C2TR67CON.txreqm || !C2TR67CON.txenm) 
....................             return(0); 
....................              
....................          C2TR67CON.txmpri=pri; 
....................           
....................          if(ext) 
....................          { 
....................             temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[6][0]=temp; 
....................             temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................             ecan2_message_buffer[6][1]=temp; 
....................             temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................             ecan2_message_buffer[6][2]=temp; 
....................          } 
....................          else 
....................          { 
....................             temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[6][0]=temp; 
....................             ecan2_message_buffer[6][1]=0x0000; 
....................             temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................             ecan2_message_buffer[6][2]=temp; 
....................          } 
....................           
....................          ptr=&ecan2_message_buffer[6][3]; 
....................          for(i=0;i<len;i+=2) 
....................          { 
....................             if (i+1==len) 
....................                *ptr=make16(0,data[i]); 
....................             else 
....................                *ptr=make16(data[i+1],data[i]); 
....................             ptr++; 
....................          } 
....................           
....................          C2TR67CON.txreqm=1; 
....................           
....................          return(1); 
....................       } 
....................    #endif 
.................... #endif 
....................  
.................... // programmable transfer buffer TRB7 
.................... #if CAN_BUFFER_SIZE>6 
....................    int1 can_trb7_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................    { 
....................       uint16_t i; 
....................       uint16_t *ptr; 
....................       uint16_t temp; 
....................        
....................       if(C1TR67CON.txreqn || !C1TR67CON.txenn) 
....................          return(0); 
....................        
....................       C1TR67CON.txnpri=pri; 
....................        
....................       if(ext) 
....................       { 
....................          temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[7][0]=temp; 
....................          temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................          ecan1_message_buffer[7][1]=temp; 
....................          temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................          ecan1_message_buffer[7][2]=temp; 
....................       } 
....................       else 
....................       { 
....................          temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................          ecan1_message_buffer[7][0]=temp; 
....................          ecan1_message_buffer[7][1]=0x0000; 
....................          temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................          ecan1_message_buffer[7][2]=temp; 
....................       } 
....................        
....................       ptr=&ecan1_message_buffer[7][3]; 
....................       for(i=0;i<len;i+=2) 
....................       { 
....................          if (i+1==len) 
....................             *ptr=make16(0,data[i]); 
....................          else 
....................             *ptr=make16(data[i+1],data[i]); 
....................          ptr++; 
....................       } 
....................        
....................       C1TR67CON.txreqn=1; 
....................        
....................       return(1); 
....................    } 
.................... #endif 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    #if CAN2_BUFFER_SIZE>6 
....................       int1 can2_trb7_putd(uint32_t id, uint8_t *data, uint8_t len, uint8_t pri, int1 ext, int1 rtr) 
....................       { 
....................          uint16_t i; 
....................          uint16_t *ptr; 
....................          uint16_t temp; 
....................           
....................          if(C2TR67CON.txreqn || !C2TR67CON.txenn) 
....................             return(0); 
....................           
....................          C2TR67CON.txnpri=pri; 
....................           
....................          if(ext) 
....................          { 
....................             temp=(((id & 0x1FFC0000) >> 16) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[7][0]=temp; 
....................             temp=((id & 0x3FFC0) >> 6) & 0x0FFF; 
....................             ecan2_message_buffer[7][1]=temp; 
....................             temp=(((id & 0x3F) << 10) | (((uint16_t)rtr << 9) | (uint16_t)len)) & 0xFF1F; 
....................             ecan2_message_buffer[7][2]=temp; 
....................          } 
....................          else 
....................          { 
....................             temp=(((id & 0x7FF) << 2) | (((uint16_t)rtr << 1) | (uint16_t)ext)) & 0x1FFF; 
....................             ecan2_message_buffer[7][0]=temp; 
....................             ecan2_message_buffer[7][1]=0x0000; 
....................             temp=(((uint16_t)rtr << 9) | (uint16_t)len)& 0xFF1F; 
....................             ecan2_message_buffer[7][2]=temp; 
....................          } 
....................           
....................          ptr=&ecan2_message_buffer[7][3]; 
....................          for(i=0;i<len;i+=2) 
....................          { 
....................             if (i+1==len) 
....................                *ptr=make16(0,data[i]); 
....................             else 
....................                *ptr=make16(data[i+1],data[i]); 
....................             ptr++; 
....................          } 
....................           
....................          C2TR67CON.txreqn=1; 
....................           
....................          return(1); 
....................       } 
....................    #endif 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_config_DMA() 
.................... // can2_config_DMA() 
.................... // 
.................... // Configures the DMA buffer to use the ECAN Peripheral 
.................... //    Transmit CAN1 set to DMA Channel 0 
.................... //    Receive CAN1 set to DMA Channel 1 
.................... //    Transmit CAN2 set to DMA Channel 2 
.................... //    Receive CAN2 set to DMA Channel 3 
.................... //        
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_config_DMA(void) 
.................... { 
....................    // transmission 
....................    setup_dma(0, DMA_OUT_ECAN1, DMA_WORD); 
*
013F2:  MOV.B   #20,W0L
013F4:  MOV.B   W0L,381
013F6:  MOV.B   #46,W0L
013F8:  MOV.B   W0L,382
013FA:  MOV     #442,W4
013FC:  MOV     W4,388
....................    dma_start(0, DMA_PERIF_ADDR, &ecan1_message_buffer[0][0], 7); 
013FE:  BCLR.B  381.7
01400:  MOV.B   #20,W0L
01402:  MOV.B   W0L,380
01404:  MOV     #2000,W4
01406:  MOV     W4,384
01408:  MOV     #7,W4
0140A:  MOV     W4,38A
0140C:  BSET.B  381.7
....................     
....................    // receive 
....................    setup_dma(1, DMA_IN_ECAN1, DMA_WORD); 
0140E:  CLR.B   38D
01410:  MOV.B   #22,W0L
01412:  MOV.B   W0L,38E
01414:  MOV     #440,W4
01416:  MOV     W4,394
....................    dma_start(1, DMA_PERIF_ADDR, &ecan1_message_buffer[0][0], 7); 
01418:  BCLR.B  38D.7
0141A:  MOV.B   #20,W0L
0141C:  MOV.B   W0L,38C
0141E:  MOV     #2000,W4
01420:  MOV     W4,390
01422:  MOV     #7,W4
01424:  MOV     W4,396
01426:  BSET.B  38D.7
01428:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_config_DMA(void) 
....................    { 
....................       // transmission 
....................       setup_dma(2, DMA_OUT_ECAN2, DMA_WORD); 
....................       dma_start(2, DMA_PERIF_ADDR, &ecan2_message_buffer[0][0], 7); 
....................        
....................       // receive 
....................       setup_dma(3, DMA_IN_ECAN2, DMA_WORD); 
....................       dma_start(3, DMA_PERIF_ADDR, &ecan2_message_buffer[0][0], 7); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_interrupts() 
.................... // can2_enable_interrupts() 
.................... // 
.................... //    Selects which interrupts causes the #INT_CAN1 and #INT_CAN2 interrupts to  
.................... //    fire 
.................... // 
.................... //    Parameters 
.................... //       setting - the selected interrupts  
.................... //          enumerated as 
.................... //             TB - Transmit Buffer Interrupt 
.................... //             RB - Receive Buffer Interrupt 
.................... //             RXOV - Receive Buffer Overflow Interrupt 
.................... //             FIFO - FIFO Almost Full Interrupt 
.................... //             ERR - Error interrupt 
.................... //             WAK - Wake-Up Interrupt 
.................... //             IVR - Invalid Message Received Interrupt 
.................... // 
.................... //          You can or these together (via |) to enable more than interrupt 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_interrupts(INTERRUPT setting) 
*
01880:  MOV     W5,[W15++]
.................... { 
....................    uint16_t temp; 
....................    uint16_t *ptr; 
....................     
....................    ptr = &C1INTE; 
01882:  MOV     #40C,W4
01884:  MOV     W4,870
....................     
....................   // temp=C1INTE; 
....................   // C1INTE=(temp | setting); 
....................    
....................   temp = *ptr; 
01886:  MOV     870,W0
01888:  MOV     [W0],[W15++]
0188A:  POP     86E
....................   *ptr = (temp | setting); 
0188C:  MOV     870,W5
0188E:  MOV     86E,W0
01890:  IOR     86C,W0
01892:  MOV     W0,[W5]
01894:  MOV     [--W15],W5
01896:  RETURN  
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_enable_interrupts(INTERRUPT setting) 
....................    { 
....................       uint16_t temp; 
....................       uint16_t *ptr; 
....................        
....................       ptr = &C2INTE; 
....................        
....................       //temp=C2INTE; 
....................       //C2INTE=(temp | setting); 
....................       temp = *ptr; 
....................       *ptr = (temp | setting); 
....................    } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_interrupts() 
.................... // can2_disable_interrupts() 
.................... // 
.................... //    Disables specified interrupts that causes the #INT_CAN1 and #INT_CAN2 
.................... //       interrupts to fire 
.................... // 
.................... //    Parameters 
.................... //       setting - the selected interrupts  
.................... //          enumerated as 
.................... //             TB - Transmit Buffer Interrupt 
.................... //             RB - Receive Buffer Interrupt 
.................... //             RXOV - Receive Buffer Overflow Interrupt 
.................... //             FIFO - FIFO Almost Full Interrupt 
.................... //             ERR - Error interrupt 
.................... //             WAK - Wake-Up Interrupt 
.................... //             IVR - Invalid Message Received Interrupt 
.................... // 
.................... //          You can or these together (via |) to enable more than interrupt 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_disable_interrupts(INTERRUPT setting) 
.................... { 
....................    uint16_t temp; 
....................    uint16_t *ptr; 
....................     
....................    ptr = &C1INTE; 
....................     
....................    //temp=C1INTE; 
....................    temp = *ptr; 
....................    temp&=(setting^0xFF); 
....................     
....................    //C1INTE=temp; 
....................    *ptr = temp; 
.................... } 
....................  
.................... #if getenv("SFR_VALID:C2CTRL1") 
....................    void can2_disable_interrupts(INTERRUPT setting) 
....................    { 
....................       uint16_t temp; 
....................       uint16_t ptr; 
....................        
....................       ptr = &C2INTE; 
....................        
....................       //temp=C2INTE; 
....................       temp = *ptr; 
....................       temp&=(setting^0xFF); 
....................        
....................       //C2INTE=temp; 
....................       *ptr = temp; 
....................    } 
.................... #endif 
....................  
....................  
.................... #PIN_SELECT C1RX=PIN_B14 
.................... #PIN_SELECT C1TX=PIN_B15 
....................  
....................  
.................... //se definen las variables que se utilizan en el programa 
.................... int8 a=0,i=0, data_tosend[8], cob=1, sync=0; 
.................... int16 voltaje[12]={4121,4115,4125,4125,4125,4125,4125,4125,4125,4125,4125,4115}, total, v_cell_min,v_cell_max, temp[8], temp_prev[8]; 
....................  
.................... int16 v_cell_minn=4120, v_min=4050, v_balanceo=4195, temp_max=700, temp_slave_max=690; 
.................... int8 diff_max=2, diff_min=10; 
.................... int32 tim=0; 
....................  
.................... struct rx_stat rxstat; 
.................... unsigned int32 rx_id; 
.................... unsigned int8 rx_buffer[8]; 
.................... unsigned int8 rx_len; 
....................  
.................... int8 slave=12; 
....................  
.................... //TIMER2 INTERRUPT 
.................... #INT_TIMER2 
.................... void  timer2_isr(void)  
*
00D1A:  PUSH    42
00D1C:  PUSH    36
00D1E:  PUSH    32
00D20:  MOV     W0,[W15++]
00D22:  MOV     #2,W0
00D24:  REPEAT  #C
00D26:  MOV     [W0++],[W15++]
.................... { 
....................    tim++; 
00D28:  INC     0858
00D2A:  BTSC.B  42.1
00D2C:  INC     085A
.................... } 
....................  
.................... //CAN INTERRUPTS 
00D2E:  BCLR.B  84.7
00D30:  MOV     #1A,W0
00D32:  REPEAT  #C
00D34:  MOV     [--W15],[W0--]
00D36:  MOV     [--W15],W0
00D38:  POP     32
00D3A:  POP     36
00D3C:  POP     42
00D3E:  RETFIE  
.................... #INT_CAN1 
.................... void can1_isr(void) 
00D40:  PUSH    42
00D42:  PUSH    36
00D44:  PUSH    32
00D46:  MOV     W0,[W15++]
00D48:  MOV     #2,W0
00D4A:  REPEAT  #C
00D4C:  MOV     [W0++],[W15++]
.................... { 
....................    // TODO: add CAN receive code here 
.................... } 
....................  
00D4E:  BCLR.B  88.3
00D50:  MOV     #1A,W0
00D52:  REPEAT  #C
00D54:  MOV     [--W15],[W0--]
00D56:  MOV     [--W15],W0
00D58:  POP     32
00D5A:  POP     36
00D5C:  POP     42
00D5E:  RETFIE  
.................... #INT_C1RX 
.................... void  c1rx_isr(void)  
*
00DE2:  PUSH    42
00DE4:  PUSH    36
00DE6:  PUSH    32
00DE8:  MOV     W0,[W15++]
00DEA:  MOV     #2,W0
00DEC:  REPEAT  #C
00DEE:  MOV     [W0++],[W15++]
.................... { 
....................    if(can_kbhit())//Returns true if there is data in one of the receive buffers for CAN1 
00DF0:  CP0     420
00DF2:  BRA     NZ,DF8
00DF4:  CP0     422
00DF6:  BRA     Z,12F6
....................    { 
....................       can_getd(rx_id, &rx_buffer[0], rx_len, rxstat); //Returns specified message/request and ID for CAN1 
00DF8:  MOV     #864,W4
00DFA:  MOV     W4,8D0
....................       if(rx_id==0x80)    
*
012A2:  MOV     860,W4
012A4:  XOR     #80,W4
012A6:  BRA     NZ,12E8
012A8:  CP0     862
012AA:  BRA     NZ,12E8
....................       { 
....................          sync=1; 
012AC:  MOV.B   #1,W0L
012AE:  MOV.B   W0L,80C
....................          v_cell_minn=(rx_buffer[0]<<8)|rx_buffer[1]; 
012B0:  MOV.B   864,W0L
012B2:  MOV.B   W0L,B
012B4:  CLR.B   W5
012B6:  MOV.B   865,W0L
012B8:  CLR.B   1
012BA:  IOR      W5,  W0,W0
012BC:  MOV     W0,84C
....................          v_min=(rx_buffer[2]<<8)|rx_buffer[3]; 
012BE:  MOV.B   866,W0L
012C0:  MOV.B   W0L,B
012C2:  CLR.B   W5
012C4:  MOV.B   867,W0L
012C6:  CLR.B   1
012C8:  IOR      W5,  W0,W0
012CA:  MOV     W0,84E
....................          v_balanceo=(rx_buffer[4]<<8)|rx_buffer[5]; 
012CC:  MOV.B   868,W0L
012CE:  MOV.B   W0L,B
012D0:  CLR.B   W5
012D2:  MOV.B   869,W0L
012D4:  CLR.B   1
012D6:  IOR      W5,  W0,W0
012D8:  MOV     W0,850
....................          temp_max=(rx_buffer[6]<<8)|rx_buffer[7]; 
012DA:  MOV.B   86A,W0L
012DC:  MOV.B   W0L,B
012DE:  CLR.B   W5
012E0:  MOV.B   86B,W0L
012E2:  CLR.B   1
012E4:  IOR      W5,  W0,W0
012E6:  MOV     W0,852
....................       } 
....................       if(rx_id==0x81) 
012E8:  MOV     860,W4
012EA:  XOR     #81,W4
012EC:  BRA     NZ,12F6
012EE:  CP0     862
012F0:  BRA     NZ,12F6
....................       { 
....................          diff_max=rx_buffer[0]; 
012F2:  MOV.B   864,W0L
012F4:  MOV.B   W0L,80D
....................       } 
....................    } 
012F6:  BCLR.B  88.2
012F8:  MOV     #1A,W0
012FA:  REPEAT  #C
012FC:  MOV     [--W15],[W0--]
012FE:  MOV     [--W15],W0
01300:  POP     32
01302:  POP     36
01304:  POP     42
01306:  RETFIE  
.................... } 
....................  
....................  
.................... //Programa principal 
.................... void main (void) 
*
01C98:  MOV     #1F80,W15
01C9A:  MOV     #1FFF,W0
01C9C:  MOV     W0,20
01C9E:  NOP     
01CA0:  MOV     #4444,W0
01CA2:  MOV     W0,A6
01CA4:  MOV     #4444,W0
01CA6:  MOV     W0,B4
01CA8:  BSET.B  81.7
01CAA:  MOV     #46,W0
01CAC:  MOV.B   W0L,742
01CAE:  MOV     #57,W0
01CB0:  MOV.B   W0L,742
01CB2:  BCLR.B  742.6
01CB4:  MOV     #3F07,W0
01CB6:  MOV     W0,6A8
01CB8:  MOV     #3F0E,W0
01CBA:  MOV     W0,6B4
01CBC:  MOV     #800,W0
01CBE:  MOV     W0,6C4
01CC0:  MOV     #7,W0
01CC2:  MOV     W0,6C6
01CC4:  MOV     #1000,W0
01CC6:  MOV     W0,6CE
01CC8:  MOV     #46,W0
01CCA:  MOV.B   W0L,742
01CCC:  MOV     #57,W0
01CCE:  MOV.B   W0L,742
01CD0:  BSET.B  742.6
01CD2:  BSET.B  2C8.7
01CD4:  BCLR.B  2C8.6
01CD6:  BCLR.B  2C8.5
01CD8:  BSET.B  2CC.5
01CDA:  BCLR.B  2C9.3
01CDC:  BSET.B  2CD.3
01CDE:  CLR.B   801
01CE0:  CLR.B   802
01CE2:  MOV.B   #1,W0L
01CE4:  MOV.B   W0L,803
01CE6:  CLR.B   80C
01CE8:  MOV     #1018,W4
01CEA:  MOV     W4,84C
01CEC:  MOV     #FD2,W4
01CEE:  MOV     W4,84E
01CF0:  MOV     #1063,W4
01CF2:  MOV     W4,850
01CF4:  MOV     #2BC,W4
01CF6:  MOV     W4,852
01CF8:  MOV     #2B2,W4
01CFA:  MOV     W4,854
01CFC:  MOV.B   #2,W0L
01CFE:  MOV.B   W0L,80D
01D00:  MOV.B   #A,W0L
01D02:  MOV.B   W0L,856
01D04:  CLR     858
01D06:  CLR     85A
01D08:  MOV.B   #C,W0L
01D0A:  MOV.B   W0L,85F
01D0C:  SETM    32C
01D0E:  MOV     #1019,W4
01D10:  MOV     W4,80E
01D12:  MOV     #1013,W4
01D14:  MOV     W4,810
01D16:  MOV     #101D,W4
01D18:  MOV     W4,812
01D1A:  MOV     #101D,W4
01D1C:  MOV     W4,814
01D1E:  MOV     #101D,W4
01D20:  MOV     W4,816
01D22:  MOV     #101D,W4
01D24:  MOV     W4,818
01D26:  MOV     #101D,W4
01D28:  MOV     W4,81A
01D2A:  MOV     #101D,W4
01D2C:  MOV     W4,81C
01D2E:  MOV     #101D,W4
01D30:  MOV     W4,81E
01D32:  MOV     #101D,W4
01D34:  MOV     W4,820
01D36:  MOV     #101D,W4
01D38:  MOV     W4,822
01D3A:  MOV     #1013,W4
01D3C:  MOV     W4,824
.................... { 
....................    output_high(LED1); 
01D3E:  BCLR.B  2C9.5
01D40:  BSET.B  2CD.5
....................    output_high(LED2); 
01D42:  BCLR.B  2C9.4
01D44:  BSET.B  2CD.4
....................    setup_timer2(TMR_INTERNAL| TMR_DIV_BY_1, 4999);   //TIMER2 OVERFLOW every 0,5us 
01D46:  CLR     110
01D48:  MOV     #1387,W4
01D4A:  MOV     W4,10C
01D4C:  MOV     #8000,W4
01D4E:  MOV     W4,110
....................  
....................    can_init(); 
01D50:  CALL    165E
....................  
....................    can_enable_b_transfer(TRB0);  //make buffer 0 a transmit buffer  //  
01D54:  CLR.B   86C
01D56:  CALL    17A0
....................    can_enable_b_transfer(TRB1); 
01D5A:  MOV.B   #1,W0L
01D5C:  MOV.B   W0L,86C
01D5E:  CALL    17A0
....................    can_enable_b_transfer(TRB2); 
01D62:  MOV.B   #2,W0L
01D64:  MOV.B   W0L,86C
01D66:  CALL    17A0
....................    can_enable_b_transfer(TRB3); 
01D6A:  MOV.B   #3,W0L
01D6C:  MOV.B   W0L,86C
01D6E:  CALL    17A0
....................    can_enable_b_transfer(TRB4);  
01D72:  MOV.B   #4,W0L
01D74:  MOV.B   W0L,86C
01D76:  CALL    17A0
....................    can_enable_b_transfer(TRB5); 
01D7A:  MOV.B   #5,W0L
01D7C:  MOV.B   W0L,86C
01D7E:  CALL    17A0
....................    can_enable_b_transfer(TRB6);  
01D82:  MOV.B   #6,W0L
01D84:  MOV.B   W0L,86C
01D86:  CALL    17A0
....................    can_enable_b_transfer(TRB7); 
01D8A:  MOV.B   #7,W0L
01D8C:  MOV.B   W0L,86C
01D8E:  CALL    17A0
....................     
....................    can_enable_interrupts(RB); 
01D92:  MOV.B   #2,W0L
01D94:  MOV.B   W0L,86C
01D96:  CALL    1880
....................    enable_interrupts(INT_CAN1); 
01D9A:  BSET.B  98.3
....................  
....................    enable_interrupts(INT_C1RX); 
01D9C:  BSET.B  98.2
....................    enable_interrupts(INT_CAN1); 
01D9E:  BSET.B  98.3
....................    enable_interrupts(INT_TIMER2); 
01DA0:  BSET.B  94.7
....................    enable_interrupts(INTR_GLOBAL); 
01DA2:  BCLR.B  81.7
01DA4:  CLR     42
01DA6:  BSET.B  81.7
....................    output_low(LED1); 
01DA8:  BCLR.B  2C9.5
01DAA:  BCLR.B  2CD.5
....................     
....................    //ADC voltage conversions 
....................    START_ADC_VOLTAGES(); 
01DAC:  CALL    18E0
....................    tim=0; 
01DB0:  CLR     858
01DB2:  CLR     85A
....................     
....................    //Temperature readings 
....................    ADC_LTC1296(&temp[0]); 
01DB4:  MOV     #82C,W4
01DB6:  MOV     W4,86C
01DB8:  CALL    1922
....................     
....................    for(i=0;i<8;i++) 
01DBC:  CLR.B   802
01DBE:  MOV.B   802,W0L
01DC0:  SE      W0,W0
01DC2:  CP      W0,#8
01DC4:  BRA     GE,1DE6
....................    { 
....................       temp_prev[i]=temp[i]; 
01DC6:  MOV.B   802,W0L
01DC8:  SE      W0,W0
01DCA:  MOV     W0,W4
01DCC:  MUL.UU  W4,#2,W0
01DCE:  MOV     #83C,W4
01DD0:  ADD     W0,W4,W5
01DD2:  MOV.B   802,W0L
01DD4:  SE      W0,W0
01DD6:  MOV     W0,W4
01DD8:  MUL.UU  W4,#2,W0
01DDA:  MOV     #82C,W4
01DDC:  ADD     W0,W4,W0
01DDE:  MOV     [W0],[W5]
01DE0:  INC.B   0802
01DE2:  GOTO    1DBE
....................    } 
....................     
....................    while(tim<70) {}  //Waiting until conversions have been done 
01DE6:  MOV     85A,W4
01DE8:  CP      W4,#0
01DEA:  BRA     GT,1DFA
01DEC:  BRA     LT,1DF6
01DEE:  MOV     858,W4
01DF0:  MOV     #46,W3
01DF2:  CP      W3,W4
01DF4:  BRA     LEU,1DFA
01DF6:  GOTO    1DE6
....................     
....................    //Voltage readings 
....................    READ_VOLTAGES (&voltaje[0], total, v_cell_min, v_cell_max); 
01DFA:  MOV     #80E,W4
01DFC:  MOV     W4,86C
01DFE:  PUSH    828
01E00:  POP     86E
01E02:  PUSH    82A
01E04:  POP     870
....................   
....................    delay_ms(2000); 
*
0224E:  MOV     #7D0,W0
02250:  CALL    19C2
....................    output_high(CS_LTC1296); 
02254:  BCLR.B  2C0.4
02256:  BSET.B  2C4.4
....................    output_high(CS_LTC6811); 
02258:  BCLR.B  2C0.0
0225A:  BSET.B  2C4.0
....................    sync=0; 
0225C:  CLR.B   80C
....................  
....................    while(true) 
....................    { 
....................  
....................       if(sync==1) 
0225E:  MOV.B   80C,W0L
02260:  SE      W0,W0
02262:  CP      W0,#1
02264:  BRA     NZ,2C1C
....................       { 
....................          output_high(LED1); 
02266:  BCLR.B  2C9.5
02268:  BSET.B  2CD.5
....................          sync=0; 
0226A:  CLR.B   80C
....................          tim=0; 
0226C:  CLR     858
0226E:  CLR     85A
....................           
....................          //CAN MANAGEMENT 
....................          a=0; 
02270:  CLR.B   801
....................          for(i=0;i<8;i=i+2) 
02272:  CLR.B   802
02274:  MOV.B   802,W0L
02276:  SE      W0,W0
02278:  CP      W0,#8
0227A:  BRA     GE,22C2
....................          {  
....................             data_tosend[i]=voltaje[a]>>8; 
0227C:  MOV.B   802,W0L
0227E:  SE      W0,W0
02280:  MOV     #804,W4
02282:  ADD     W0,W4,W5
02284:  MOV.B   801,W0L
02286:  SE      W0,W0
02288:  MOV     W0,W4
0228A:  MUL.UU  W4,#2,W0
0228C:  MOV     #80E,W4
0228E:  ADD     W0,W4,W0
02290:  MOV     [W0],W6
02292:  CLR.B   1
02294:  MOV.B   D,W0L
02296:  MOV.B   W0L,W0L
02298:  MOV.B   W0L,[W5]
....................             data_tosend[i+1]=voltaje[a]; 
0229A:  MOV.B   802,W0L
0229C:  SE      W0,W0
0229E:  ADD     W0,#1,W0
022A0:  MOV     W0,W5
022A2:  MOV     #804,W4
022A4:  ADD     W5,W4,W6
022A6:  MOV.B   801,W0L
022A8:  SE      W0,W0
022AA:  MOV     W0,W4
022AC:  MUL.UU  W4,#2,W0
022AE:  MOV     #80E,W4
022B0:  ADD     W0,W4,W0
022B2:  MOV.B   [W0],[W6]
....................             a++; 
022B4:  INC.B   0801
022B6:  MOV.B   802,W0L
022B8:  SE      W0,W0
022BA:  ADD     W0,#2,W0
022BC:  MOV.B   W0L,802
022BE:  GOTO    2274
....................          } 
....................          can_putd(0x82+slave*3,&data_tosend[0],8,0,0,0); 
022C2:  MOV.B   85F,W0L
022C4:  SE      W0,W0
022C6:  MOV     W0,W4
022C8:  MUL.UU  W4,#3,W0
022CA:  MOV     #82,W4
022CC:  ADD     W0,W4,W5
022CE:  MOV     W0,[W15++]
022D0:  MOV.B   #8,W0L
022D2:  MOV.B   W0L,876
022D4:  MOV     [--W15],W0
022D6:  CLR.B   877
022D8:  CLR.B   878
022DA:  CLR.B   879
022DC:  MOV     W5,870
022DE:  CLR     W4
022E0:  BTSC.B  871.7
022E2:  SETM    W4
022E4:  MOV     W4,872
022E6:  MOV     #804,W4
022E8:  MOV     W4,874
022EA:  CALL    19D2
....................          for(i=0;i<8;i=i+2) 
022EE:  CLR.B   802
022F0:  MOV.B   802,W0L
022F2:  SE      W0,W0
022F4:  CP      W0,#8
022F6:  BRA     GE,233E
....................          { 
....................             data_tosend[i]=voltaje[a]>>8; 
022F8:  MOV.B   802,W0L
022FA:  SE      W0,W0
022FC:  MOV     #804,W4
022FE:  ADD     W0,W4,W5
02300:  MOV.B   801,W0L
02302:  SE      W0,W0
02304:  MOV     W0,W4
02306:  MUL.UU  W4,#2,W0
02308:  MOV     #80E,W4
0230A:  ADD     W0,W4,W0
0230C:  MOV     [W0],W6
0230E:  CLR.B   1
02310:  MOV.B   D,W0L
02312:  MOV.B   W0L,W0L
02314:  MOV.B   W0L,[W5]
....................             data_tosend[i+1]=voltaje[a]; 
02316:  MOV.B   802,W0L
02318:  SE      W0,W0
0231A:  ADD     W0,#1,W0
0231C:  MOV     W0,W5
0231E:  MOV     #804,W4
02320:  ADD     W5,W4,W6
02322:  MOV.B   801,W0L
02324:  SE      W0,W0
02326:  MOV     W0,W4
02328:  MUL.UU  W4,#2,W0
0232A:  MOV     #80E,W4
0232C:  ADD     W0,W4,W0
0232E:  MOV.B   [W0],[W6]
....................             a++; 
02330:  INC.B   0801
02332:  MOV.B   802,W0L
02334:  SE      W0,W0
02336:  ADD     W0,#2,W0
02338:  MOV.B   W0L,802
0233A:  GOTO    22F0
....................          } 
....................          can_putd(0x83+slave*3,&data_tosend[0],8,0,0,0); 
0233E:  MOV.B   85F,W0L
02340:  SE      W0,W0
02342:  MOV     W0,W4
02344:  MUL.UU  W4,#3,W0
02346:  MOV     #83,W4
02348:  ADD     W0,W4,W5
0234A:  MOV     W0,[W15++]
0234C:  MOV.B   #8,W0L
0234E:  MOV.B   W0L,876
02350:  MOV     [--W15],W0
02352:  CLR.B   877
02354:  CLR.B   878
02356:  CLR.B   879
02358:  MOV     W5,870
0235A:  CLR     W4
0235C:  BTSC.B  871.7
0235E:  SETM    W4
02360:  MOV     W4,872
02362:  MOV     #804,W4
02364:  MOV     W4,874
02366:  CALL    19D2
....................          if (slave!=1 && slave!=4 && slave!=7 && slave!=10 && slave!=13) 
0236A:  MOV.B   85F,W0L
0236C:  SE      W0,W0
0236E:  CP      W0,#1
02370:  BRA     Z,240E
02372:  MOV.B   85F,W0L
02374:  SE      W0,W0
02376:  CP      W0,#4
02378:  BRA     Z,240E
0237A:  MOV.B   85F,W0L
0237C:  SE      W0,W0
0237E:  CP      W0,#7
02380:  BRA     Z,240E
02382:  MOV.B   85F,W0L
02384:  SE      W0,W0
02386:  CP      W0,#A
02388:  BRA     Z,240E
0238A:  MOV.B   85F,W0L
0238C:  SE      W0,W0
0238E:  CP      W0,#D
02390:  BRA     Z,240E
....................          { 
....................             for(i=0;i<4;i=i+2) 
02392:  CLR.B   802
02394:  MOV.B   802,W0L
02396:  SE      W0,W0
02398:  CP      W0,#4
0239A:  BRA     GE,23E2
....................             { 
....................                data_tosend[i]=voltaje[a]>>8; 
0239C:  MOV.B   802,W0L
0239E:  SE      W0,W0
023A0:  MOV     #804,W4
023A2:  ADD     W0,W4,W5
023A4:  MOV.B   801,W0L
023A6:  SE      W0,W0
023A8:  MOV     W0,W4
023AA:  MUL.UU  W4,#2,W0
023AC:  MOV     #80E,W4
023AE:  ADD     W0,W4,W0
023B0:  MOV     [W0],W6
023B2:  CLR.B   1
023B4:  MOV.B   D,W0L
023B6:  MOV.B   W0L,W0L
023B8:  MOV.B   W0L,[W5]
....................                data_tosend[i+1]=voltaje[a]; 
023BA:  MOV.B   802,W0L
023BC:  SE      W0,W0
023BE:  ADD     W0,#1,W0
023C0:  MOV     W0,W5
023C2:  MOV     #804,W4
023C4:  ADD     W5,W4,W6
023C6:  MOV.B   801,W0L
023C8:  SE      W0,W0
023CA:  MOV     W0,W4
023CC:  MUL.UU  W4,#2,W0
023CE:  MOV     #80E,W4
023D0:  ADD     W0,W4,W0
023D2:  MOV.B   [W0],[W6]
....................                a++; 
023D4:  INC.B   0801
023D6:  MOV.B   802,W0L
023D8:  SE      W0,W0
023DA:  ADD     W0,#2,W0
023DC:  MOV.B   W0L,802
023DE:  GOTO    2394
....................             } 
....................             can_putd(0x84+slave*3,&data_tosend[0],4,0,0,0); 
023E2:  MOV.B   85F,W0L
023E4:  SE      W0,W0
023E6:  MOV     W0,W4
023E8:  MUL.UU  W4,#3,W0
023EA:  MOV     #84,W4
023EC:  ADD     W0,W4,W5
023EE:  MOV     W0,[W15++]
023F0:  MOV.B   #4,W0L
023F2:  MOV.B   W0L,876
023F4:  MOV     [--W15],W0
023F6:  CLR.B   877
023F8:  CLR.B   878
023FA:  CLR.B   879
023FC:  MOV     W5,870
023FE:  CLR     W4
02400:  BTSC.B  871.7
02402:  SETM    W4
02404:  MOV     W4,872
02406:  MOV     #804,W4
02408:  MOV     W4,874
0240A:  CALL    19D2
....................          } 
....................           
....................          a=0; 
0240E:  CLR.B   801
....................          for(i=0;i<8;i=i+2) 
02410:  CLR.B   802
02412:  MOV.B   802,W0L
02414:  SE      W0,W0
02416:  CP      W0,#8
02418:  BRA     GE,2460
....................          {  
....................             data_tosend[i]=temp[a]>>8; 
0241A:  MOV.B   802,W0L
0241C:  SE      W0,W0
0241E:  MOV     #804,W4
02420:  ADD     W0,W4,W5
02422:  MOV.B   801,W0L
02424:  SE      W0,W0
02426:  MOV     W0,W4
02428:  MUL.UU  W4,#2,W0
0242A:  MOV     #82C,W4
0242C:  ADD     W0,W4,W0
0242E:  MOV     [W0],W6
02430:  CLR.B   1
02432:  MOV.B   D,W0L
02434:  MOV.B   W0L,W0L
02436:  MOV.B   W0L,[W5]
....................             data_tosend[i+1]=temp[a]; 
02438:  MOV.B   802,W0L
0243A:  SE      W0,W0
0243C:  ADD     W0,#1,W0
0243E:  MOV     W0,W5
02440:  MOV     #804,W4
02442:  ADD     W5,W4,W6
02444:  MOV.B   801,W0L
02446:  SE      W0,W0
02448:  MOV     W0,W4
0244A:  MUL.UU  W4,#2,W0
0244C:  MOV     #82C,W4
0244E:  ADD     W0,W4,W0
02450:  MOV.B   [W0],[W6]
....................             a++; 
02452:  INC.B   0801
02454:  MOV.B   802,W0L
02456:  SE      W0,W0
02458:  ADD     W0,#2,W0
0245A:  MOV.B   W0L,802
0245C:  GOTO    2412
....................          } 
....................          can_putd((0xC0+slave*2),&data_tosend[0],8,0,0,0); 
02460:  MOV.B   85F,W0L
02462:  SE      W0,W0
02464:  MOV     W0,W4
02466:  MUL.UU  W4,#2,W0
02468:  MOV     #C0,W4
0246A:  ADD     W0,W4,W5
0246C:  MOV     W0,[W15++]
0246E:  MOV.B   #8,W0L
02470:  MOV.B   W0L,876
02472:  MOV     [--W15],W0
02474:  CLR.B   877
02476:  CLR.B   878
02478:  CLR.B   879
0247A:  MOV     W5,870
0247C:  CLR     W4
0247E:  BTSC.B  871.7
02480:  SETM    W4
02482:  MOV     W4,872
02484:  MOV     #804,W4
02486:  MOV     W4,874
02488:  CALL    19D2
....................           
....................          for(i=0;i<8;i=i+2) 
0248C:  CLR.B   802
0248E:  MOV.B   802,W0L
02490:  SE      W0,W0
02492:  CP      W0,#8
02494:  BRA     GE,24DC
....................          {  
....................             data_tosend[i]=temp[a]>>8; 
02496:  MOV.B   802,W0L
02498:  SE      W0,W0
0249A:  MOV     #804,W4
0249C:  ADD     W0,W4,W5
0249E:  MOV.B   801,W0L
024A0:  SE      W0,W0
024A2:  MOV     W0,W4
024A4:  MUL.UU  W4,#2,W0
024A6:  MOV     #82C,W4
024A8:  ADD     W0,W4,W0
024AA:  MOV     [W0],W6
024AC:  CLR.B   1
024AE:  MOV.B   D,W0L
024B0:  MOV.B   W0L,W0L
024B2:  MOV.B   W0L,[W5]
....................             data_tosend[i+1]=temp[a]; 
024B4:  MOV.B   802,W0L
024B6:  SE      W0,W0
024B8:  ADD     W0,#1,W0
024BA:  MOV     W0,W5
024BC:  MOV     #804,W4
024BE:  ADD     W5,W4,W6
024C0:  MOV.B   801,W0L
024C2:  SE      W0,W0
024C4:  MOV     W0,W4
024C6:  MUL.UU  W4,#2,W0
024C8:  MOV     #82C,W4
024CA:  ADD     W0,W4,W0
024CC:  MOV.B   [W0],[W6]
....................             a++; 
024CE:  INC.B   0801
024D0:  MOV.B   802,W0L
024D2:  SE      W0,W0
024D4:  ADD     W0,#2,W0
024D6:  MOV.B   W0L,802
024D8:  GOTO    248E
....................          } 
....................          can_putd((0xC1+slave*2),&data_tosend[0],8,0,0,0); 
024DC:  MOV.B   85F,W0L
024DE:  SE      W0,W0
024E0:  MOV     W0,W4
024E2:  MUL.UU  W4,#2,W0
024E4:  MOV     #C1,W4
024E6:  ADD     W0,W4,W5
024E8:  MOV     W0,[W15++]
024EA:  MOV.B   #8,W0L
024EC:  MOV.B   W0L,876
024EE:  MOV     [--W15],W0
024F0:  CLR.B   877
024F2:  CLR.B   878
024F4:  CLR.B   879
024F6:  MOV     W5,870
024F8:  CLR     W4
024FA:  BTSC.B  871.7
024FC:  SETM    W4
024FE:  MOV     W4,872
02500:  MOV     #804,W4
02502:  MOV     W4,874
02504:  CALL    19D2
....................  
....................          //ADC voltage conversions 
....................          START_ADC_VOLTAGES(); 
02508:  CALL    18E0
....................          tim=0; 
0250C:  CLR     858
0250E:  CLR     85A
....................           
....................          //Balancing evaluation 
....................          BLANCEO(v_cell_minn, v_balanceo, v_min, diff_max, diff_min, &voltaje[0], temp_max, temp_slave_max); 
02510:  MOV     #80E,W4
02512:  MOV     W4,86C
....................           
....................          //Temperature readings 
....................          ADC_LTC1296(&temp[0]); 
*
02748:  MOV     #82C,W4
0274A:  MOV     W4,86C
0274C:  CALL    1922
....................           
....................          //Lowpass filter for temp readings 
....................          for(i=0;i<8;i++) 
02750:  CLR.B   802
02752:  MOV.B   802,W0L
02754:  SE      W0,W0
02756:  CP      W0,#8
02758:  BRA     GE,27B0
....................          { 
....................             temp[i]=(temp[i]+temp_prev[i])/2; 
0275A:  MOV.B   802,W0L
0275C:  SE      W0,W0
0275E:  MOV     W0,W4
02760:  MUL.UU  W4,#2,W0
02762:  MOV     #82C,W4
02764:  ADD     W0,W4,W5
02766:  MOV.B   802,W0L
02768:  SE      W0,W0
0276A:  MOV     W0,W4
0276C:  MUL.UU  W4,#2,W0
0276E:  MOV     #82C,W4
02770:  ADD     W0,W4,W0
02772:  MOV     [W0],W6
02774:  MOV.B   802,W0L
02776:  SE      W0,W0
02778:  MOV     W0,W4
0277A:  MUL.UU  W4,#2,W0
0277C:  MOV     #83C,W4
0277E:  ADD     W0,W4,W0
02780:  MOV     W0,W4
02782:  MOV     [W4],W0
02784:  ADD     W0,W6,W6
02786:  MOV     W6,W4
02788:  MOV     #2,W3
0278A:  REPEAT  #11
0278C:  DIV.S   W4,W3
0278E:  MOV     W0,[W5]
....................             temp_prev[i]=temp[i]; 
02790:  MOV.B   802,W0L
02792:  SE      W0,W0
02794:  MOV     W0,W4
02796:  MUL.UU  W4,#2,W0
02798:  MOV     #83C,W4
0279A:  ADD     W0,W4,W5
0279C:  MOV.B   802,W0L
0279E:  SE      W0,W0
027A0:  MOV     W0,W4
027A2:  MUL.UU  W4,#2,W0
027A4:  MOV     #82C,W4
027A6:  ADD     W0,W4,W0
027A8:  MOV     [W0],[W5]
027AA:  INC.B   0802
027AC:  GOTO    2752
....................          } 
....................           
....................          while(tim<70) {}  //Waiting until conversions have been done 
027B0:  MOV     85A,W4
027B2:  CP      W4,#0
027B4:  BRA     GT,27C4
027B6:  BRA     LT,27C0
027B8:  MOV     858,W4
027BA:  MOV     #46,W3
027BC:  CP      W3,W4
027BE:  BRA     LEU,27C4
027C0:  GOTO    27B0
....................           
....................          //Voltage readings 
....................          READ_VOLTAGES (&voltaje[0], total, v_cell_min, v_cell_max); 
027C4:  MOV     #80E,W4
027C6:  MOV     W4,86C
027C8:  PUSH    828
027CA:  POP     86E
027CC:  PUSH    82A
027CE:  POP     870
....................       } 
*
02C18:  GOTO    2C20
....................       else 
....................       { 
....................         output_low(LED1); 
02C1C:  BCLR.B  2C9.5
02C1E:  BCLR.B  2CD.5
....................       } 
02C20:  GOTO    225E
....................    } 
.................... } 
02C24:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00CF   NOWRTB NOBSS NORBS
          H: FF00  
   Word  2L: 00CF   NOWRTSS NOSSS NORSS
          H: FF00  
   Word  3L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  4L: 0002   PR NOIESO
          H: FF00  
   Word  5L: 0026   HS NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: FF00  
   Word  7L: 0010   NOPUT NOALTI2C1
          H: FF00  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: FF00  
